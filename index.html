<!DOCTYPE html>
<html lang="vi" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Trading Bot Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #d1d5db; }
        .card { background-color: #1f2937; border: 1px solid #374151; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.625rem 1.25rem; border-radius: 0.5rem; font-weight: 500; transition: background-color 0.2s, opacity 0.2s; cursor: pointer; opacity: 1; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .input-field, textarea { width: 100%; background-color: #374151; border: 1px solid #4b5563; color: #d1d5db; border-radius: 0.5rem; padding: 0.625rem; transition: border-color 0.2s, box-shadow 0.2s; }
        .input-field:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px #1e40af; }
        .status-badge { padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; display: inline-block; }
        .status-running { background-color: #10b981; color: #064e3b; }
        .status-stopped { background-color: #f87171; color: #991b1b; }
        .status-cooldown { background-color: #f59e0b; color: #92400e; }
        .log-container { height: 350px; background-color: #111827; border: 1px solid #374151; border-radius: 0.5rem; padding: 0.75rem; overflow-y: auto; font-family: monospace; font-size: 0.875rem; }
        #currentPrice.price-up { color: #10b981; transition: color 0.2s ease; }
        #currentPrice.price-down { color: #ef4444; transition: color 0.2s ease; }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-white">Bảng điều khiển Bot Giao dịch Bybit (Advanced Order Flow)</h1>
            <p class="text-gray-400 mt-1">Sử dụng phân tích dòng lệnh nâng cao để tìm kiếm các cơ hội giao dịch có xác suất cao.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Cột cài đặt -->
            <div class="lg:col-span-1 space-y-6">
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Cài đặt API</h2>
                    <div class="space-y-4">
                        <div><label for="apiKey" class="block text-sm font-medium mb-1">API Key</label><input type="password" id="apiKey" class="input-field" placeholder="Nhập API Key của bạn"></div>
                        <div><label for="apiSecret" class="block text-sm font-medium mb-1">API Secret</label><input type="password" id="apiSecret" class="input-field" placeholder="Nhập API Secret của bạn"></div>
                        <button id="saveApi" class="btn btn-primary w-full pt-2">Lưu API</button>
                    </div>
                </div>
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Cấu hình Bot</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                           <div><label for="orderValue" class="block text-sm font-medium mb-1">Giá trị lệnh ($)</label><input type="number" id="orderValue" class="input-field" step="1" value="8"></div>
                           <div><label for="timeStop" class="block text-sm font-medium mb-1">Time Stop (giây)</label><input type="number" id="timeStop" class="input-field" value="120"></div>
                        </div>
                         <div class="grid grid-cols-2 gap-4 pt-2">
                            <button id="startBot" class="btn btn-primary">Bắt đầu</button>
                            <button id="stopBot" class="btn btn-danger">Dừng</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cột thông tin và nhật ký -->
            <div class="lg:col-span-2 space-y-6">
                 <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Trạng thái Hệ thống</h2>
                    <div class="grid grid-cols-2 lg:grid-cols-3 gap-4">
                        <div><span class="text-gray-400">Trạng thái Bot:</span> <span id="botStatus" class="status-badge status-stopped ml-2">Đã dừng</span></div>
                        <div><span class="text-gray-400">Số dư USDT:</span> <span id="usdtBalance" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Cặp tiềm năng:</span> <span id="topCoin" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Pump Score:</span> <span id="pumpScore" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Advanced Score:</span> <span id="advancedScore" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Giá theo dõi:</span> <span id="currentPrice" class="text-white font-semibold ml-2 text-lg">--</span></div>
                        <div class="lg:col-span-3"><span class="text-gray-400">Vị thế hiện tại:</span> <span id="currentPosition" class="text-white font-semibold ml-2">Không có</span></div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Nhật ký hoạt động</h2>
                    <div id="logContainer" class="log-container">
                        <p class="text-gray-500">Chờ bot khởi động...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const elements = {
                apiKeyInput: document.getElementById('apiKey'), apiSecretInput: document.getElementById('apiSecret'), saveApiButton: document.getElementById('saveApi'),
                startBotButton: document.getElementById('startBot'), stopBotButton: document.getElementById('stopBot'), orderValueInput: document.getElementById('orderValue'),
                timeStopInput: document.getElementById('timeStop'), botStatus: document.getElementById('botStatus'), usdtBalance: document.getElementById('usdtBalance'),
                topCoin: document.getElementById('topCoin'), pumpScore: document.getElementById('pumpScore'), advancedScore: document.getElementById('advancedScore'),
                currentPosition: document.getElementById('currentPosition'), logContainer: document.getElementById('logContainer'), currentPriceEl: document.getElementById('currentPrice'),
            };

            // --- State Variables ---
            let state = {
                botInterval: null, apiKey: '', apiSecret: '', ws: null, pingInterval: null, lastPrice: 0, isBotRunning: false,
                instrumentInfo: new Map(), cooldownUntil: 0, activeSymbolWs: null, position: { hasPosition: false, symbol: null, entryTime: 0, coin: null },
                risk: { consecutiveLosses: 0 }, realtimeData: new Map(), timeOffset: 0, isTimeSynced: false,
            };

            // --- WebSocket for Real-time Data ---
            function connectWebSocket(symbol) {
                if (state.activeSymbolWs === symbol) return;
                if (state.ws) { state.ws.close(); }
                if (state.pingInterval) { clearInterval(state.pingInterval); }
                
                state.activeSymbolWs = symbol;
                elements.currentPriceEl.textContent = '--';
                if (!state.realtimeData.has(symbol)) {
                    state.realtimeData.set(symbol, { orderbook: null, trades: [], cvd: 0, micropriceTilts: [], iceberg: { price: 0, displayed: 0, traded: 0 } });
                }
                
                state.ws = new WebSocket('wss://stream.bybit.com/v5/public/spot');
                state.ws.onopen = () => {
                    addLog(`Đã kết nối WebSocket cho ${symbol}.`);
                    state.ws.send(JSON.stringify({ op: 'subscribe', args: [`publicTrade.${symbol}`, `orderbook.50.${symbol}`] }));
                    state.pingInterval = setInterval(() => { if (state.ws.readyState === WebSocket.OPEN) state.ws.send(JSON.stringify({ op: 'ping' })); }, 28000);
                };
                state.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const symbolData = state.realtimeData.get(symbol);
                    if (!symbolData) return;

                    if (data.topic?.startsWith('publicTrade')) {
                        const trade = data.data[0];
                        const newPrice = parseFloat(trade.p);
                        elements.currentPriceEl.classList.toggle('price-up', newPrice > state.lastPrice);
                        elements.currentPriceEl.classList.toggle('price-down', newPrice < state.lastPrice);
                        elements.currentPriceEl.textContent = newPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 });
                        state.lastPrice = newPrice;
                        const volume = parseFloat(trade.v);
                        if (trade.S === 'Buy') symbolData.cvd += volume; else symbolData.cvd -= volume;
                        if(symbolData.orderbook?.b.length > 0 && newPrice === parseFloat(symbolData.orderbook.b[0][0])) {
                            if(symbolData.iceberg.price === newPrice) { symbolData.iceberg.traded += volume; } 
                            else { symbolData.iceberg.price = newPrice; symbolData.iceberg.displayed = parseFloat(symbolData.orderbook.b[0][1]); symbolData.iceberg.traded = volume; }
                        }
                    } else if (data.topic?.startsWith('orderbook')) {
                        symbolData.orderbook = data.data;
                        if (symbolData.orderbook.b.length > 0 && symbolData.orderbook.a.length > 0) {
                            const [pBid, qBid] = [parseFloat(symbolData.orderbook.b[0][0]), parseFloat(symbolData.orderbook.b[0][1])];
                            const [pAsk, qAsk] = [parseFloat(symbolData.orderbook.a[0][0]), parseFloat(symbolData.orderbook.a[0][1])];
                            if (qBid + qAsk > 0) {
                                const microprice = (pAsk * qBid + pBid * qAsk) / (qBid + qAsk);
                                const midprice = (pAsk + pBid) / 2;
                                const tilt = (microprice - midprice) / midprice * 100;
                                symbolData.micropriceTilts.push(tilt);
                                if (symbolData.micropriceTilts.length > 5) symbolData.micropriceTilts.shift();
                            }
                        }
                    }
                };
                state.ws.onclose = () => { addLog('Kết nối WebSocket đã đóng.', 'info'); if(state.pingInterval) clearInterval(state.pingInterval); };
                state.ws.onerror = (error) => addLog(`Lỗi WebSocket: ${error.message || 'Unknown error'}`, 'error');
            }
            
            // --- API Communication & Time Sync ---
            async function syncTime() {
                 try {
                    addLog('Bắt đầu đồng bộ thời gian với máy chủ Bybit...', 'info');
                    const serverTimeRes = await fetch('https://api.bybit.com/v5/market/time?_=' + new Date().getTime(), { cache: 'no-cache' });
                    const serverTimeData = await serverTimeRes.json();
                    if (serverTimeData.retCode === 0) {
                        const serverTime = parseInt(serverTimeData.result.timeNano) / 1000000;
                        const oldOffset = state.timeOffset;
                        state.timeOffset = serverTime - Date.now();
                        state.isTimeSynced = true;
                        addLog(`Đồng bộ thời gian thành công. Lệch: ${state.timeOffset.toFixed(0)}ms (thay đổi: ${(state.timeOffset - oldOffset).toFixed(0)}ms).`, 'success');
                        return true;
                    } else {
                       throw new Error(serverTimeData.retMsg);
                    }
                } catch (e) {
                    state.isTimeSynced = false;
                    addLog(`Lỗi đồng bộ thời gian: ${e.message}. API có thể không hoạt động.`, 'error');
                    return false;
                }
            }

            async function bybitRequest(endpoint, method, params, isRetry = false) {
                if (!state.apiKey || !state.apiSecret) { addLog('Lỗi: Vui lòng lưu API Key và Secret trước.', 'error'); return null; }
                if (!state.isTimeSynced && !isRetry) {
                    addLog('Lỗi: Thời gian chưa được đồng bộ. Đang thử đồng bộ lại...', 'info');
                    const syncSuccess = await syncTime();
                    if (!syncSuccess) return null;
                }

                const API_BASE = 'https://api.bybit.com';
                const timestamp = (Date.now() + state.timeOffset).toString();
                const recvWindow = '20000';
                
                let signaturePayload;
                let body = null;
                let url = new URL(API_BASE + endpoint);

                if (method === 'GET') {
                    signaturePayload = Object.entries(params).sort(([a], [b]) => a.localeCompare(b)).map(([k, v]) => `${k}=${v}`).join('&');
                    if (signaturePayload) { url.search = signaturePayload; }
                } else { // POST
                    signaturePayload = JSON.stringify(params);
                    body = signaturePayload;
                }

                const stringToSign = timestamp + state.apiKey + recvWindow + signaturePayload;
                const signature = CryptoJS.HmacSHA256(stringToSign, state.apiSecret).toString();
                
                const headers = { 'Content-Type': 'application/json', 'X-BAPI-API-KEY': state.apiKey, 'X-BAPI-TIMESTAMP': timestamp, 'X-BAPI-RECV-WINDOW': recvWindow, 'X-BAPI-SIGN': signature, };

                try {
                    const response = await fetch(url, { method, headers, body });
                    const data = await response.json();

                    if (data.retCode === 10001 && data.retMsg.includes('timestamp') && !isRetry) {
                        addLog(`Phát hiện lỗi timestamp (10001). Tự động đồng bộ lại thời gian và thử lại...`, 'info');
                        const syncSuccess = await syncTime();
                        if (syncSuccess) {
                            return await bybitRequest(endpoint, method, params, true); // Retry once
                        } else {
                            addLog('Thử lại thất bại do không thể đồng bộ thời gian.', 'error');
                            return null;
                        }
                    }

                    if (data.retCode !== 0) { addLog(`Lỗi API (${endpoint}): ${data.retMsg} (Code: ${data.retCode})`, 'error'); return null; }
                    return data.result;
                } catch (error) { addLog(`Lỗi mạng: ${error.message}`, 'error'); return null; }
            }
            
            // --- UI & Helper Functions ---
            const addLog = (message, type = 'info') => {
                const p = document.createElement('p');
                p.innerHTML = `<span class="text-gray-500">${new Date().toLocaleTimeString()}</span> - ${message}`;
                if (type === 'error') p.className = 'text-red-400';
                if (type === 'success') p.className = 'text-green-400';
                elements.logContainer.appendChild(p);
                elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            };
            const setBotStatusUI = (status) => {
                state.isBotRunning = (status === 'running');
                let text = 'Đã dừng', className = 'status-stopped';
                if (status === 'running') { text = 'Đang chạy'; className = 'status-running'; }
                if (status === 'cooldown') { text = 'Tạm nghỉ'; className = 'status-cooldown'; }
                elements.botStatus.textContent = text;
                elements.botStatus.className = `status-badge ml-2 ${className}`;
                elements.startBotButton.disabled = state.isBotRunning;
                elements.stopBotButton.disabled = !state.isBotRunning;
            };
            const roundToTickSize = (num, tickSize) => Math.floor(num / tickSize) * tickSize;

            // --- Technical Analysis Calculations ---
            const calculateEMA = (d, p) => { const k = 2/(p+1); let e=[d[0]]; for(let i=1;i<d.length;i++) e.push(d[i]*k+e[i-1]*(1-k)); return e; };
            const calculateATR = (klines, p) => { let tr=[]; for(let i=1;i<klines.length;i++) {tr.push(Math.max(klines[i].high-klines[i].low,Math.abs(klines[i].high-klines[i-1].close),Math.abs(klines[i].low-klines[i-1].close)));} return calculateEMA(tr, p).pop(); };
            const calculateVWAP = (klines, p) => { const rk=klines.slice(-p); let pv=0, v=0; rk.forEach(k => { pv += ((k.high+k.low+k.close)/3)*k.volume; v+=k.volume; }); return v > 0 ? pv/v : 0; };

            // --- Core Bot Logic ---
            async function runBotLogic() {
                if (!state.isTimeSynced) {
                    addLog('Dừng quét do thời gian chưa được đồng bộ.', 'error');
                    elements.stopBotButton.click();
                    return;
                }
                if (Date.now() < state.cooldownUntil) {
                    setBotStatusUI('cooldown');
                    addLog(`Bot đang trong thời gian nghỉ, còn lại ${Math.round((state.cooldownUntil - Date.now()) / 1000)}s...`);
                    return;
                }
                if(state.isBotRunning) setBotStatusUI('running');
                await updatePositionStatus();
                if (state.position.hasPosition) { await manageOpenPosition(); } else { await scanAndTrade(); }
            }
            
            async function discoverPromisingPairs() {
                addLog('Đang tự động tìm kiếm các cặp giao dịch tiềm năng...');
                const tickersData = await bybitRequest('/v5/market/tickers', 'GET', { category: 'spot' });
                if (!tickersData?.list) { addLog('Không thể tải danh sách tickers từ Bybit.', 'error'); return []; }
                const promisingPairs = tickersData.list.filter(t=>t.symbol.endsWith('USDT')).sort((a,b)=>parseFloat(b.turnover24h)-parseFloat(a.turnover24h)).slice(0,40).map(t=>t.symbol);
                if (promisingPairs.length > 0) addLog(`Đã chọn Top ${promisingPairs.length} cặp theo volume 24h để quét chi tiết.`, 'success');
                return promisingPairs;
            }

            async function scanAndTrade() {
                addLog('Bắt đầu quét thị trường...');
                const coinList = await discoverPromisingPairs();
                if (!coinList || coinList.length === 0) { addLog('Không tìm thấy cặp nào tiềm năng để quét.', 'info'); return; }
                
                let scoredCoins = [];
                for (const symbol of coinList) {
                    try {
                        const scores = await calculateScores(symbol);
                        if(scores) scoredCoins.push({ symbol, ...scores });
                    } catch (e) { addLog(`Lỗi khi quét ${symbol}: ${e.message}`, 'error'); }
                }
                
                if (scoredCoins.length === 0) { addLog('Không tìm thấy cặp nào đạt chuẩn.'); elements.topCoin.textContent='--'; elements.pumpScore.textContent='--'; elements.advancedScore.textContent='--'; return; }
                
                scoredCoins.sort((a, b) => (b.pumpScore + b.advancedScore) - (a.pumpScore + a.advancedScore));
                const topCoin = scoredCoins[0];
                
                elements.topCoin.textContent = topCoin.symbol;
                elements.pumpScore.textContent = `${topCoin.pumpScore.toFixed(0)}/100`;
                elements.advancedScore.textContent = `${topCoin.advancedScore.toFixed(0)}/60`;
                connectWebSocket(topCoin.symbol);

                if (topCoin.pumpScore >= 60 && topCoin.advancedScore >= 30) {
                    addLog(`Cặp tiềm năng: ${topCoin.symbol} (Pump: ${topCoin.pumpScore.toFixed(0)}, Adv: ${topCoin.advancedScore.toFixed(0)}). Chuẩn bị vào lệnh.`, 'success');
                    await executeTrade(topCoin);
                } else {
                    addLog(`Cặp tốt nhất ${topCoin.symbol} chưa đạt ngưỡng (Pump: ${topCoin.pumpScore.toFixed(0)}, Adv: ${topCoin.advancedScore.toFixed(0)}).`);
                }
            }

            async function calculateScores(symbol) {
                const klineData = await bybitRequest('/v5/market/kline', 'GET', { category: 'spot', symbol, interval: '1', limit: 100 });
                const realtime = state.realtimeData.get(symbol);
                if (!klineData?.list || klineData.list.length < 50 || !realtime?.orderbook) return null;
                const klines = klineData.list.map(k=>({time:k[0],open:parseFloat(k[1]),high:parseFloat(k[2]),low:parseFloat(k[3]),close:parseFloat(k[4]),volume:parseFloat(k[5])})).reverse();
                
                let pumpScore = 0;
                const currentPrice = klines[klines.length-1].close;
                const orderBookData = realtime.orderbook;
                const bestBid = parseFloat(orderBookData.b[0][0]), bestAsk = parseFloat(orderBookData.a[0][0]);
                const spread = (bestAsk - bestBid) / bestAsk * 100;
                if (spread <= 0.06) pumpScore += 15;
                let depth10 = 0; orderBookData.b.forEach(([p,s]) => { if (parseFloat(p) >= bestBid*0.999) depth10 += parseFloat(s)*parseFloat(p); });
                if (depth10 >= 10 * parseFloat(elements.orderValueInput.value)) pumpScore += 15;
                const bidNotional = orderBookData.b.slice(0,5).reduce((a,[p,s])=>a+(parseFloat(p)*parseFloat(s)),0);
                const askNotional = orderBookData.a.slice(0,5).reduce((a,[p,s])=>a+(parseFloat(p)*parseFloat(s)),0);
                if (askNotional > 0 && (bidNotional/askNotional) >= 1.2) pumpScore += 10;
                if (pumpScore < 30) return null;

                const closes = klines.map(k => k.close);
                if (closes[closes.length-1] > closes[closes.length-2]) pumpScore += 10;
                if (closes[closes.length-1] > closes[closes.length-4]) pumpScore += 10;
                const [ema9,ema20,ema50] = [calculateEMA(closes,9).pop(),calculateEMA(closes,20).pop(),calculateEMA(closes,50).pop()];
                if (ema9>ema20 && ema20>ema50) pumpScore += 10;
                const atr = calculateATR(klines, 14);
                if (Math.abs(klines[klines.length-1].close - klines[klines.length-1].open) < 1.5 * atr && Math.abs(klines[klines.length-2].close-klines[klines.length-2].open) < 1.5 * atr) pumpScore += 5;
                const atrPercent = (atr / currentPrice) * 100;
                if (atrPercent >= 0.20 && atrPercent <= 0.80) pumpScore += 15;
                const vwap = calculateVWAP(klines, 20);
                if (currentPrice > vwap) pumpScore += 10;

                let advancedScore = 0;
                if (realtime.micropriceTilts.length >= 3 && realtime.micropriceTilts.slice(-3).every(t => t >= 0.02)) advancedScore += 10;
                const cumBid = orderBookData.b.slice(0,5).reduce((a,[,s])=>a+parseFloat(s),0);
                const cumAsk = orderBookData.a.slice(0,5).reduce((a,[,s])=>a+parseFloat(s),0);
                if (cumBid + cumAsk > 0 && (cumBid - cumAsk) / (cumBid + cumAsk) >= 0.2) advancedScore += 10;
                const cvdTrend = realtime.cvd > (state.realtimeData.get(symbol)?.trades[0]?.cvd_start || 0);
                const priceTrend = currentPrice > klines[klines.length-5].close;
                if (cvdTrend && !priceTrend) advancedScore += 10;
                if (realtime.iceberg.traded > realtime.iceberg.displayed * 1.5) advancedScore += 10;
                
                return { pumpScore, advancedScore, currentPrice, spread, atrPercent, vwap, ema20, klines };
            }
            
            async function executeTrade(coinData) {
                const { symbol, advancedScore, currentPrice, spread, atrPercent, vwap, ema20, klines } = coinData;
                const info = state.instrumentInfo.get(symbol);
                if (!info) return addLog(`Thiếu thông tin của cặp ${symbol}`, 'error');

                const orderValue = parseFloat(elements.orderValueInput.value);
                const minOrderValue = parseFloat(info.lotSizeFilter.minOrderValue || '5');
                if(orderValue < minOrderValue) return addLog(`Giá trị lệnh ${orderValue}$ quá nhỏ cho ${symbol} (yêu cầu ≥ ${minOrderValue}$).`);

                const pullbackFactor = advancedScore >= 30 ? 0.45 : 0.6;
                const hh20 = Math.max(...klines.slice(-20).map(k => k.high));
                const vungChuan = Math.max(vwap, ema20, hh20);
                const atrStep = (atrPercent / 100) * currentPrice;
                const entryPrice = roundToTickSize(vungChuan - pullbackFactor * atrStep, parseFloat(info.priceFilter.tickSize));
                const tpPercent = Math.max(0.50, 1.2 * spread, 0.8 * atrPercent) / 100;
                const takeProfitPrice = roundToTickSize(entryPrice * (1 + tpPercent), parseFloat(info.priceFilter.tickSize));
                const stopLossPrice = roundToTickSize(vungChuan * 0.996, parseFloat(info.priceFilter.tickSize));
                const qty = Math.floor((orderValue / entryPrice) / parseFloat(info.lotSizeFilter.qtyStep)) * parseFloat(info.lotSizeFilter.qtyStep);

                addLog(`Chuẩn bị lệnh MUA ${qty} ${symbol} tại ${entryPrice} (pullback ${pullbackFactor}x). TP: ${takeProfitPrice}, SL: ${stopLossPrice}`, 'success');
                const orderResult = await bybitRequest('/v5/order/create', 'POST', {
                    category: 'spot', symbol, side: 'Buy', orderType: 'Limit', qty: qty.toString(),
                    price: entryPrice.toString(), timeInForce: 'PostOnly',
                    takeProfit: takeProfitPrice.toString(), stopLoss: stopLossPrice.toString(),
                });
                
                if (orderResult?.orderId) {
                    addLog(`Đặt lệnh thành công. OrderID: ${orderResult.orderId}`, 'success');
                    state.position.entryTime = Date.now() + state.timeOffset;
                }
            }

            async function manageOpenPosition() {
                const timeStopSeconds = parseInt(elements.timeStopInput.value);
                const elapsedSeconds = ((Date.now() + state.timeOffset) - state.position.entryTime) / 1000;
                if (elapsedSeconds > timeStopSeconds) {
                    addLog(`Vị thế đã vượt quá Time-Stop (${timeStopSeconds}s). Đang đóng...`, 'info');
                    await closePosition(state.position.symbol, state.position.coin);
                } else {
                    addLog(`Đang giữ ${state.position.symbol}. Thời gian mở: ${Math.round(elapsedSeconds)}s / ${timeStopSeconds}s.`);
                }
            }
            
            async function updatePositionStatus() {
                 const portfolio = await bybitRequest('/v5/asset/transfer/query-account-coins-balance', 'GET', { accountType: "UNIFIED" });
                 if (!portfolio) return;
                 const usdtBalance = portfolio.balance.find(c => c.coin === 'USDT');
                 if (usdtBalance) elements.usdtBalance.textContent = parseFloat(usdtBalance.walletBalance).toFixed(2);
                 const openPositions = portfolio.balance.filter(c => c.coin !== 'USDT' && parseFloat(c.walletBalance) > 1e-6);
                 if (openPositions.length > 0) {
                     if (!state.position.hasPosition) { state.risk.consecutiveLosses = 0; addLog('Phát hiện vị thế mới.', 'success'); }
                     state.position.hasPosition = true;
                     const pos = openPositions[0];
                     state.position.symbol = pos.coin + 'USDT';
                     state.position.coin = pos.coin;
                     elements.currentPosition.textContent = `${pos.coin}: ${parseFloat(pos.walletBalance)}`;
                 } else {
                     if (state.position.hasPosition) { addLog('Vị thế đã được đóng.', 'info'); }
                     state.position.hasPosition = false;
                     elements.currentPosition.textContent = 'Không có';
                 }
            }

            async function closePosition(symbol, coin) {
                addLog(`Đang đóng vị thế ${symbol} bằng lệnh Market...`, 'info');
                await bybitRequest('/v5/order/cancel-all', 'POST', { category: 'spot', symbol });
                const portfolio = await bybitRequest('/v5/asset/transfer/query-account-coins-balance', 'GET', { accountType: "UNIFIED", coin });
                const coinBalance = portfolio?.balance[0];
                if (coinBalance && parseFloat(coinBalance.walletBalance) > 0) {
                    const info = state.instrumentInfo.get(symbol);
                    const qty = Math.floor(parseFloat(coinBalance.walletBalance)/parseFloat(info.lotSizeFilter.qtyStep))*parseFloat(info.lotSizeFilter.qtyStep);
                    if(qty > 0) {
                        const closeResult = await bybitRequest('/v5/order/create', 'POST', { category: 'spot', symbol, side: 'Sell', orderType: 'Market', qty: qty.toString() });
                        if (closeResult?.orderId) { addLog('Đóng vị thế thành công.', 'success'); state.risk.consecutiveLosses++; }
                    }
                }
                state.position.hasPosition = false;
                if(state.risk.consecutiveLosses >= 2) {
                    addLog('2 lệnh thua liên tiếp, tạm nghỉ 30 phút.', 'error');
                    state.cooldownUntil = Date.now() + 30 * 60 * 1000;
                    state.risk.consecutiveLosses = 0;
                }
            }

            // --- Event Listeners & Initialization ---
            elements.saveApiButton.addEventListener('click', async () => {
                state.apiKey = elements.apiKeyInput.value.trim();
                state.apiSecret = elements.apiSecretInput.value.trim();
                if (state.apiKey && state.apiSecret) {
                    localStorage.setItem('bybitApiKey', state.apiKey);
                    localStorage.setItem('bybitApiSecret', state.apiSecret);
                    
                    const syncSuccess = await syncTime();
                    if (!syncSuccess) {
                        addLog('Không thể khởi tạo bot do lỗi đồng bộ thời gian. Vui lòng thử lại.', 'error');
                        return;
                    }

                    addLog('Đã lưu khóa API thành công.', 'success');
                    await updatePositionStatus();
                    addLog('Đang tải thông tin các cặp giao dịch...');
                    const instruments = await bybitRequest('/v5/market/instruments-info', 'GET', { category: 'spot', limit: 1000 });
                    if (instruments?.list) {
                        instruments.list.forEach(i => state.instrumentInfo.set(i.symbol, i));
                        addLog(`Đã tải thông tin cho ${state.instrumentInfo.size} cặp. Bot đã sẵn sàng.`, 'success');
                    } else { addLog('Không thể tải thông tin cặp giao dịch.', 'error'); }
                } else { addLog('Vui lòng nhập cả API Key và Secret.', 'error'); }
            });
            elements.startBotButton.addEventListener('click', async () => {
                if (!state.apiKey || !state.apiSecret) return addLog('Lỗi: Vui lòng lưu API trước khi bắt đầu.', 'error');
                
                addLog('Đang kiểm tra & đồng bộ lại thời gian trước khi bắt đầu...', 'info');
                const syncSuccess = await syncTime();
                if (!syncSuccess) {
                    return addLog('Lỗi: Đồng bộ thời gian thất bại. Không thể bắt đầu bot.', 'error');
                }

                if (state.instrumentInfo.size === 0) return addLog('Lỗi: Chưa có thông tin cặp giao dịch. Vui lòng lưu lại API.', 'error');

                addLog('Bot đã bắt đầu quét...', 'success');
                setBotStatusUI('running');
                
                if (state.botInterval) clearInterval(state.botInterval);
                state.botInterval = setInterval(runBotLogic, 15000);
            });
            elements.stopBotButton.addEventListener('click', () => {
                if (state.botInterval) clearInterval(state.botInterval);
                state.botInterval = null;
                addLog('Bot đã dừng.', 'info');
                setBotStatusUI('stopped');
            });
            function initialize() {
                const storedApiKey = localStorage.getItem('bybitApiKey');
                const storedApiSecret = localStorage.getItem('bybitApiSecret');
                if (storedApiKey && storedApiSecret) {
                    elements.apiKeyInput.value = storedApiKey;
                    elements.apiSecretInput.value = storedApiSecret;
                    elements.saveApiButton.click();
                } else { addLog('Chào mừng! Vui lòng nhập và lưu khóa API Bybit của bạn.'); }
                setBotStatusUI('stopped');
            }
            initialize();
        });
    </script>
</body>
</html>

