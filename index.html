<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Trading Bot</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CryptoJS for API signature generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Chart.js for charting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .log-area { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-break: break-all; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .tab-active {
            border-bottom-width: 2px;
            border-color: #0891B2; /* cyan-500 */
            color: #ffffff;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-7xl mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6">
        
        <header class="text-center">
            <h1 class="text-3xl font-bold text-white">Bybit Trading Bot</h1>
            <p class="text-gray-400 mt-2">Giao dịch tự động và quản lý tài khoản Bybit của bạn.</p>
        </header>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Left Column: Settings, Account -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-gray-700/50 p-6 rounded-xl">
                     <div class="flex items-center justify-between border-b border-gray-600 pb-3 mb-4">
                        <h2 class="text-xl font-semibold">Cài đặt API</h2>
                        <span id="apiStatus" class="text-xs font-medium px-2.5 py-1 rounded-full">&nbsp;</span>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label for="apiKey" class="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                            <input type="password" id="apiKey" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="apiSecret" class="block text-sm font-medium text-gray-300 mb-1">API Secret</label>
                            <input type="password" id="apiSecret" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500">
                        </div>
                         <div class="flex items-center justify-between">
                            <button id="saveApi" class="w-2/3 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105">Lưu API Key</button>
                            <div class="flex items-center space-x-2 text-sm">
                               <label for="showApiKeys" class="text-gray-400">Hiện</label>
                               <input type="checkbox" id="showApiKeys" class="form-checkbox h-5 w-5 text-blue-500 bg-gray-900 border-gray-600 rounded focus:ring-blue-500">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <h2 class="text-xl font-semibold mb-3 border-b border-gray-600 pb-3">Thông tin tài khoản</h2>
                    <div id="balanceInfo" class="bg-gray-900 p-4 rounded-lg text-sm min-h-[120px]">
                        Vui lòng xác thực API để xem số dư...
                    </div>
                </div>
            </div>

            <!-- Right Column: Dashboard & Scanner -->
            <div class="lg:col-span-2 space-y-6">
                 <!-- Trading Dashboard -->
                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <div class="flex justify-between items-center border-b border-gray-600 mb-4">
                        <div class="flex">
                            <button id="priceChartTab" class="py-2 px-4 font-semibold tab-active">Biểu Đồ Giá</button>
                            <button id="pnlChartTab" class="py-2 px-4 text-gray-400 font-semibold">Lịch Sử PNL</button>
                        </div>
                        <button id="clearPnlHistoryBtn" class="py-1 px-2 text-xs bg-red-800 hover:bg-red-700 rounded-md hidden">Xóa Lịch Sử</button>
                    </div>
                    <div id="priceChartContainer" class="bg-gray-900 rounded-lg p-4 h-64">
                        <canvas id="priceChart"></canvas>
                    </div>
                     <div id="pnlChartContainer" class="bg-gray-900 rounded-lg p-4 h-64 hidden">
                        <canvas id="pnlChart"></canvas>
                    </div>
                </div>
                 <!-- Market Scanner Section -->
                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <h2 class="text-xl font-semibold border-b border-gray-600 pb-3 mb-4">Bot Giao Dịch Theo Xu Hướng (V4.3.1)</h2>
                     <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                        <div class="md:col-span-1">
                            <label for="scannerCapital" class="block text-sm font-medium text-gray-300 mb-1">Vốn Tối Đa / Lệnh</label>
                            <input type="number" id="scannerCapital" value="8" step="1" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200">
                        </div>
                        <div class="md:col-span-1 flex items-end pb-1">
                             <label for="autoTradeToggle" class="flex items-center cursor-pointer">
                                <div class="relative">
                                    <input type="checkbox" id="autoTradeToggle" class="sr-only peer">
                                    <div class="block bg-gray-600 w-14 h-8 rounded-full peer-checked:bg-green-600"></div>
                                    <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform transform peer-checked:translate-x-full"></div>
                                </div>
                                <span class="ml-3 text-sm font-medium text-gray-300">Tự động</span>
                            </label>
                        </div>
                        <div class="md:col-span-1 grid grid-cols-2 gap-2">
                            <button id="startScannerBtn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-500" disabled>Bắt đầu</button>
                            <button id="stopScannerBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition" disabled>Dừng</button>
                        </div>
                    </div>
                    <div id="scannerStatus" class="mt-4 bg-gray-900 p-3 rounded-lg text-sm text-center">Công cụ quét đang không hoạt động.</div>
                </div>
            </div>
        </div>

        <!-- Trading Plan Cards Container -->
        <div id="scannerResults" class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Trading Plan Cards will be populated here -->
        </div>
        
        <!-- CSH-RT Bot Section -->
        <div class="bg-gray-700/50 p-6 rounded-xl mt-6">
            <h2 class="text-xl font-semibold border-b border-gray-600 pb-3 mb-4">Bot CSH-RT (V5.2.1 - Tích hợp OCO)</h2>
            <div class="bg-purple-900 border-l-4 border-purple-500 text-purple-100 p-4 rounded-lg mb-4" role="alert">
                <p><strong class="font-bold">Cách Hoạt Động:</strong> Tự động chọn cặp, đặt lệnh Maker kèm TP/SL (OCO) và tự hủy nếu không khớp trước khi nến đóng.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                <div>
                    <label for="cshCapital" class="block text-sm font-medium text-gray-300 mb-1">Vốn / Lệnh (USDT)</label>
                    <input type="number" id="cshCapital" value="5" step="1" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200">
                </div>
                <div class="md:col-span-2 grid grid-cols-2 gap-2">
                    <button id="startCshBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-500" disabled>Bắt đầu Auto-Pick</button>
                    <button id="stopCshBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition" disabled>Dừng</button>
                </div>
            </div>
            <div id="cshStatusContainer" class="mt-4 space-y-2">
                <p class="text-center text-gray-500">Bot CSH-RT đang không hoạt động.</p>
            </div>
        </div>

        <!-- Log Area -->
        <div class="bg-gray-900/70 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-semibold mb-2">Nhật ký hoạt động</h2>
            <div id="log" class="log-area bg-black h-64 overflow-y-auto p-3 rounded-lg text-xs text-gray-400"></div>
        </div>

    </div>

    <!-- Loading Spinner Modal -->
    <div id="loaderModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="flex flex-col items-center">
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24"></div>
            <p id="loaderText" class="mt-4 text-white text-lg font-semibold">Đang xử lý...</p>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const ui = {
                apiKeyInput: document.getElementById('apiKey'),
                apiSecretInput: document.getElementById('apiSecret'),
                saveApiBtn: document.getElementById('saveApi'),
                showApiKeysCheckbox: document.getElementById('showApiKeys'),
                apiStatus: document.getElementById('apiStatus'),
                balanceInfoDiv: document.getElementById('balanceInfo'),
                logDiv: document.getElementById('log'),
                loaderModal: document.getElementById('loaderModal'),
                loaderText: document.getElementById('loaderText'),
                priceChartCanvas: document.getElementById('priceChart'),
                pnlChartCanvas: document.getElementById('pnlChart'),
                priceChartTab: document.getElementById('priceChartTab'),
                pnlChartTab: document.getElementById('pnlChartTab'),
                priceChartContainer: document.getElementById('priceChartContainer'),
                pnlChartContainer: document.getElementById('pnlChartContainer'),
                clearPnlHistoryBtn: document.getElementById('clearPnlHistoryBtn'),
                scanner: {
                    capital: document.getElementById('scannerCapital'),
                    autoTradeToggle: document.getElementById('autoTradeToggle'),
                    startBtn: document.getElementById('startScannerBtn'),
                    stopBtn: document.getElementById('stopScannerBtn'),
                    status: document.getElementById('scannerStatus'),
                    results: document.getElementById('scannerResults'),
                },
                csh: {
                    capitalInput: document.getElementById('cshCapital'),
                    startBtn: document.getElementById('startCshBtn'),
                    stopBtn: document.getElementById('stopCshBtn'),
                    statusContainer: document.getElementById('cshStatusContainer'),
                }
            };

            // --- State Management ---
            const state = {
                apiKey: '',
                apiSecret: '',
                scannerIntervalId: null,
                balanceUpdateIntervalId: null,
                isScanning: false,
                apiKeysValid: false,
                autoTradeEnabled: false,
                activeTrade: null,
                priceChart: null,
                pnlChart: null,
                pnlHistory: [],
                scannedCandidates: new Map(),
                availableUsdt: 0,
            };

            // --- Constants & Config ---
            const CONSTANTS = {
                BYBIT_API_URL: 'https://api.bybit.com',
                WS_SPOT_URL: "wss://stream.bybit.com/v5/public/spot",
                RECV_WINDOW: '10000', 
                SCANNER_INTERVAL_MS: 120000, 
                TRADE_MONITOR_INTERVAL_MS: 7000,
                BALANCE_UPDATE_INTERVAL_MS: 60000,
            };
            const CONFIG = {
                MIN_ORDER_VALUE_USDT: 3, 
                MIN_TURNOVER_24H: 500000,
                ATR_TP_MULTIPLIER: 1.5,
                ATR_SL_MULTIPLIER: 1.0,
            };
            
             // --- Technical Analysis Lib ---
            const TA = {
                ema: (d, p) => {
                    if (!d || d.length < p) return [];
                    const k = 2 / (p + 1);
                    let e = [d[0]];
                    for (let i = 1; i < d.length; i++) e[i] = d[i] * k + e[i - 1] * (1 - k);
                    return e;
                },
                rsi: (d, p) => {
                    if (!d || d.length < p + 1) return [];
                    let gains = 0, losses = 0;
                    for (let i = 1; i <= p; i++) {
                        const diff = d[i] - d[i - 1];
                        if (diff > 0) gains += diff;
                        else losses -= diff;
                    }
                    let avgGain = gains / p;
                    let avgLoss = losses / p;
                    if (avgLoss === 0) return Array(d.length - p).fill(100);

                    let rsiValues = [100 - (100 / (1 + (avgGain / avgLoss)))];

                    for (let i = p + 1; i < d.length; i++) {
                        const diff = d[i] - d[i - 1];
                        let gain = 0, loss = 0;
                        if (diff > 0) gain = diff;
                        else loss = -diff;
                        avgGain = (avgGain * (p - 1) + gain) / p;
                        avgLoss = (avgLoss * (p - 1) + loss) / p;
                        if (avgLoss === 0) {
                           rsiValues.push(100);
                        } else {
                           rsiValues.push(100 - (100 / (1 + (avgGain / avgLoss))));
                        }
                    }
                    return rsiValues;
                },
                atr: (k, p) => {
                    if (!k || k.length < p) return [];
                    let trValues = [];
                    for (let i = 1; i < k.length; i++) {
                        const high = parseFloat(k[i][2]);
                        const low = parseFloat(k[i][3]);
                        const prevClose = parseFloat(k[i - 1][4]);
                        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
                        trValues.push(tr);
                    }
                    if (trValues.length === 0) return [];
                    return TA.ema(trValues, p);
                }
            };

            // --- Core Functions ---
            const showLoader = (text = 'Đang xử lý...') => {
                ui.loaderText.textContent = text;
                ui.loaderModal.classList.remove('hidden');
            };
            const hideLoader = () => ui.loaderModal.classList.add('hidden');

            function logMessage(message, isError = false) {
                const timestamp = new Date().toLocaleString('vi-VN');
                const colorClass = isError ? 'text-red-400' : 'text-green-400';
                ui.logDiv.innerHTML += `<p class="${colorClass}">[${timestamp}] ${message}</p>`;
                ui.logDiv.scrollTop = ui.logDiv.scrollHeight;
            }

            function updateScannerStatus(message) {
                if (ui.scanner.status) {
                    ui.scanner.status.textContent = message;
                }
            }

            async function getServerTimestampMs() {
                try {
                    const r = await fetch(`${CONSTANTS.BYBIT_API_URL}/v5/market/time`);
                    const j = await r.json();
                    if (j.retCode !== 0) throw new Error("Could not sync Bybit server time.");
                    const nsStr = j.result?.timeNano;
                    return nsStr ? (BigInt(nsStr) / 1000000n).toString() : (BigInt(j.result.timeSecond) * 1000n).toString();
                } catch (e) {
                    return Date.now().toString();
                }
            }
            
            async function bybitRequest(endpoint, method, params = {}, isPublic = false) {
                const isValidationCall = endpoint === '/v5/user/query-api';
                if (!isPublic && !state.apiKeysValid && !isValidationCall) {
                    if (endpoint.includes('/v5/market/tickers')) return null;
                    logMessage('API Keys không hợp lệ hoặc chưa được lưu.', true);
                    return null;
                }
                const headers = { 'Content-Type': 'application/json' };
                let url = `${CONSTANTS.BYBIT_API_URL}${endpoint}`;
                let body;

                if (!isPublic) {
                    const timestamp = await getServerTimestampMs();
                    const paramStr = method === 'POST' ? JSON.stringify(params) : new URLSearchParams(params).toString();
                    const signStr = timestamp + state.apiKey + CONSTANTS.RECV_WINDOW + paramStr;
                    const signature = CryptoJS.HmacSHA256(signStr, state.apiSecret).toString(CryptoJS.enc.Hex);
                    Object.assign(headers, {
                        'X-BAPI-API-KEY': state.apiKey, 'X-BAPI-TIMESTAMP': timestamp,
                        'X-BAPI-RECV-WINDOW': CONSTANTS.RECV_WINDOW, 'X-BAPI-SIGN': signature,
                    });
                    if (method === 'GET' && paramStr) url += `?${paramStr}`;
                    if (method === 'POST') body = paramStr;
                } else {
                     if (Object.keys(params).length > 0) url += `?${new URLSearchParams(params)}`;
                }
                try {
                    const response = await fetch(url, { method, headers, body });
                    const data = await response.json();
                    if (data.retCode !== 0) {
                        if (data.retMsg.includes("Not supported symbols") || data.retMsg.includes("Instrument not found")) return null;
                        throw new Error(`Bybit API Error: ${data.retMsg} (Code: ${data.retCode})`);
                    }
                    return data.result;
                } catch (error) {
                    if (!isValidationCall) { 
                        logMessage(error.message, true);
                    }
                    return null;
                }
            }
            
            async function placeOrder(orderParams) {
                if (!orderParams.symbol || !orderParams.qty) {
                    logMessage('Thông tin lệnh không hợp lệ.', true); return null;
                }
                const result = await bybitRequest('/v5/order/create', 'POST', orderParams);
                if (result?.orderId) {
                    logMessage(`Đặt lệnh ${orderParams.side} ${orderParams.symbol} thành công! Order ID: ${result.orderId}`);
                    await new Promise(resolve => setTimeout(resolve, 1500)); 
                    const orderHistory = await bybitRequest('/v5/order/history', 'GET', { category: 'spot', orderId: result.orderId });
                    return orderHistory?.list?.[0] ?? result;
                }
                return null;
            }

            function updateApiStatus(isValid) {
                state.apiKeysValid = isValid;
                const activeClasses = 'bg-green-900 text-green-300';
                const inactiveClasses = 'bg-red-900 text-red-300';
                ui.apiStatus.textContent = isValid ? 'Hợp lệ' : 'Không hợp lệ';
                ui.apiStatus.className = `text-xs font-medium px-2.5 py-1 rounded-full ${isValid ? activeClasses : inactiveClasses}`;
                ui.scanner.startBtn.disabled = !isValid;
                ui.csh.startBtn.disabled = !isValid;
            }

            async function checkApiKeys() {
                if (!state.apiKey || !state.apiSecret) {
                    updateApiStatus(false); return;
                }
                const result = await bybitRequest('/v5/user/query-api', 'GET', {});
                updateApiStatus(!!result);
                if(!!result) {
                    logMessage('Xác thực API Key thành công.');
                    await fetchWalletBalance();
                } else {
                     logMessage('API Keys không hợp lệ.', true)
                }
            }
            
            async function fetchWalletBalance() {
                const result = await bybitRequest('/v5/account/wallet-balance', 'GET', { accountType: 'UNIFIED' });
                if (result?.list?.[0]) {
                    const account = result.list[0];
                    const usdtAsset = account.coin.find(c => c.coin === 'USDT');
                    const availableBalanceStr = usdtAsset?.walletBalance;
                    state.availableUsdt = availableBalanceStr ? parseFloat(availableBalanceStr) : 0;
                    if (isNaN(state.availableUsdt)) {
                        logMessage(`[Balance Check] Giá trị số dư không hợp lệ nhận được: ${availableBalanceStr}. Đặt lại thành 0.`, true);
                        state.availableUsdt = 0;
                    }
                    
                    const totalEquity = parseFloat(account.totalEquity);
                    if (state.pnlHistory.length === 0 || state.pnlHistory[state.pnlHistory.length - 1].equity !== totalEquity) {
                        state.pnlHistory.push({ time: new Date(), equity: totalEquity });
                        localStorage.setItem('bybitPnlHistory', JSON.stringify(state.pnlHistory));
                        renderPnlChart();
                    }

                    let balanceHTML = `<p><strong>Tổng vốn (USD):</strong> ${totalEquity.toFixed(2)}</p><p><strong>USDT Khả dụng:</strong> <span class="font-bold text-yellow-300">${state.availableUsdt.toFixed(2)}</span></p><hr class="my-2 border-gray-600"><ul class="space-y-1 max-h-40 overflow-y-auto">`;
                    account.coin.forEach(c => { if (parseFloat(c.walletBalance) > 0.00001) balanceHTML += `<li><strong>${c.coin}:</strong> ${parseFloat(c.walletBalance).toFixed(5)}</li>`; });
                    balanceHTML += '</ul>';
                    ui.balanceInfoDiv.innerHTML = balanceHTML;
                } else {
                    ui.balanceInfoDiv.textContent = "Không thể lấy dữ liệu số dư.";
                }
            }

            // --- Trade Management (For Scanner Bot) ---
            async function closeActiveTrade(reason) {
                if (!state.activeTrade) return;

                const tradeToClose = { ...state.activeTrade }; 
                state.activeTrade = null; 
                clearInterval(tradeToClose.intervalId);

                logMessage(`[Trade Manager] Đóng lệnh ${tradeToClose.symbol} vì: ${reason}.`, false);
                
                showLoader(`Đang đặt lệnh Bán ${tradeToClose.symbol}...`);
                const orderParams = {
                    category: 'spot',
                    symbol: tradeToClose.symbol,
                    side: 'Sell',
                    orderType: 'Market',
                    qty: tradeToClose.quantity.toString(),
                };
                const sellResult = await placeOrder(orderParams);
                hideLoader();

                if (sellResult && sellResult.orderId) {
                    const entryValue = parseFloat(tradeToClose.entryValue);
                    const exitValue = parseFloat(sellResult.cumExecValue);
                    const profit = (exitValue - entryValue).toFixed(2);
                    logMessage(`[Trade Manager] Bán thành công ${tradeToClose.quantity} ${tradeToClose.symbol}. Lợi nhuận ước tính: ${profit} USDT.`);
                    logMessage("Bot đã sẵn sàng tìm kiếm tín hiệu giao dịch tiếp theo.", false);
                    await fetchWalletBalance();
                } else {
                    logMessage(`[Trade Manager] LỖI NGHIÊM TRỌNG: Không thể đặt lệnh bán cho ${tradeToClose.symbol}. Cần can thiệp thủ công!`, true);
                }
            }
            
            // --- Auto Trade Execution (For Scanner Bot) ---
            async function executeAutoTrades(plans) {
                if (!state.autoTradeEnabled || plans.length === 0 || state.activeTrade) {
                    return;
                }

                logMessage("[Auto-Trade] Bắt đầu quy trình vào lệnh...");

                if (isNaN(state.availableUsdt) || state.availableUsdt < CONFIG.MIN_ORDER_VALUE_USDT) {
                    logMessage(`[Auto-Trade] Số dư khả dụng (${isNaN(state.availableUsdt) ? 'Không xác định' : state.availableUsdt.toFixed(2)} USDT) thấp hơn mức tối thiểu (${CONFIG.MIN_ORDER_VALUE_USDT} USDT). Không thể giao dịch.`, true);
                    return;
                }

                const maxCapitalPerTrade = parseFloat(ui.scanner.capital.value);
                const capitalToUse = Math.min(state.availableUsdt, maxCapitalPerTrade);
                
                if (capitalToUse < CONFIG.MIN_ORDER_VALUE_USDT) {
                    logMessage(`[Auto-Trade] Vốn sau khi giới hạn (${capitalToUse.toFixed(2)} USDT) thấp hơn mức tối thiểu (${CONFIG.MIN_ORDER_VALUE_USDT} USDT). Không thể giao dịch.`, true);
                    return;
                }
                
                const orderQty = (capitalToUse * 0.995).toFixed(5);

                logMessage(`[Auto-Trade] Vốn khả dụng: ${state.availableUsdt.toFixed(2)} USDT. Vốn tối đa: ${maxCapitalPerTrade.toFixed(2)} USDT. Sẽ sử dụng ~${orderQty} USDT cho lệnh.`);

                for (const plan of plans) {
                    logMessage(`[Auto-Trade] Thử vào lệnh cho tín hiệu #1: ${plan.symbol} với ${orderQty} USDT.`);
                    
                    showLoader(`Đang đặt lệnh Mua OCO ${plan.symbol}...`);

                    const tickSize = state.scannedCandidates.get(plan.symbol)?.tickSize || 0.00000001;
                    const lastPrice = parseFloat(plan.lastPrice);
                    const takeProfitPrice = roundTo(lastPrice + (plan.lastAtr * CONFIG.ATR_TP_MULTIPLIER), tickSize);
                    const stopLossPrice = roundTo(lastPrice - (plan.lastAtr * CONFIG.ATR_SL_MULTIPLIER), tickSize);

                    const orderParams = {
                        category: 'spot', symbol: plan.symbol, side: 'Buy',
                        orderType: 'Market', qty: orderQty.toString(), marketUnit: 'quoteCoin',
                        tpslMode: 'Full',
                        takeProfit: takeProfitPrice.toString(),
                        stopLoss: stopLossPrice.toString()
                    };
                    const result = await placeOrder(orderParams);
                    hideLoader();

                    if (result && result.orderId && result.cumExecQty && parseFloat(result.cumExecQty) > 0) {
                        logMessage(`[Auto-Trade] VÀO LỆNH OCO THÀNH CÔNG cho ${plan.symbol}. TP=${takeProfitPrice.toFixed(5)}, SL=${stopLossPrice.toFixed(5)}.`);
                        state.activeTrade = {
                            symbol: plan.symbol,
                            quantity: parseFloat(result.cumExecQty),
                        };
                        startPositionMonitor(plan.symbol, parseFloat(result.cumExecQty));
                        return;
                    } else {
                        logMessage(`[Auto-Trade] Lệnh cho ${plan.symbol} thất bại hoặc không khớp. Thử tín hiệu tiếp theo...`, true);
                    }
                }
                logMessage(`[Auto-Trade] Đã thử tất cả ${plans.length} tín hiệu nhưng không có giao dịch nào thành công.`, true);
            }
            
            async function startPositionMonitor(symbol, initialQty) {
                const baseCoin = symbol.replace('USDT', '');
                const monitorIntervalId = setInterval(async () => {
                    const balanceResult = await bybitRequest('/v5/account/wallet-balance', 'GET', { accountType: 'UNIFIED' });
                    if (balanceResult?.list?.[0]?.coin) {
                        const coinData = balanceResult.list[0].coin.find(c => c.coin === baseCoin);
                        const currentQty = coinData ? parseFloat(coinData.walletBalance) : 0;
                        if (currentQty < initialQty * 0.1) { // If less than 10% remains, consider it closed
                            logMessage(`[Trade Monitor] Phát hiện lệnh ${symbol} đã đóng.`);
                            clearInterval(monitorIntervalId);
                            state.activeTrade = null;
                            await fetchWalletBalance();
                        }
                    }
                }, CONSTANTS.TRADE_MONITOR_INTERVAL_MS * 2); // Check less frequently
            }

            
            // --- UI Handlers & Initialization ---
            function setupEventListeners() {
                ui.saveApiBtn.addEventListener('click', () => {
                    state.apiKey = ui.apiKeyInput.value.trim();
                    state.apiSecret = ui.apiSecretInput.value.trim();
                    if (state.apiKey && state.apiSecret) {
                        localStorage.setItem('bybitApiKey', state.apiKey);
                        localStorage.setItem('bybitApiSecret', state.apiSecret);
                        logMessage('API Key và Secret đã được lưu. Đang xác thực...');
                        checkApiKeys();
                    } else { logMessage('Vui lòng nhập cả API Key và Secret.', true); }
                });

                ui.showApiKeysCheckbox.addEventListener('change', (e) => {
                    const type = e.target.checked ? 'text' : 'password';
                    ui.apiKeyInput.type = type;
                    ui.apiSecretInput.type = type;
                });
                
                ui.scanner.startBtn.addEventListener('click', startScanner);
                ui.scanner.stopBtn.addEventListener('click', stopScanner);
                
                ui.scanner.autoTradeToggle.addEventListener('change', (e) => {
                    state.autoTradeEnabled = e.target.checked;
                    logMessage(`[Auto-Trade] Tự động giao dịch đã được ${state.autoTradeEnabled ? 'BẬT' : 'TẮT'}.`);
                });

                ui.csh.startBtn.addEventListener('click', () => startCSHRT_Auto(3));
                ui.csh.stopBtn.addEventListener('click', () => stopCSHRT_Auto());

                ui.priceChartTab.addEventListener('click', () => {
                    ui.priceChartContainer.classList.remove('hidden');
                    ui.pnlChartContainer.classList.add('hidden');
                    ui.priceChartTab.classList.add('tab-active', 'text-white');
                    ui.pnlChartTab.classList.remove('tab-active', 'text-white');
                    ui.clearPnlHistoryBtn.classList.add('hidden');
                });
                 ui.pnlChartTab.addEventListener('click', () => {
                    ui.pnlChartContainer.classList.remove('hidden');
                    ui.priceChartContainer.classList.add('hidden');
                    ui.pnlChartTab.classList.add('tab-active', 'text-white');
                    ui.priceChartTab.classList.remove('tab-active', 'text-white');
                    ui.clearPnlHistoryBtn.classList.remove('hidden');
                });
                ui.clearPnlHistoryBtn.addEventListener('click', () => {
                    state.pnlHistory = [];
                    localStorage.removeItem('bybitPnlHistory');
                    if(state.pnlChart) {
                        state.pnlChart.data.labels = [];
                        state.pnlChart.data.datasets = [];
                        state.pnlChart.update();
                    }
                    logMessage('[PNL] Lịch sử PNL đã được xóa.');
                });
            }
             // --- Charting Functions ---
            function createChart(canvas) {
                const ctx = canvas.getContext('2d');
                 return new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { ticks: { color: '#9CA3AF', maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                            y: { ticks: { color: '#9CA3AF' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                        },
                        plugins: { legend: { labels: { color: '#D1D5DB' } }, tooltip: { titleColor: '#FFFFFF', bodyColor: '#E5E7EB', backgroundColor: '#1F2937' } }
                    }
                });
            }

            function initializeCharts() {
                if (state.priceChart) state.priceChart.destroy();
                state.priceChart = createChart(ui.priceChartCanvas);
                if (state.pnlChart) state.pnlChart.destroy();
                state.pnlChart = createChart(ui.pnlChartCanvas);
            }

            function renderPriceChart(symbol, klines) {
                if (!state.priceChart || !klines || klines.length === 0) return;
                
                const closes = klines.map(k => parseFloat(k[4]));
                const labels = klines.map(k => new Date(parseInt(k[0])).toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' }));
                const ema20 = TA.ema(closes, 20);
                const ema50 = TA.ema(closes, 50);
                const ema20Data = [...Array(klines.length - ema20.length).fill(null), ...ema20];
                const ema50Data = [...Array(klines.length - ema50.length).fill(null), ...ema50];

                state.priceChart.data.labels = labels;
                state.priceChart.data.datasets = [
                    { label: `Giá ${symbol}`, data: closes, borderColor: '#3498db', borderWidth: 2, tension: 0.1, pointRadius: 0 },
                    { label: 'EMA 20', data: ema20Data, borderColor: '#f1c40f', borderWidth: 1, pointRadius: 0 },
                    { label: 'EMA 50', data: ema50Data, borderColor: '#e74c3c', borderWidth: 1, pointRadius: 0 }
                ];
                state.priceChart.update();
            }

            function renderPnlChart() {
                if (!state.pnlChart || state.pnlHistory.length === 0) return;

                const labels = state.pnlHistory.map(p => p.time.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit'}));
                const data = state.pnlHistory.map(p => p.equity);
                
                const firstEquity = state.pnlHistory.length > 0 ? state.pnlHistory[0].equity : 0;
                const pointBackgroundColors = data.map(equity => equity >= firstEquity ? 'rgba(46, 204, 113, 0.7)' : 'rgba(231, 76, 60, 0.7)');

                state.pnlChart.data.labels = labels;
                state.pnlChart.data.datasets = [{
                    label: 'Tổng Vốn (USD)',
                    data: data,
                    borderColor: '#2ecc71',
                    backgroundColor: 'rgba(46, 204, 113, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                    pointBackgroundColor: pointBackgroundColors,
                    pointRadius: 3,
                }];
                state.pnlChart.update();
            }
            
            // --- CSH-RT WebSocket Logic ---
            const CSH = new Map();
            let ws = null;
            let wsSubs = new Set();
            let wsPing = null;
            let CSHRT_rotationTimer = null;

            function wsConnect() {
              if (ws && ws.readyState === WebSocket.OPEN) return;
              ws = new WebSocket(CONSTANTS.WS_SPOT_URL);
              ws.onopen = () => {
                logMessage("[WS] Connected (public spot)");
                for (const t of wsSubs) wsSend({op:"subscribe", args:[t]});
                wsPing = setInterval(()=> wsSend({op:"ping"}), 20000);
              };
              ws.onclose = () => { logMessage("[WS] Closed", true); if (wsPing) clearInterval(wsPing); setTimeout(wsConnect, 1500); };
              ws.onerror = (e) => logMessage("[WS] Error " + (e?.message||""), true);
              ws.onmessage = wsHandleMessage;
            }

            function wsSend(obj){ if (ws?.readyState===WebSocket.OPEN) ws.send(JSON.stringify(obj)); }
            function wsSub(topic){ wsSubs.add(topic); wsSend({op:"subscribe", args:[topic]}); }
            function wsUnsub(topic){ wsSubs.delete(topic); wsSend({op:"unsubscribe", args:[topic]}); }
            function ensureSym(sym){ if (!CSH.has(sym)) CSH.set(sym, { repriceCount:0 }); return CSH.get(sym); }

            function wsHandleMessage(ev){
              const msg = JSON.parse(ev.data||"{}");
              if (!msg.topic || !msg.data) return;

              if (msg.topic.startsWith("kline.")) {
                const d = Array.isArray(msg.data) ? msg.data[0] : msg.data;
                const [, interval, sym] = msg.topic.split(".");
                if (interval !== "15") return; 
                const st = ensureSym(sym);
                const O = parseFloat(d.open), H=parseFloat(d.high), L=parseFloat(d.low), C=parseFloat(d.close);
                if (d.confirm) {
                  const R = Math.max(1e-12, H - L);
                  st.lastClosed = {O,H,L,C,R,ts: d.end};
                  st.entry = L + 0.18 * R;
                  st.tp    = L + 0.55 * R;
                  st.candleEndTs = Number(d.end) + 15*60*1000;
                  st.repriceCount = 0;
                  logMessage(`[CSH] ${sym} new plan: Entry=${st.entry.toFixed(5)} TP=${st.tp.toFixed(5)}`);
                } else {
                  st.live = {O,H,L,C};
                }
                updateCshStatusUI();
                return;
              }

              if (msg.topic.startsWith("orderbook.")) {
                const sym = msg.topic.split(".").pop();
                const st = ensureSym(sym);
                const ob = Array.isArray(msg.data) ? msg.data[0] : msg.data;
                const ask = (ob.a?.[0]?.[0]) ?? ob.ask1Price ?? ob.bestAskPrice;
                const bid = (ob.b?.[0]?.[0]) ?? ob.bid1Price ?? ob.bestBidPrice;
                if (!ask || !bid) return;
                st.mid = (parseFloat(ask) + parseFloat(bid))/2;
                maybePlaceOrReprice(sym);
                updateCshStatusUI();
                return;
              }
            }
             
            async function primeSymbolMeta(sym){
              const info = await bybitRequest('/v5/market/instruments-info', 'GET', {category:'spot', symbol:sym}, true);
              const it = info?.list?.[0];
              if (!it) return null;
              const st = ensureSym(sym);
              st.tickSize   = parseFloat(it.priceFilter?.tickSize ?? "0.00000001");
              st.lotStep    = parseFloat(it.lotSizeFilter?.basePrecision ?? it.lotSizeFilter?.qtyStep ?? "0.00000001");
              st.minNotional= parseFloat(it.lotSizeFilter?.minOrderAmt ?? "2");
              return st;
            }

            function roundTo(x, step){ return (Math.floor(x/step) * step).toString(); }

            async function placeLimitMaker(sym, price, quoteSizeUSD){
                const st = ensureSym(sym);
                if (!st.tickSize) await primeSymbolMeta(sym); // Ensure meta is loaded
                if (!st.tickSize) {
                    logMessage(`[CSH] Không thể lấy thông tin meta cho ${sym}`, true);
                    return null;
                }

                const p = roundTo(price, st.tickSize);
                let qty = (quoteSizeUSD / parseFloat(p));
                qty = roundTo(qty, st.lotStep);

                if (parseFloat(p) * parseFloat(qty) < st.minNotional) {
                    logMessage(`[CSH] ${sym} giá trị lệnh quá nhỏ: ${(parseFloat(p) * parseFloat(qty)).toFixed(3)} < ${st.minNotional}`, true);
                    return null;
                }
                
                const atrPrice = st.lastAtr || (st.lastClosed.R * 0.7); // Fallback ATR
                const stopLossPrice = roundTo(st.lastClosed.L - (atrPrice * 0.3), st.tickSize);
                const takeProfitPrice = roundTo(st.tp, st.tickSize);

                const res = await bybitRequest('/v5/order/create','POST',{
                    category:'spot', 
                    symbol:sym, 
                    side:'Buy', 
                    orderType:'Limit', 
                    timeInForce:'PostOnly',
                    price: p, 
                    qty: qty,
                    tpslMode: 'Full',
                    takeProfit: takeProfitPrice,
                    stopLoss: stopLossPrice,
                });

                if (res?.orderId) {
                    st.openOrderId = res.orderId;
                    st.openOrderPrice = parseFloat(p);
                    st.repriceCount = 0;
                    logMessage(`[CSH] Đặt lệnh OCO ${sym} @ ${p} | TP=${takeProfitPrice}, SL=${stopLossPrice}`);
                }
                return res;
            }

            async function cancelOrder(sym, orderId){
                const res = await bybitRequest('/v5/order/cancel','POST',{ category:'spot', symbol:sym, orderId });
                const st = ensureSym(sym);
                st.openOrderId = null;
                if (res?.orderId) logMessage(`[CSH] Hủy lệnh ${sym} ${orderId} thành công`);
            }
            
            async function maybePlaceOrReprice(sym){
                const st = CSH.get(sym);
                if (!st || !st.entry || !st.mid || st.openOrderId) return;
                
                if (st.mid <= st.entry * 1.0002) {
                    const capital = parseFloat(ui.csh.capitalInput.value);
                    if (isNaN(capital) || capital < CONFIG.MIN_ORDER_VALUE_USDT) {
                        logMessage(`[CSH] Vốn không hợp lệ: ${capital}. Tối thiểu ${CONFIG.MIN_ORDER_VALUE_USDT} USDT.`, true);
                        return;
                    }
                    await placeLimitMaker(sym, st.entry, capital);
                    scheduleAutoCancel(sym);
                }
            }

            function scheduleAutoCancel(sym){
                const st = ensureSym(sym);
                if (!st.candleEndTs) return;
                const msLeft = st.candleEndTs - Date.now() - 8000; 
                if (msLeft > 0) {
                    setTimeout(async ()=>{
                        const currentSt = CSH.get(sym);
                        if (currentSt && currentSt.openOrderId) {
                            logMessage(`[CSH] Tự động hủy lệnh ${sym} chưa khớp trước khi nến đóng.`);
                            await cancelOrder(sym, currentSt.openOrderId);
                        }
                    }, msLeft);
                }
            }
             function updateCshStatusUI() {
                if (wsSubs.size === 0) {
                    ui.csh.statusContainer.innerHTML = '<p class="text-center text-gray-500">Bot CSH-RT đang không hoạt động.</p>';
                    return;
                }

                let html = '<div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">';
                for (const [symbol, data] of CSH.entries()) {
                    if (!wsSubs.has(`kline.15.${symbol}`)) continue;
                    html += `<div class="bg-gray-900 p-2 rounded-md">
                        <div class="font-bold text-purple-400">${symbol}</div>
                        <div>Giá giữa: <span class="text-white">${data.mid?.toFixed(5) || '...'}</span></div>
                        <div>Entry/TP: <span class="text-green-400">${data.entry?.toFixed(5) || '...'} / ${data.tp?.toFixed(5) || '...'}</span></div>
                        <div>Trạng thái: <span class="text-yellow-400">${data.openOrderId ? `Đang chờ khớp` : 'Đang theo dõi'}</span></div>
                    </div>`;
                }
                html += '</div>';
                ui.csh.statusContainer.innerHTML = html;
            }

            async function startCSH_RT(symbols) {
                wsConnect();
                for (const sym of symbols) {
                    await primeSymbolMeta(sym);
                    wsSub(`kline.15.${sym}`);
                    wsSub(`orderbook.1.${sym}`);
                }
                logMessage(`[CSH] Realtime ON: ${symbols.join(", ")}`);
                ui.csh.startBtn.disabled = true;
                ui.csh.stopBtn.disabled = false;
                updateCshStatusUI();
            }

            function stopCSH_RT(symbolsToStop) {
                const symbols = symbolsToStop || Array.from(wsSubs).map(t => t.split('.').pop());
                for (const sym of symbols) {
                    wsUnsub(`kline.15.${sym}`);
                    wsUnsub(`orderbook.1.${sym}`);
                    const st = CSH.get(sym);
                    if (st?.openOrderId) {
                        cancelOrder(sym, st.openOrderId);
                    }
                }
                logMessage(`[CSH] Realtime OFF: ${symbols.join(", ")}`);
                if(wsSubs.size === 0 && ws) ws.close();
                ui.csh.startBtn.disabled = false;
                ui.csh.stopBtn.disabled = true;
                updateCshStatusUI();
            }
           
            // --- Auto-Picker for CSH-RT ---
            async function pMap(items, limit, mapper) {
              const ret = []; let i = 0; const running = new Set();
              async function next() {
                if (i >= items.length) return;
                const idx = i++;
                const p = Promise.resolve(mapper(items[idx], idx)).then(v => { ret[idx] = v; running.delete(p); });
                running.add(p);
                if (running.size >= limit) await Promise.race(running);
                return next();
              }
              for (let k = 0; k < limit; k++) next();
              await Promise.all(running);
              return ret;
            }

            function computeSpreadBps(b,a){ const bid=parseFloat(b),ask=parseFloat(a);if(!isFinite(bid)||!isFinite(ask)||ask<=0||bid<=0)return 1e9;const mid=(ask+bid)/2;return mid>0?((ask-bid)/mid)*10000:1e9 }
            
            function computeCandleEdge(lastK, atrPrice, volZ) {
              const O = parseFloat(lastK[1]), H = parseFloat(lastK[2]), L = parseFloat(lastK[3]), C = parseFloat(lastK[4]);
              const R = Math.max(1e-12, H - L); if (!isFinite(R) || R<=0) return null;
              const LW = Math.max(0, Math.min(O, C) - L);
              const lwR  = LW / R;
              const posC = (C - L) / R;
              const exp  = atrPrice > 0 ? (R / atrPrice) : 0;

              const clip = (x,lo=0,hi=1)=>Math.max(lo,Math.min(hi,x));
              const s_exp  = clip((exp - 1.0)/1.5);
              const s_wick = clip((lwR - 0.35)/0.35);
              const s_pos  = clip((0.45 - posC)/0.45);
              const s_vol  = clip((volZ - 2.0)/3.0);
              const CES_raw = 0.32*s_exp + 0.28*s_wick + 0.22*s_pos + 0.18*s_vol;

              const alpha = 0.18, beta = 0.55;
              const entry = L + alpha*R;
              const tp = L + beta*R;

              return { R, lwR, posC, exp, CES_raw, entry, tp, O,H,L,C };
            }

            function estimateCostPct_maker(){ return 0.23; }

            function corr15m(closesA, closesB) {
              const n = Math.min(closesA.length, closesB.length, 16);
              if (n < 8) return 0;
              const ra = [], rb = [];
              for (let i=closesA.length-n+1; i<closesA.length; i++){
                ra.push( (closesA[i]/closesA[i-1])-1 );
                rb.push( (closesB[i]/closesB[i-1])-1 );
              }
              const ma = ra.reduce((a,b)=>a+b,0)/ra.length;
              const mb = rb.reduce((a,b)=>a+b,0)/rb.length;
              let num=0, da=0, db=0;
              for (let i=0;i<ra.length;i++){ const xa=ra[i]-ma, xb=rb[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; }
              return (da>0 && db>0) ? (num/Math.sqrt(da*db)) : 0;
            }

            async function autoPickCSHRT(topN = 3) {
              try {
                logMessage(`[CSH-RT] (S0) Lấy universe…`);
                const inst = await bybitRequest('/v5/market/instruments-info', 'GET', { category: 'spot' }, true);
                if (!inst?.list) throw new Error("Không lấy được instruments-info.");
                const tradables = inst.list.filter(i => i.status==='Trading' && i.quoteCoin==='USDT').map(i => i.symbol);

                const tickers = await bybitRequest('/v5/market/tickers', 'GET', { category: 'spot' }, true);
                if (!tickers?.list) throw new Error("Không lấy được tickers.");
                let uni = tickers.list.filter(t => tradables.includes(t.symbol));
                
                uni.sort((a,b)=> parseFloat(b.turnover24h) - parseFloat(a.turnover24h) );
                uni = uni.slice(0, 150);

                logMessage(`[CSH-RT] (S1) Đo spread…`);
                const ob = await pMap(uni, 20, t => bybitRequest('/v5/market/orderbook', 'GET', { category:'spot', symbol:t.symbol, limit:1 }, true));
                const enriched = uni.map((t,i)=>{
                  const o = ob[i];
                  const ask = o?.a?.[0]?.[0] ?? t.ask1Price, bid = o?.b?.[0]?.[0] ?? t.bid1Price;
                  const spread_bps = computeSpreadBps(bid, ask);
                  return {...t, _ask:ask, _bid:bid, spread_bps};
                }).filter(x => isFinite(x.spread_bps));
                const spreads = enriched.map(x=>x.spread_bps).sort((a,b)=>a-b);
                const p60 = spreads[Math.floor(0.60*spreads.length)] || 20;
                const SPREAD_MAX = Math.max(15, Math.min(25, p60));
                const liq = enriched.filter(x => x.spread_bps <= SPREAD_MAX);

                logMessage(`[CSH-RT] (S2) ATR & nến cuối (15m) cho ${liq.length} cặp…`);
                const kl = await pMap(liq, 16, t => bybitRequest('/v5/market/kline', 'GET', { category:'spot', symbol:t.symbol, interval:'15', limit:200 }, true));
                const cands = [];
                for (let i=0;i<liq.length;i++){
                  const list = kl[i]?.list; if (!list || list.length<50) continue;
                  const arr = list.map(k => [Number(k[0]), ...k.slice(1,6).map(Number)] ); 
                  arr.sort((a,b)=>a[0]-b[0]);
                  const closes = arr.map(r=>r[4]);
                  const lastK = arr[arr.length-1];
                  const atrArr = TA.atr(arr.map(k => ['', '', k[2], k[3], k[4]]), 14); const atrPrice = atrArr.pop() || 0;
                  const volArr = arr.map(r=>r[5]||0); const med20 = volArr.slice(-20).sort((a,b)=>a-b)[10] || 1;
                  const volZ = med20>0 ? (volArr[volArr.length-1]/med20) : 1;
                  const lastPrice = closes[closes.length-1] || 0;
                  const atrPct = lastPrice>0 ? (atrPrice/lastPrice)*100 : 0;
                  cands.push({...liq[i], klines:arr, closes, lastK, atrPrice, atrPct, volZ});
                }
                if (!cands.length) throw new Error("Không đủ dữ liệu kline.");
                
                const atrs = cands.map(c=>c.atrPct).sort((a,b)=>a-b);
                const atrMin = Math.max(atrs[Math.floor(0.40*atrs.length)]||0.12, 0.12);
                const atrMax = Math.min(atrs[Math.floor(0.95*atrs.length)]||6.0, 6.0);
                const filtered = cands.filter(c => c.atrPct>=atrMin && c.atrPct<=atrMax);

                const ranked = [];
                for (const c of filtered) {
                  const ce = computeCandleEdge(c.lastK, c.atrPrice, c.volZ);
                  if (!ce) continue;
                  if (!(ce.exp >= 1.2 && ce.lwR >= 0.35 && ce.posC <= 0.40 && c.volZ >= 2)) continue;
                  const cost = estimateCostPct_maker();
                  const pen_cost = Math.min(1, cost/0.6);
                  const CES = ce.CES_raw - 0.20*pen_cost;
                  const grossPct = c.entry>0 ? ((ce.tp-ce.entry)/ce.entry)*100 : 0;
                  if (CES < 0.65 || grossPct < 2.0*cost) continue;
                   ensureSym(c.symbol).lastAtr = c.atrPrice;
                  ranked.push({ symbol: c.symbol, spread_bps: c.spread_bps, atrPct: c.atrPct, CES, grossPct, closes: c.closes, lastAtr: c.atrPrice });
                }

                ranked.sort((a,b)=> b.CES - a.CES || a.spread_bps - b.spread_bps);
                const picks = [];
                for (const r of ranked) {
                  let ok = true;
                  for (const p of picks) {
                    if (corr15m(r.closes, p.closes) > 0.85) { ok = false; break; }
                  }
                  if (ok) {
                    picks.push(r);
                    if (picks.length >= topN) break;
                  }
                }

                if (!picks.length) { logMessage(`[CSH-RT] Không tìm thấy cặp phù hợp.`); return []; }

                picks.forEach((p,i)=>{ logMessage(`[CSH-RT] Pick #${i+1} ${p.symbol} | CES=${p.CES.toFixed(3)} | spread=${p.spread_bps.toFixed(1)}bps | ATR=${p.atrPct.toFixed(2)}% | gross≈${p.grossPct.toFixed(2)}%`); });
                return picks.map(p=>p.symbol);
              } catch (e) {
                logMessage(`[CSH-RT] Auto-pick lỗi: ${e.message}`, true);
                return [];
              }
            }
            
            async function startCSHRT_Auto(topN=3){
              const syms = await autoPickCSHRT(topN);
              if (!syms.length) {
                  logMessage(`[CSH-RT] Không có cặp để bật real-time. Thử lại sau 15 phút.`, true);
                  scheduleCSHRT_Rotation(topN, []);
                  return;
              }
              startCSH_RT(syms); 
              scheduleCSHRT_Rotation(topN, syms);
            }

            function scheduleCSHRT_Rotation(topN, currentSyms){
              if (CSHRT_rotationTimer) clearTimeout(CSHRT_rotationTimer);
              const now = Date.now();
              const msToNext15 = 15*60*1000 - (now % (15*60*1000)) + 1500;
              logMessage(`[CSH-RT] Lần quét chọn cặp tiếp theo sau: ${(msToNext15/60000).toFixed(1)} phút.`);
              CSHRT_rotationTimer = setTimeout(async ()=>{
                stopCSH_RT(currentSyms);
                startCSHRT_Auto(topN);
              }, msToNext15);
            }

            function stopCSHRT_Auto(){
              if (CSHRT_rotationTimer) clearTimeout(CSHRT_rotationTimer);
              const currentSyms = Array.from(wsSubs).map(t => t.split(".").pop());
              if (currentSyms.length) stopCSH_RT(currentSyms);
              logMessage(`[CSH-RT] Auto-pick stopped.`);
            }
            
            // --- Scanner Bot (V4) ---
            const startScanner = async () => {
                if (!state.apiKeysValid) { logMessage('API keys không hợp lệ.', true); return; }
                if (state.scannerIntervalId || state.activeTrade) { logMessage('Bot đang bận, vui lòng dừng trước khi bắt đầu lại.', true); return; }
                logMessage("Bắt đầu công cụ quét thị trường...");
                ui.scanner.startBtn.disabled = true;
                ui.scanner.stopBtn.disabled = false;
                
                await fetchWalletBalance(); 
                state.balanceUpdateIntervalId = setInterval(fetchWalletBalance, CONSTANTS.BALANCE_UPDATE_INTERVAL_MS);

                executeScan();
                state.scannerIntervalId = setInterval(executeScan, CONSTANTS.SCANNER_INTERVAL_MS);
            };
            const stopScanner = () => {
                if (state.scannerIntervalId) {
                    clearInterval(state.scannerIntervalId);
                    state.scannerIntervalId = null;
                }
                if (state.balanceUpdateIntervalId) {
                    clearInterval(state.balanceUpdateIntervalId);
                    state.balanceUpdateIntervalId = null;
                }
                logMessage("Công cụ quét đã dừng bởi người dùng.");
                updateScannerStatus("Công cụ quét đang không hoạt động.");
                ui.scanner.startBtn.disabled = false;
                ui.scanner.stopBtn.disabled = true;

                 if(state.activeTrade) {
                    closeActiveTrade("Người dùng yêu cầu dừng bot.");
                }
            };
            async function executeScan() {
                 if (state.isScanning) return;
                state.isScanning = true;
                logMessage(`[Scanner] Bắt đầu quét với thuật toán V4.3.0...`);
                try {
                    if(state.activeTrade) {
                        updateScannerStatus(`Đang giám sát ${state.activeTrade.symbol}... Vẫn quét nền.`);
                    } else {
                        updateScannerStatus(`(B1) Lấy dữ liệu thị trường...`); 
                        showLoader(ui.scanner.status.textContent);
                    }
                    
                    const instrumentsInfo = await bybitRequest('/v5/market/instruments-info', 'GET', { category: 'spot' }, true);
                    if (!instrumentsInfo || !instrumentsInfo.list) { throw new Error("Không thể lấy danh sách cặp giao dịch từ Bybit."); }
                    const allTradablePairs = instrumentsInfo.list.filter(i => i.status === 'Trading' && i.quoteCoin === 'USDT').map(i => i.symbol);

                    const allTickersData = await bybitRequest('/v5/market/tickers', 'GET', { category: 'spot' }, true);
                     if (!allTickersData || !allTickersData.list) { throw new Error("Không thể lấy dữ liệu tickers từ Bybit."); }
                    let universe = allTickersData.list.filter(t => allTradablePairs.includes(t.symbol) && parseFloat(t.turnover24h) > CONFIG.MIN_TURNOVER_24H).slice(0, 150);

                    updateScannerStatus(`(B2) Lấy dữ liệu chi tiết cho ${universe.length} cặp...`);
                    const dataPromises = universe.map(t => Promise.all([
                        bybitRequest('/v5/market/instruments-info', 'GET', { category: 'spot', symbol: t.symbol }, true),
                        bybitRequest('/v5/market/orderbook', 'GET', { category: 'spot', symbol: t.symbol, limit: 1 }, true),
                        bybitRequest('/v5/market/kline', 'GET', { category: 'spot', symbol: t.symbol, interval: '15', limit: 200 }, true)
                    ]));
                    const results = await Promise.all(dataPromises);
                    
                    state.scannedCandidates.clear();
                    for (let i = 0; i < universe.length; i++) {
                        const [instInfo, ob, klineData] = results[i];
                        if (ob && klineData?.list?.length >= 51 && instInfo?.list?.[0]) {
                            const ticker = universe[i];
                            const info = instInfo.list[0];
                            const ask = ob?.a?.[0]?.[0] ?? ticker.ask1Price;
                            const bid = ob?.b?.[0]?.[0] ?? ticker.bid1Price;
                            const candidateData = { 
                                ...ticker, 
                                spread_bps: ((ask - bid) / ask) * 10000, 
                                klines: klineData.list.reverse(),
                                tickSize: parseFloat(info.priceFilter?.tickSize ?? "0.00000001")
                            };
                            state.scannedCandidates.set(ticker.symbol, candidateData);
                        }
                    }
                    
                    updateScannerStatus(`(B3) Chấm điểm ${state.scannedCandidates.size} cặp...`);
                    let processedCandidates = [];
                    for (const [symbol, cand] of state.scannedCandidates.entries()) {
                        const closes = cand.klines.map(k => parseFloat(k[4]));
                        const lastPrice = closes[closes.length - 1];
                        if (!lastPrice || closes.length < 52) continue; 

                        const ema20 = TA.ema(closes, 20).pop();
                        const ema50 = TA.ema(closes, 50).pop();
                        const rsiValues = TA.rsi(closes, 14);
                        const atrValues = TA.atr(cand.klines, 14);

                        if (ema20 === undefined || ema50 === undefined || rsiValues.length < 2 || atrValues.length < 1) continue;
                        
                        const lastRsi = rsiValues[rsiValues.length - 1];
                        const prevRsi = rsiValues[rsiValues.length - 2];
                        const lastAtr = atrValues[atrValues.length - 1];

                        const isUptrend = ema20 > ema50;
                        const priceAboveTrend = lastPrice > ema50;
                        const inPullbackZone = lastRsi > 45 && lastRsi < 65;
                        const isRecovering = lastRsi > prevRsi;

                        if (isUptrend && priceAboveTrend && inPullbackZone && isRecovering) {
                            const rsiScore = (65 - lastRsi) / 20; 
                            const proximityToEmaScore = 1 - Math.min(1, Math.abs(lastPrice - ema20) / lastPrice * 10);
                            const spreadScore = 1 - Math.min(1, cand.spread_bps / 30);
                            const finalScore = (rsiScore * 0.5) + (proximityToEmaScore * 0.3) + (spreadScore * 0.2);

                            processedCandidates.push({ ...cand, raos: finalScore, regime: 'Uptrend Pullback', rsi: lastRsi, lastAtr: lastAtr });
                        }
                    }
                    processedCandidates.sort((a, b) => b.raos - a.raos);
                    
                    const topPicks = processedCandidates.slice(0, 3);
                    displayScanResults(topPicks);
                    if (topPicks.length > 0 && !state.activeTrade) {
                        renderPriceChart(topPicks[0].symbol, topPicks[0].klines);
                    } else if (topPicks.length === 0) {
                        initializeCharts(); 
                    }

                    logMessage(`[Scanner] Quét hoàn tất. Hiển thị ${topPicks.length} tín hiệu tiềm năng.`);
                    if(!state.activeTrade) {
                        updateScannerStatus(`Quét xong. Cập nhật lần cuối: ${new Date().toLocaleTimeString('vi-VN')}`);
                    }
                    
                    await executeAutoTrades(topPicks);
                
                } catch (error) {
                    logMessage(`[Scanner] Lỗi: ${error.message}`, true);
                    updateScannerStatus("Đã xảy ra lỗi. Kiểm tra log và thử lại.");
                    displayScanResults([]);
                } finally {
                    state.isScanning = false;
                    if(!state.activeTrade) {
                        hideLoader();
                    }
                }
            }
            function displayScanResults(results) {
                 ui.scanner.results.innerHTML = '';
                if (!results || results.length === 0) {
                    ui.scanner.results.innerHTML = '<div class="col-span-full text-center text-gray-400">Không có kế hoạch giao dịch nào phù hợp.</div>';
                    return;
                }
                let header = state.activeTrade ? `<h3 class="col-span-full text-center text-yellow-400 font-semibold mb-2">Tín hiệu tiềm năng cho lệnh tiếp theo:</h3>` : '';
                ui.scanner.results.innerHTML = header;

                results.forEach((item, index) => {
                    const capitalDisplay = index === 0 ? `(Ưu tiên #1)` : '(Dự phòng)';
                    const lastPrice = parseFloat(item.lastPrice);
                    const potentialTp = lastPrice + (item.lastAtr * CONFIG.ATR_TP_MULTIPLIER);
                    const potentialSl = lastPrice - (item.lastAtr * CONFIG.ATR_SL_MULTIPLIER);
                    const cardHTML = `
                        <div class="bg-gray-900/50 rounded-xl p-4 border border-gray-700 flex flex-col space-y-3 ${index > 0 ? 'opacity-60' : ''}">
                            <div class="flex justify-between items-center">
                                <h3 class="text-lg font-bold text-cyan-400">${item.symbol}</h3>
                                <span class="px-2 py-1 text-xs font-semibold rounded-full regime-trend">${item.regime} ${capitalDisplay}</span>
                            </div>
                            <div class="grid grid-cols-2 gap-x-4 text-sm">
                                <span class="text-gray-400">Score</span><span class="font-semibold text-yellow-400 text-right">${item.raos?.toFixed(3) ?? 'N/A'}</span>
                                <span class="text-gray-400">RSI(14)</span><span class="font-semibold text-white text-right">${item.rsi?.toFixed(2) ?? 'N/A'}</span>
                                <span class="text-gray-400">Spread</span><span class="font-semibold text-white text-right">${item.spread_bps?.toFixed(2) ?? 'N/A'} bps</span>
                            </div>
                             <div class="border-t border-gray-700 pt-2 mt-2 text-xs">
                                <p class="font-semibold text-gray-400">TP/SL Động (dựa trên ATR):</p>
                                <div class="flex justify-between"><span>Chốt lời (ước tính):</span><span class="text-green-400">${potentialTp.toFixed(4)}</span></div>
                                <div class="flex justify-between"><span>Cắt lỗ (ước tính):</span><span class="text-red-400">${potentialSl.toFixed(4)}</span></div>
                            </div>
                             <button class="view-chart-btn mt-2 w-full bg-gray-600 hover:bg-gray-500 text-white text-xs font-bold py-2 px-4 rounded-lg transition" data-symbol="${item.symbol}">Xem Biểu Đồ</button>
                        </div>`;
                    ui.scanner.results.innerHTML += cardHTML;
                });

                document.querySelectorAll('.view-chart-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const symbol = e.target.dataset.symbol;
                        const candidateData = state.scannedCandidates.get(symbol);
                        if(candidateData) {
                            renderPriceChart(symbol, candidateData.klines);
                        }
                    });
                });
            }
            
            // --- Start the application ---
            function initialize() {
                const storedApiKey = localStorage.getItem('bybitApiKey');
                const storedApiSecret = localStorage.getItem('bybitApiSecret');
                if(storedApiKey && storedApiSecret) {
                    ui.apiKeyInput.value = storedApiKey;
                    ui.apiSecretInput.value = storedApiSecret;
                    state.apiKey = storedApiKey;
                    state.apiSecret = storedApiSecret;
                    checkApiKeys();
                } else {
                    updateApiStatus(false);
                }
                setupEventListeners();
                initializeCharts();
                
                const storedPnlHistory = localStorage.getItem('bybitPnlHistory');
                if (storedPnlHistory) {
                    try {
                        state.pnlHistory = JSON.parse(storedPnlHistory).map(item => ({
                            equity: item.equity,
                            time: new Date(item.time)
                        }));
                        renderPnlChart();
                    } catch(e) {
                        logMessage('[PNL] Lỗi khi đọc lịch sử PNL.', true);
                        state.pnlHistory = [];
                    }
                }

                logMessage('Bot đã sẵn sàng. Vui lòng lưu API key để kích hoạt các tính năng.');
            }

            initialize();
        });
    </script>
</body>
</html>

