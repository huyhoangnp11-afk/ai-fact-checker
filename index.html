<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Trading Bot</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CryptoJS for API signature generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Chart.js for charting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .log-area { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-break: break-all; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .tab-active {
            border-bottom-width: 2px;
            border-color: #0891B2; /* cyan-500 */
            color: #ffffff;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-7xl mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6">
        
        <header class="text-center">
            <h1 class="text-3xl font-bold text-white">Bybit Trading Bot</h1>
            <p class="text-gray-400 mt-2">Giao dịch tự động và quản lý tài khoản Bybit của bạn.</p>
        </header>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Left Column: Settings, Account -->
            <div class="lg:col-span-1 space-y-6">
                <div class="bg-gray-700/50 p-6 rounded-xl">
                     <div class="flex items-center justify-between border-b border-gray-600 pb-3 mb-4">
                        <h2 class="text-xl font-semibold">Cài đặt API</h2>
                        <span id="apiStatus" class="text-xs font-medium px-2.5 py-1 rounded-full">&nbsp;</span>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label for="apiKey" class="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                            <input type="password" id="apiKey" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="apiSecret" class="block text-sm font-medium text-gray-300 mb-1">API Secret</label>
                            <input type="password" id="apiSecret" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500">
                        </div>
                         <div class="flex items-center justify-between">
                            <button id="saveApi" class="w-2/3 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105">Lưu API Key</button>
                            <div class="flex items-center space-x-2 text-sm">
                               <label for="showApiKeys" class="text-gray-400">Hiện</label>
                               <input type="checkbox" id="showApiKeys" class="form-checkbox h-5 w-5 text-blue-500 bg-gray-900 border-gray-600 rounded focus:ring-blue-500">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <h2 class="text-xl font-semibold mb-3 border-b border-gray-600 pb-3">Thông tin tài khoản</h2>
                    <div id="balanceInfo" class="bg-gray-900 p-4 rounded-lg text-sm min-h-[120px]">
                        Vui lòng xác thực API để xem số dư...
                    </div>
                </div>
            </div>

            <!-- Right Column: Dashboard & Scanner -->
            <div class="lg:col-span-2 space-y-6">
                 <!-- Trading Dashboard -->
                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <div class="flex border-b border-gray-600 mb-4">
                        <button id="priceChartTab" class="py-2 px-4 font-semibold tab-active">Biểu Đồ Giá</button>
                        <button id="pnlChartTab" class="py-2 px-4 text-gray-400 font-semibold">Lịch Sử PNL</button>
                    </div>
                    <div id="priceChartContainer" class="bg-gray-900 rounded-lg p-4 h-64">
                        <canvas id="priceChart"></canvas>
                    </div>
                     <div id="pnlChartContainer" class="bg-gray-900 rounded-lg p-4 h-64 hidden">
                        <canvas id="pnlChart"></canvas>
                    </div>
                </div>
                 <!-- Market Scanner Section -->
                <div class="bg-gray-700/50 p-6 rounded-xl">
                    <h2 class="text-xl font-semibold border-b border-gray-600 pb-3 mb-4">Bot Giao Dịch Tự Động (V4.2.1)</h2>
                    <div class="bg-blue-900 border-l-4 border-blue-500 text-blue-100 p-4 rounded-lg mb-4" role="alert">
                        <p><strong class="font-bold">TP/SL Động (ATR):</strong> Bot tự động đặt Chốt Lời (1.5 x ATR) và Cắt Lỗ (1.0 x ATR) dựa trên biến động của từng cặp tiền.</p>
                    </div>
                     <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                        <div class="md:col-span-1">
                            <label for="scannerCapital" class="block text-sm font-medium text-gray-300 mb-1">Vốn Tối Đa / Lệnh</label>
                            <input type="number" id="scannerCapital" value="8" step="1" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200">
                        </div>
                        <div class="md:col-span-1 flex items-end pb-1">
                             <label for="autoTradeToggle" class="flex items-center cursor-pointer">
                                <div class="relative">
                                    <input type="checkbox" id="autoTradeToggle" class="sr-only peer">
                                    <div class="block bg-gray-600 w-14 h-8 rounded-full peer-checked:bg-green-600"></div>
                                    <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform transform peer-checked:translate-x-full"></div>
                                </div>
                                <span class="ml-3 text-sm font-medium text-gray-300">Tự động</span>
                            </label>
                        </div>
                        <div class="md:col-span-1 grid grid-cols-2 gap-2">
                            <button id="startScannerBtn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-500" disabled>Bắt đầu</button>
                            <button id="stopScannerBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition" disabled>Dừng</button>
                        </div>
                    </div>
                    <div id="scannerStatus" class="mt-4 bg-gray-900 p-3 rounded-lg text-sm text-center">Công cụ quét đang không hoạt động.</div>
                </div>
            </div>
        </div>

        <!-- Trading Plan Cards Container -->
        <div id="scannerResults" class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Trading Plan Cards will be populated here -->
        </div>

        <!-- Log Area -->
        <div class="bg-gray-900/70 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-semibold mb-2">Nhật ký hoạt động</h2>
            <div id="log" class="log-area bg-black h-64 overflow-y-auto p-3 rounded-lg text-xs text-gray-400"></div>
        </div>

    </div>

    <!-- Loading Spinner Modal -->
    <div id="loaderModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="flex flex-col items-center">
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24"></div>
            <p id="loaderText" class="mt-4 text-white text-lg font-semibold">Đang xử lý...</p>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const ui = {
                apiKeyInput: document.getElementById('apiKey'),
                apiSecretInput: document.getElementById('apiSecret'),
                saveApiBtn: document.getElementById('saveApi'),
                showApiKeysCheckbox: document.getElementById('showApiKeys'),
                apiStatus: document.getElementById('apiStatus'),
                balanceInfoDiv: document.getElementById('balanceInfo'),
                logDiv: document.getElementById('log'),
                loaderModal: document.getElementById('loaderModal'),
                loaderText: document.getElementById('loaderText'),
                priceChartCanvas: document.getElementById('priceChart'),
                pnlChartCanvas: document.getElementById('pnlChart'),
                priceChartTab: document.getElementById('priceChartTab'),
                pnlChartTab: document.getElementById('pnlChartTab'),
                priceChartContainer: document.getElementById('priceChartContainer'),
                pnlChartContainer: document.getElementById('pnlChartContainer'),
                scanner: {
                    capital: document.getElementById('scannerCapital'),
                    autoTradeToggle: document.getElementById('autoTradeToggle'),
                    startBtn: document.getElementById('startScannerBtn'),
                    stopBtn: document.getElementById('stopScannerBtn'),
                    status: document.getElementById('scannerStatus'),
                    results: document.getElementById('scannerResults'),
                }
            };

            // --- State Management ---
            const state = {
                apiKey: '',
                apiSecret: '',
                scannerIntervalId: null,
                balanceUpdateIntervalId: null,
                isScanning: false,
                apiKeysValid: false,
                autoTradeEnabled: false,
                activeTrade: null,
                priceChart: null,
                pnlChart: null,
                pnlHistory: [],
                scannedCandidates: new Map(),
                availableUsdt: 0,
            };

            // --- Constants & Config ---
            const CONSTANTS = {
                BYBIT_API_URL: 'https://api.bybit.com',
                RECV_WINDOW: '10000', 
                SCANNER_INTERVAL_MS: 120000, 
                TRADE_MONITOR_INTERVAL_MS: 7000,
                BALANCE_UPDATE_INTERVAL_MS: 60000,
            };
            const CONFIG = {
                MIN_ORDER_VALUE_USDT: 3, 
                MIN_TURNOVER_24H: 500000,
                ATR_TP_MULTIPLIER: 1.5,
                ATR_SL_MULTIPLIER: 1.0,
            };
            
             // --- Technical Analysis Lib ---
            const TA = {
                ema: (d, p) => {
                    if (!d || d.length < p) return [];
                    const k = 2 / (p + 1);
                    let e = [d[0]];
                    for (let i = 1; i < d.length; i++) e[i] = d[i] * k + e[i - 1] * (1 - k);
                    return e;
                },
                rsi: (d, p) => {
                    if (!d || d.length < p + 1) return [];
                    let gains = 0, losses = 0;
                    for (let i = 1; i <= p; i++) {
                        const diff = d[i] - d[i - 1];
                        if (diff > 0) gains += diff;
                        else losses -= diff;
                    }
                    let avgGain = gains / p;
                    let avgLoss = losses / p;
                    if (avgLoss === 0) return Array(d.length - p).fill(100);

                    let rsiValues = [100 - (100 / (1 + (avgGain / avgLoss)))];

                    for (let i = p + 1; i < d.length; i++) {
                        const diff = d[i] - d[i - 1];
                        let gain = 0, loss = 0;
                        if (diff > 0) gain = diff;
                        else loss = -diff;
                        avgGain = (avgGain * (p - 1) + gain) / p;
                        avgLoss = (avgLoss * (p - 1) + loss) / p;
                        if (avgLoss === 0) {
                           rsiValues.push(100);
                        } else {
                           rsiValues.push(100 - (100 / (1 + (avgGain / avgLoss))));
                        }
                    }
                    return rsiValues;
                },
                atr: (k, p) => {
                    if (!k || k.length < p) return [];
                    let trValues = [];
                    for (let i = 1; i < k.length; i++) {
                        const high = parseFloat(k[i][2]);
                        const low = parseFloat(k[i][3]);
                        const prevClose = parseFloat(k[i - 1][4]);
                        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
                        trValues.push(tr);
                    }
                    if (trValues.length === 0) return [];
                    // Using EMA for ATR is a common method (Wilder's Smoothing)
                    return TA.ema(trValues, p);
                }
            };

            // --- Core Functions ---
            const showLoader = (text = 'Đang xử lý...') => {
                ui.loaderText.textContent = text;
                ui.loaderModal.classList.remove('hidden');
            };
            const hideLoader = () => ui.loaderModal.classList.add('hidden');

            function logMessage(message, isError = false) {
                const timestamp = new Date().toLocaleString('vi-VN');
                const colorClass = isError ? 'text-red-400' : 'text-green-400';
                ui.logDiv.innerHTML += `<p class="${colorClass}">[${timestamp}] ${message}</p>`;
                ui.logDiv.scrollTop = ui.logDiv.scrollHeight;
            }

            function updateScannerStatus(message) {
                if (ui.scanner.status) {
                    ui.scanner.status.textContent = message;
                }
            }

            async function getServerTimestampMs() {
                try {
                    const r = await fetch(`${CONSTANTS.BYBIT_API_URL}/v5/market/time`);
                    const j = await r.json();
                    if (j.retCode !== 0) throw new Error("Could not sync Bybit server time.");
                    const nsStr = j.result?.timeNano;
                    return nsStr ? (BigInt(nsStr) / 1000000n).toString() : (BigInt(j.result.timeSecond) * 1000n).toString();
                } catch (e) {
                    return Date.now().toString();
                }
            }
            
            async function bybitRequest(endpoint, method, params = {}, isPublic = false) {
                const isValidationCall = endpoint === '/v5/user/query-api';
                if (!isPublic && !state.apiKeysValid && !isValidationCall) {
                    if (endpoint.includes('/v5/market/tickers')) return null;
                    logMessage('API Keys không hợp lệ hoặc chưa được lưu.', true);
                    return null;
                }
                const headers = { 'Content-Type': 'application/json' };
                let url = `${CONSTANTS.BYBIT_API_URL}${endpoint}`;
                let body;

                if (!isPublic) {
                    const timestamp = await getServerTimestampMs();
                    const paramStr = method === 'POST' ? JSON.stringify(params) : new URLSearchParams(params).toString();
                    const signStr = timestamp + state.apiKey + CONSTANTS.RECV_WINDOW + paramStr;
                    const signature = CryptoJS.HmacSHA256(signStr, state.apiSecret).toString(CryptoJS.enc.Hex);
                    Object.assign(headers, {
                        'X-BAPI-API-KEY': state.apiKey, 'X-BAPI-TIMESTAMP': timestamp,
                        'X-BAPI-RECV-WINDOW': CONSTANTS.RECV_WINDOW, 'X-BAPI-SIGN': signature,
                    });
                    if (method === 'GET' && paramStr) url += `?${paramStr}`;
                    if (method === 'POST') body = paramStr;
                } else {
                     if (Object.keys(params).length > 0) url += `?${new URLSearchParams(params)}`;
                }
                try {
                    const response = await fetch(url, { method, headers, body });
                    const data = await response.json();
                    if (data.retCode !== 0) {
                        if (data.retMsg.includes("Not supported symbols") || data.retMsg.includes("Instrument not found")) return null;
                        throw new Error(`Bybit API Error: ${data.retMsg} (Code: ${data.retCode})`);
                    }
                    return data.result;
                } catch (error) {
                    if (!isValidationCall) { 
                        logMessage(error.message, true);
                    }
                    return null;
                }
            }
            
            async function placeOrder(orderParams) {
                if (!orderParams.symbol || !orderParams.qty) {
                    logMessage('Thông tin lệnh không hợp lệ.', true); return null;
                }
                const result = await bybitRequest('/v5/order/create', 'POST', orderParams);
                if (result?.orderId) {
                    logMessage(`Đặt lệnh ${orderParams.side} ${orderParams.symbol} thành công! Order ID: ${result.orderId}`);
                    await new Promise(resolve => setTimeout(resolve, 1500)); 
                    const orderHistory = await bybitRequest('/v5/order/history', 'GET', { category: 'spot', orderId: result.orderId });
                    return orderHistory?.list?.[0] ?? result;
                }
                return null;
            }

            function updateApiStatus(isValid) {
                state.apiKeysValid = isValid;
                const activeClasses = 'bg-green-900 text-green-300';
                const inactiveClasses = 'bg-red-900 text-red-300';
                ui.apiStatus.textContent = isValid ? 'Hợp lệ' : 'Không hợp lệ';
                ui.apiStatus.className = `text-xs font-medium px-2.5 py-1 rounded-full ${isValid ? activeClasses : inactiveClasses}`;
                ui.scanner.startBtn.disabled = !isValid;
            }

            async function checkApiKeys() {
                if (!state.apiKey || !state.apiSecret) {
                    updateApiStatus(false); return;
                }
                const result = await bybitRequest('/v5/user/query-api', 'GET', {});
                updateApiStatus(!!result);
                if(!!result) {
                    logMessage('Xác thực API Key thành công.');
                    await fetchWalletBalance();
                } else {
                     logMessage('API Keys không hợp lệ.', true)
                }
            }
            
            async function fetchWalletBalance() {
                const result = await bybitRequest('/v5/account/wallet-balance', 'GET', { accountType: 'UNIFIED' });
                if (result?.list?.[0]) {
                    const account = result.list[0];
                    const usdtAsset = account.coin.find(c => c.coin === 'USDT');
                    const availableBalanceStr = usdtAsset?.availableToWithdraw;
                    state.availableUsdt = availableBalanceStr ? parseFloat(availableBalanceStr) : 0;
                    if (isNaN(state.availableUsdt)) {
                        logMessage(`[Balance Check] Giá trị số dư không hợp lệ nhận được: ${availableBalanceStr}. Đặt lại thành 0.`, true);
                        state.availableUsdt = 0;
                    }
                    
                    const totalEquity = parseFloat(account.totalEquity);
                    if (state.pnlHistory.length === 0 || state.pnlHistory[state.pnlHistory.length - 1].equity !== totalEquity) {
                        state.pnlHistory.push({ time: new Date(), equity: totalEquity });
                        renderPnlChart();
                    }

                    let balanceHTML = `<p><strong>Tổng vốn (USD):</strong> ${totalEquity.toFixed(2)}</p><p><strong>USDT Khả dụng:</strong> <span class="font-bold text-yellow-300">${state.availableUsdt.toFixed(2)}</span></p><hr class="my-2 border-gray-600"><ul class="space-y-1 max-h-40 overflow-y-auto">`;
                    account.coin.forEach(c => { if (parseFloat(c.walletBalance) > 0.00001) balanceHTML += `<li><strong>${c.coin}:</strong> ${parseFloat(c.walletBalance).toFixed(5)}</li>`; });
                    balanceHTML += '</ul>';
                    ui.balanceInfoDiv.innerHTML = balanceHTML;
                } else {
                    ui.balanceInfoDiv.textContent = "Không thể lấy dữ liệu số dư.";
                }
            }

            // --- Trade Management ---
            async function closeActiveTrade(reason) {
                if (!state.activeTrade) return;

                const tradeToClose = { ...state.activeTrade }; 
                state.activeTrade = null; 
                clearInterval(tradeToClose.intervalId);

                logMessage(`[Trade Manager] Đóng lệnh ${tradeToClose.symbol} vì: ${reason}.`, false);
                
                showLoader(`Đang đặt lệnh Bán ${tradeToClose.symbol}...`);
                const orderParams = {
                    category: 'spot',
                    symbol: tradeToClose.symbol,
                    side: 'Sell',
                    orderType: 'Market',
                    qty: tradeToClose.quantity.toString(),
                };
                const sellResult = await placeOrder(orderParams);
                hideLoader();

                if (sellResult && sellResult.orderId) {
                    const entryValue = parseFloat(tradeToClose.entryValue);
                    const exitValue = parseFloat(sellResult.cumExecValue);
                    const profit = (exitValue - entryValue).toFixed(2);
                    logMessage(`[Trade Manager] Bán thành công ${tradeToClose.quantity} ${tradeToClose.symbol}. Lợi nhuận ước tính: ${profit} USDT.`);
                    logMessage("Bot đã sẵn sàng tìm kiếm tín hiệu giao dịch tiếp theo.", false);
                    await fetchWalletBalance();
                } else {
                    logMessage(`[Trade Manager] LỖI NGHIÊM TRỌNG: Không thể đặt lệnh bán cho ${tradeToClose.symbol}. Cần can thiệp thủ công!`, true);
                }
            }

            function startTradeMonitor() {
                if (!state.activeTrade) return;

                const { symbol, entryPrice, lastAtr } = state.activeTrade;

                if (!lastAtr || lastAtr <= 0) {
                    logMessage(`[Trade Manager] Lỗi: Không có dữ liệu ATR hợp lệ cho ${symbol}. Không thể đặt TP/SL động.`, true);
                    closeActiveTrade("Lỗi dữ liệu ATR");
                    return;
                }
                
                const tpPrice = entryPrice + (lastAtr * CONFIG.ATR_TP_MULTIPLIER);
                const slPrice = entryPrice - (lastAtr * CONFIG.ATR_SL_MULTIPLIER);

                logMessage(`[Trade Manager] Bắt đầu giám sát ${symbol}. Entry: ${entryPrice.toFixed(4)}, ATR: ${lastAtr.toFixed(4)}, TP: ${tpPrice.toFixed(4)}, SL: ${slPrice.toFixed(4)}.`);
                
                const intervalId = setInterval(async () => {
                    if (!state.activeTrade || state.activeTrade.symbol !== symbol) {
                        clearInterval(intervalId);
                        return;
                    }
                    const tickerData = await bybitRequest('/v5/market/tickers', 'GET', { category: 'spot', symbol }, true);
                    if (tickerData?.list?.[0]) {
                        const currentPrice = parseFloat(tickerData.list[0].lastPrice);
                        updateScannerStatus(`Đang giám sát ${symbol}: ${currentPrice.toFixed(4)}`);
                        if (currentPrice >= tpPrice) {
                            closeActiveTrade(`Đạt Take Profit tại ${currentPrice.toFixed(4)}`);
                        } else if (currentPrice <= slPrice) {
                            closeActiveTrade(`Chạm Stop Loss tại ${currentPrice.toFixed(4)}`);
                        }
                    }
                }, CONSTANTS.TRADE_MONITOR_INTERVAL_MS);

                state.activeTrade.intervalId = intervalId;
            }

            // --- Auto Trade Execution ---
            async function executeAutoTrades(plans) {
                if (!state.autoTradeEnabled || plans.length === 0 || state.activeTrade) {
                    if (state.activeTrade) {
                        updateScannerStatus(`Đang trong giao dịch ${state.activeTrade.symbol}. Tạm dừng quét.`);
                    }
                    return;
                }

                logMessage("[Auto-Trade] Bắt đầu quy trình vào lệnh...");

                if (state.availableUsdt < CONFIG.MIN_ORDER_VALUE_USDT) {
                    logMessage(`[Auto-Trade] Số dư khả dụng (${state.availableUsdt.toFixed(2)} USDT) thấp hơn mức tối thiểu (${CONFIG.MIN_ORDER_VALUE_USDT} USDT). Không thể giao dịch.`, true);
                    return;
                }

                const maxCapitalPerTrade = parseFloat(ui.scanner.capital.value);
                const capitalToUse = Math.min(state.availableUsdt, maxCapitalPerTrade);
                
                if (capitalToUse < CONFIG.MIN_ORDER_VALUE_USDT) {
                    logMessage(`[Auto-Trade] Vốn sau khi giới hạn (${capitalToUse.toFixed(2)} USDT) thấp hơn mức tối thiểu (${CONFIG.MIN_ORDER_VALUE_USDT} USDT). Không thể giao dịch.`, true);
                    return;
                }
                
                const orderQty = (capitalToUse * 0.995).toFixed(5);

                logMessage(`[Auto-Trade] Vốn khả dụng: ${state.availableUsdt.toFixed(2)} USDT. Vốn tối đa: ${maxCapitalPerTrade.toFixed(2)} USDT. Sẽ sử dụng ~${orderQty} USDT cho lệnh.`);

                for (const plan of plans) {
                    logMessage(`[Auto-Trade] Thử vào lệnh cho tín hiệu #1: ${plan.symbol} với ${orderQty} USDT.`);
                    
                    showLoader(`Đang đặt lệnh Mua ${plan.symbol}...`);
                    const orderParams = {
                        category: 'spot', symbol: plan.symbol, side: 'Buy',
                        orderType: 'Market', qty: orderQty.toString(), marketUnit: 'quoteCoin'
                    };
                    const result = await placeOrder(orderParams);
                    hideLoader();

                    if (result && result.orderId && result.cumExecQty && parseFloat(result.cumExecQty) > 0) {
                        logMessage(`[Auto-Trade] VÀO LỆNH THÀNH CÔNG cho ${plan.symbol}.`);
                        state.activeTrade = {
                            symbol: plan.symbol,
                            entryPrice: parseFloat(result.avgPrice),
                            quantity: parseFloat(result.cumExecQty),
                            entryValue: parseFloat(result.cumExecValue),
                            lastAtr: plan.lastAtr,
                            intervalId: null,
                        };
                        startTradeMonitor();
                        return;
                    } else {
                        logMessage(`[Auto-Trade] Lệnh cho ${plan.symbol} thất bại hoặc không khớp. Thử tín hiệu tiếp theo...`, true);
                    }
                }
                logMessage(`[Auto-Trade] Đã thử tất cả ${plans.length} tín hiệu nhưng không có giao dịch nào thành công.`, true);
            }
            
            // --- UI Handlers & Initialization ---
            function setupEventListeners() {
                ui.saveApiBtn.addEventListener('click', () => {
                    state.apiKey = ui.apiKeyInput.value.trim();
                    state.apiSecret = ui.apiSecretInput.value.trim();
                    if (state.apiKey && state.apiSecret) {
                        localStorage.setItem('bybitApiKey', state.apiKey);
                        localStorage.setItem('bybitApiSecret', state.apiSecret);
                        logMessage('API Key và Secret đã được lưu. Đang xác thực...');
                        checkApiKeys();
                    } else { logMessage('Vui lòng nhập cả API Key và Secret.', true); }
                });

                ui.showApiKeysCheckbox.addEventListener('change', (e) => {
                    const type = e.target.checked ? 'text' : 'password';
                    ui.apiKeyInput.type = type;
                    ui.apiSecretInput.type = type;
                });
                
                ui.scanner.startBtn.addEventListener('click', startScanner);
                ui.scanner.stopBtn.addEventListener('click', stopScanner);
                
                ui.scanner.autoTradeToggle.addEventListener('change', (e) => {
                    state.autoTradeEnabled = e.target.checked;
                    logMessage(`[Auto-Trade] Tự động giao dịch đã được ${state.autoTradeEnabled ? 'BẬT' : 'TẮT'}.`);
                });

                ui.priceChartTab.addEventListener('click', () => {
                    ui.priceChartContainer.classList.remove('hidden');
                    ui.pnlChartContainer.classList.add('hidden');
                    ui.priceChartTab.classList.add('tab-active', 'text-white');
                    ui.pnlChartTab.classList.remove('tab-active', 'text-white');
                });
                 ui.pnlChartTab.addEventListener('click', () => {
                    ui.pnlChartContainer.classList.remove('hidden');
                    ui.priceChartContainer.classList.add('hidden');
                    ui.pnlChartTab.classList.add('tab-active', 'text-white');
                    ui.priceChartTab.classList.remove('tab-active', 'text-white');
                });
            }
             // --- Charting Functions ---
            function createChart(canvas) {
                const ctx = canvas.getContext('2d');
                 return new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { ticks: { color: '#9CA3AF', maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                            y: { ticks: { color: '#9CA3AF' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                        },
                        plugins: { legend: { labels: { color: '#D1D5DB' } }, tooltip: { titleColor: '#FFFFFF', bodyColor: '#E5E7EB', backgroundColor: '#1F2937' } }
                    }
                });
            }

            function initializeCharts() {
                if (state.priceChart) state.priceChart.destroy();
                state.priceChart = createChart(ui.priceChartCanvas);
                if (state.pnlChart) state.pnlChart.destroy();
                state.pnlChart = createChart(ui.pnlChartCanvas);
            }

            function renderPriceChart(symbol, klines) {
                if (!state.priceChart || !klines || klines.length === 0) return;
                
                const closes = klines.map(k => parseFloat(k[4]));
                const labels = klines.map(k => new Date(parseInt(k[0])).toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' }));
                const ema20 = TA.ema(closes, 20);
                const ema50 = TA.ema(closes, 50);
                const ema20Data = [...Array(klines.length - ema20.length).fill(null), ...ema20];
                const ema50Data = [...Array(klines.length - ema50.length).fill(null), ...ema50];

                state.priceChart.data.labels = labels;
                state.priceChart.data.datasets = [
                    { label: `Giá ${symbol}`, data: closes, borderColor: '#3498db', borderWidth: 2, tension: 0.1, pointRadius: 0 },
                    { label: 'EMA 20', data: ema20Data, borderColor: '#f1c40f', borderWidth: 1, pointRadius: 0 },
                    { label: 'EMA 50', data: ema50Data, borderColor: '#e74c3c', borderWidth: 1, pointRadius: 0 }
                ];
                state.priceChart.update();
            }

            function renderPnlChart() {
                if (!state.pnlChart || state.pnlHistory.length === 0) return;

                const labels = state.pnlHistory.map(p => p.time.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit'}));
                const data = state.pnlHistory.map(p => p.equity);
                
                const firstEquity = state.pnlHistory[0].equity;
                const pointBackgroundColors = data.map(equity => equity >= firstEquity ? 'rgba(46, 204, 113, 0.7)' : 'rgba(231, 76, 60, 0.7)');

                state.pnlChart.data.labels = labels;
                state.pnlChart.data.datasets = [{
                    label: 'Tổng Vốn (USD)',
                    data: data,
                    borderColor: '#2ecc71',
                    backgroundColor: 'rgba(46, 204, 113, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                    pointBackgroundColor: pointBackgroundColors,
                    pointRadius: 3,
                }];
                state.pnlChart.update();
            }

            function initialize() {
                const storedApiKey = localStorage.getItem('bybitApiKey');
                const storedApiSecret = localStorage.getItem('bybitApiSecret');
                if(storedApiKey && storedApiSecret) {
                    ui.apiKeyInput.value = storedApiKey;
                    ui.apiSecretInput.value = storedApiSecret;
                    state.apiKey = storedApiKey;
                    state.apiSecret = storedApiSecret;
                    checkApiKeys();
                } else {
                    updateApiStatus(false);
                }
                setupEventListeners();
                initializeCharts();
                logMessage('Bot đã sẵn sàng. Vui lòng lưu API key để kích hoạt các tính năng.');
            }
            
             // --- Scanner Logic ---
            async function executeScan() {
                if (state.isScanning || state.activeTrade) return;
                state.isScanning = true;
                logMessage(`[Scanner] Bắt đầu quét với thuật toán V4.2.1...`);
                try {
                    updateScannerStatus(`(B1) Lấy dữ liệu thị trường...`); showLoader(ui.scanner.status.textContent);
                    const instrumentsInfo = await bybitRequest('/v5/market/instruments-info', 'GET', { category: 'spot' }, true);
                    if (!instrumentsInfo || !instrumentsInfo.list) {
                        throw new Error("Không thể lấy danh sách cặp giao dịch từ Bybit.");
                    }
                    const allTradablePairs = instrumentsInfo.list.filter(i => i.status === 'Trading' && i.quoteCoin === 'USDT').map(i => i.symbol);

                    const allTickersData = await bybitRequest('/v5/market/tickers', 'GET', { category: 'spot' }, true);
                     if (!allTickersData || !allTickersData.list) {
                        throw new Error("Không thể lấy dữ liệu tickers từ Bybit.");
                    }
                    let universe = allTickersData.list.filter(t => allTradablePairs.includes(t.symbol) && parseFloat(t.turnover24h) > CONFIG.MIN_TURNOVER_24H).slice(0, 150);

                    updateScannerStatus(`(B2) Lấy dữ liệu chi tiết cho ${universe.length} cặp...`); showLoader(ui.scanner.status.textContent);
                    const dataPromises = universe.map(t => Promise.all([
                        bybitRequest('/v5/market/orderbook', 'GET', { category: 'spot', symbol: t.symbol, limit: 1 }, true),
                        bybitRequest('/v5/market/kline', 'GET', { category: 'spot', symbol: t.symbol, interval: '15', limit: 200 }, true)
                    ]));
                    const results = await Promise.all(dataPromises);
                    
                    state.scannedCandidates.clear();
                    for (let i = 0; i < universe.length; i++) {
                        const [ob, klineData] = results[i];
                        if (ob && klineData?.list?.length >= 51) {
                            const ticker = universe[i];
                            const ask = ob?.a?.[0]?.[0] ?? ticker.ask1Price;
                            const bid = ob?.b?.[0]?.[0] ?? ticker.bid1Price;
                            const candidateData = { ...ticker, spread_bps: ((ask - bid) / ask) * 10000, klines: klineData.list.reverse() };
                            state.scannedCandidates.set(ticker.symbol, candidateData);
                        }
                    }
                    
                    updateScannerStatus(`(B3) Chấm điểm ${state.scannedCandidates.size} cặp với logic "Bắt đáy trong Uptrend"...`); showLoader(ui.scanner.status.textContent);
                    let processedCandidates = [];
                    for (const [symbol, cand] of state.scannedCandidates.entries()) {
                        const closes = cand.klines.map(k => parseFloat(k[4]));
                        const lastPrice = closes[closes.length - 1];
                        if (!lastPrice || closes.length < 52) continue; // Need at least 2 RSI values

                        const ema20 = TA.ema(closes, 20).pop();
                        const ema50 = TA.ema(closes, 50).pop();
                        const rsiValues = TA.rsi(closes, 14);
                        const atrValues = TA.atr(cand.klines, 14);

                        if (ema20 === undefined || ema50 === undefined || rsiValues.length < 2 || atrValues.length < 1) continue;
                        
                        const lastRsi = rsiValues[rsiValues.length - 1];
                        const prevRsi = rsiValues[rsiValues.length - 2];
                        const lastAtr = atrValues[atrValues.length - 1];

                        const isUptrend = ema20 > ema50;
                        const priceAboveTrend = lastPrice > ema50;
                        const inPullbackZone = lastRsi > 45 && lastRsi < 65;
                        const isRecovering = lastRsi > prevRsi;

                        if (isUptrend && priceAboveTrend && inPullbackZone && isRecovering) {
                            const rsiScore = (65 - lastRsi) / 20; 
                            const proximityToEmaScore = 1 - Math.min(1, Math.abs(lastPrice - ema20) / lastPrice * 10);
                            const spreadScore = 1 - Math.min(1, cand.spread_bps / 30);
                            const finalScore = (rsiScore * 0.5) + (proximityToEmaScore * 0.3) + (spreadScore * 0.2);

                            processedCandidates.push({ ...cand, raos: finalScore, regime: 'Uptrend Pullback', rsi: lastRsi, lastAtr: lastAtr });
                        }
                    }
                    processedCandidates.sort((a, b) => b.raos - a.raos);
                    
                    const topPicks = processedCandidates.slice(0, 3);
                    displayScanResults(topPicks);
                    if (topPicks.length > 0) {
                        renderPriceChart(topPicks[0].symbol, topPicks[0].klines);
                    } else {
                        initializeCharts(); 
                    }

                    logMessage(`[Scanner] Quét hoàn tất. Hiển thị ${topPicks.length} tín hiệu tiềm năng.`);
                    updateScannerStatus(`Quét xong. Cập nhật lần cuối: ${new Date().toLocaleTimeString('vi-VN')}`);
                    
                    await executeAutoTrades(topPicks);
                
                } catch (error) {
                    logMessage(`[Scanner] Lỗi: ${error.message}`, true);
                    updateScannerStatus("Đã xảy ra lỗi. Kiểm tra log và thử lại.");
                    displayScanResults([]);
                } finally {
                    state.isScanning = false;
                    hideLoader();
                }
            }

            function displayScanResults(results) {
                 ui.scanner.results.innerHTML = '';
                if (!results || results.length === 0) {
                    ui.scanner.results.innerHTML = '<div class="col-span-full text-center text-gray-400">Không có kế hoạch giao dịch nào phù hợp.</div>';
                    return;
                }
                results.forEach((item, index) => {
                    const capitalDisplay = index === 0 ? `(Ưu tiên #1)` : '(Dự phòng)';
                    const lastPrice = parseFloat(item.lastPrice);
                    const potentialTp = lastPrice + (item.lastAtr * CONFIG.ATR_TP_MULTIPLIER);
                    const potentialSl = lastPrice - (item.lastAtr * CONFIG.ATR_SL_MULTIPLIER);
                    const cardHTML = `
                        <div class="bg-gray-900/50 rounded-xl p-4 border border-gray-700 flex flex-col space-y-3 ${index > 0 ? 'opacity-60' : ''}">
                            <div class="flex justify-between items-center">
                                <h3 class="text-lg font-bold text-cyan-400">${item.symbol}</h3>
                                <span class="px-2 py-1 text-xs font-semibold rounded-full regime-trend">${item.regime} ${capitalDisplay}</span>
                            </div>
                            <div class="grid grid-cols-2 gap-x-4 text-sm">
                                <span class="text-gray-400">Score</span><span class="font-semibold text-yellow-400 text-right">${item.raos?.toFixed(3) ?? 'N/A'}</span>
                                <span class="text-gray-400">RSI(14)</span><span class="font-semibold text-white text-right">${item.rsi?.toFixed(2) ?? 'N/A'}</span>
                                <span class="text-gray-400">Spread</span><span class="font-semibold text-white text-right">${item.spread_bps?.toFixed(2) ?? 'N/A'} bps</span>
                            </div>
                             <div class="border-t border-gray-700 pt-2 mt-2 text-xs">
                                <p class="font-semibold text-gray-400">TP/SL Động (dựa trên ATR):</p>
                                <div class="flex justify-between"><span>Chốt lời (ước tính):</span><span class="text-green-400">${potentialTp.toFixed(4)}</span></div>
                                <div class="flex justify-between"><span>Cắt lỗ (ước tính):</span><span class="text-red-400">${potentialSl.toFixed(4)}</span></div>
                            </div>
                             <button class="view-chart-btn mt-2 w-full bg-gray-600 hover:bg-gray-500 text-white text-xs font-bold py-2 px-4 rounded-lg transition" data-symbol="${item.symbol}">Xem Biểu Đồ</button>
                        </div>`;
                    ui.scanner.results.innerHTML += cardHTML;
                });

                document.querySelectorAll('.view-chart-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const symbol = e.target.dataset.symbol;
                        const candidateData = state.scannedCandidates.get(symbol);
                        if(candidateData) {
                            renderPriceChart(symbol, candidateData.klines);
                        }
                    });
                });
            }
           
            const startScanner = () => {
                if (!state.apiKeysValid) { logMessage('API keys không hợp lệ.', true); return; }
                if (state.scannerIntervalId || state.activeTrade) { logMessage('Bot đang bận, vui lòng dừng trước khi bắt đầu lại.', true); return; }
                logMessage("Bắt đầu công cụ quét thị trường...");
                ui.scanner.startBtn.disabled = true;
                ui.scanner.stopBtn.disabled = false;
                
                fetchWalletBalance(); 
                state.balanceUpdateIntervalId = setInterval(fetchWalletBalance, CONSTANTS.BALANCE_UPDATE_INTERVAL_MS);

                executeScan();
                state.scannerIntervalId = setInterval(executeScan, CONSTANTS.SCANNER_INTERVAL_MS);
            };
            const stopScanner = () => {
                if (state.scannerIntervalId) {
                    clearInterval(state.scannerIntervalId);
                    state.scannerIntervalId = null;
                }
                if (state.balanceUpdateIntervalId) {
                    clearInterval(state.balanceUpdateIntervalId);
                    state.balanceUpdateIntervalId = null;
                }
                logMessage("Công cụ quét đã dừng bởi người dùng.");
                updateScannerStatus("Công cụ quét đang không hoạt động.");
                ui.scanner.startBtn.disabled = false;
                ui.scanner.stopBtn.disabled = true;

                 if(state.activeTrade) {
                    closeActiveTrade("Người dùng yêu cầu dừng bot.");
                }
            };
            
            // --- Start the application ---
            initialize();
        });
    </script>
</body>
</html>

