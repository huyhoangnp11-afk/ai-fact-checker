<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bybit Bot v9.0 - Production Ready</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
  <style>
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODERN LIGHT THEME - Professional & Clean â˜€ï¸
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    :root {
      --bg: #f5f7fa;
      --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
      --card: #ffffff;
      --card-hover: #fafbfc;
      --border: #e1e4e8;
      --border-light: #f0f2f5;
      --text: #1a202c;
      --text-secondary: #4a5568;
      --text-dim: #718096;
      --accent: #4f46e5;
      --accent-hover: #4338ca;
      --accent-light: #eef2ff;
      --success: #059669;
      --success-light: #d1fae5;
      --danger: #dc2626;
      --danger-light: #fee2e2;
      --warning: #d97706;
      --warning-light: #fef3c7;
      --info: #0891b2;
      --info-light: #cffafe;
      --shadow: 0 2px 8px rgba(0,0,0,0.06);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ANIMATIONS & TRANSITIONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .fade-in {
      animation: fadeIn 0.4s ease-out;
    }

    .slide-in {
      animation: slideIn 0.4s ease-out;
    }

    .pulse {
      animation: pulse 2s ease-in-out infinite;
    }

    .spin {
      animation: spin 1s linear infinite;
    }

    .bounce {
      animation: bounce 1s ease-in-out infinite;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      line-height: 1.6;
      font-size: 14px;
      min-height: 100vh;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LAYOUT
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: var(--shadow-md);
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      color: var(--text);
    }

    .status {
      padding: 8px 16px;
      background: var(--border);
      border-radius: 8px;
      font-size: 13px;
      color: var(--text-dim);
    }

    .status.active { background: var(--success); color: white; }
    .status.error { background: var(--danger); color: white; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TABS SYSTEM
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0;
    }

    .tab {
      padding: 12px 24px;
      background: transparent;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      margin-bottom: -2px;
    }

    .tab:hover {
      color: var(--text);
      background: rgba(59, 130, 246, 0.1);
    }

    .tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       GRID & CARDS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 20px;
      margin-bottom: 20px;
    }

    .col-3 { grid-column: span 3; }
    .col-4 { grid-column: span 4; }
    .col-6 { grid-column: span 6; }
    .col-8 { grid-column: span 8; }
    .col-12 { grid-column: span 12; }

    @media (max-width: 1200px) {
      .col-3, .col-4 { grid-column: span 6; }
    }

    @media (max-width: 768px) {
      .col-3, .col-4, .col-6, .col-8 { grid-column: span 12; }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RESPONSIVE ENHANCEMENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 16px;
        text-align: center;
      }

      .header h1 {
        font-size: 20px;
      }

      .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tab {
        padding: 10px 16px;
        font-size: 13px;
        white-space: nowrap;
      }

      .card {
        padding: 16px;
        border-radius: 12px;
      }

      .card-title {
        font-size: 14px;
      }

      .btn {
        padding: 10px 16px;
        font-size: 13px;
      }

      .modal-content {
        padding: 24px;
        margin: 16px;
      }

      .grid {
        gap: 12px;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 12px;
      }

      .header {
        padding: 16px;
        margin-bottom: 12px;
      }

      body {
        font-size: 13px;
      }
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      animation: fadeIn 0.5s ease-out;
    }

    .card:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
      border-color: var(--accent);
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FORM ELEMENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    label {
      display: block;
      color: var(--text-dim);
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input, select {
      width: 100%;
      background: var(--card);
      border: 1.5px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.2s;
    }

    input:hover, select:hover {
      border-color: var(--text-dim);
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
      background: white;
      box-shadow: 0 0 0 4px var(--accent-light);
    }

    input[type="checkbox"] {
      width: auto;
      accent-color: var(--accent);
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .form-row > * {
      flex: 1;
      min-width: 150px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUTTONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: var(--shadow);
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-secondary {
      background: var(--border);
      color: var(--text);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TOOLTIPS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    [data-tooltip] {
      position: relative;
      cursor: help;
    }

    [data-tooltip]::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-8px);
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: var(--shadow-lg);
    }

    [data-tooltip]::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-2px);
      border: 6px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.9);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
    }

    [data-tooltip]:hover::before,
    [data-tooltip]:hover::after {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODAL / DIALOG
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--card);
      border-radius: 16px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease-out;
    }

    .modal-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text);
    }

    .modal-body {
      color: var(--text-secondary);
      margin-bottom: 24px;
      line-height: 1.6;
    }

    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #2a3254;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-group {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOG CONSOLE
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .log-console {
      background: #1a1f2e;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      height: 300px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
    }

    .log-line {
      margin-bottom: 4px;
    }

    .log-info { color: #94a3b8; }
    .log-success { color: #10b981; }
    .log-warning { color: #fbbf24; }
    .log-error { color: #f87171; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TABLE
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th {
      background: var(--border-light);
      color: var(--text-secondary);
      font-weight: 700;
      text-align: left;
      padding: 14px 16px;
      border-bottom: 2px solid var(--border);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    td {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-light);
      color: var(--text);
    }

    tr:hover {
      background: var(--accent-light);
      transition: background 0.2s;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       UTILITIES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .badge {
      padding: 5px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge-success {
      background: var(--success-light);
      color: var(--success);
      border: 1px solid var(--success);
    }
    .badge-danger {
      background: var(--danger-light);
      color: var(--danger);
      border: 1px solid var(--danger);
    }
    .badge-warning {
      background: var(--warning-light);
      color: var(--warning);
      border: 1px solid var(--warning);
    }
    .badge-info {
      background: var(--info-light);
      color: var(--info);
      border: 1px solid var(--info);
    }

    .text-success { color: var(--success); }
    .text-danger { color: var(--danger); }
    .text-warning { color: var(--warning); }
    .text-dim { color: var(--text-dim); }

    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-between { justify-content: space-between; }
    .gap-2 { gap: 8px; }
    .gap-4 { gap: 16px; }
    .mt-4 { margin-top: 16px; }
    .mb-4 { margin-bottom: 16px; }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px 12px;
      background: var(--bg);
      border-radius: 6px;
      font-size: 13px;
      text-transform: none;
      letter-spacing: 0;
    }

    .checkbox-label:hover {
      background: var(--border);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       UTILITY CLASSES & NEW COMPONENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    .mt-3 { margin-top: 12px; }
    .mb-3 { margin-bottom: 12px; }

    /* Metrics Grid */
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .metric-item {
      background: var(--bg);
      padding: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .metric-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
    }

    .metric-value.positive {
      color: var(--success);
    }

    .metric-value.negative {
      color: var(--danger);
    }
  </style>
</head>
<body>

<div class="container">

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       HEADER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="header">
    <div>
      <h1>ğŸš€ Bybit Bot v9.0 <span class="badge badge-danger" style="font-size: 14px;">AGGRESSIVE MODE ğŸ’°</span></h1>
      <div class="text-dim" style="font-size: 12px; margin-top: 4px;">Production-Ready Trading System | Profit-Optimized ğŸ”¥</div>
    </div>
    <div class="status" id="systemStatus">Ready</div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TABS NAVIGATION
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tabs">
    <button class="tab active" data-tab="setup">âš™ï¸ Setup</button>
    <button class="tab" data-tab="strategy">ğŸ¯ Strategy</button>
    <button class="tab" data-tab="live">â–¶ï¸ Live Trading</button>
    <button class="tab" data-tab="results">ğŸ“Š Results</button>
    <button class="tab" data-tab="backtest">ğŸ“ˆ Backtesting</button>
    <button class="tab" data-tab="analytics">ğŸ“Š Analytics</button>
    <button class="tab" data-tab="alerts">ğŸ”” Alerts</button>
    <button class="tab" data-tab="advanced">ğŸ¤– Advanced</button>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 1: SETUP
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content active" id="tab-setup">
    <div class="grid">

      <!-- Mode & Capital -->
      <div class="card col-4">
        <div class="card-title">ğŸ’¼ Mode & Capital</div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="simMode" checked>
            <span>ğŸ® SIM Mode (Virtual Trading)</span>
          </label>
        </div>

        <div id="simSettings">
          <div class="form-group">
            <label>Virtual Capital (USDT)</label>
            <input type="number" id="simCapital" value="1000" min="100" step="100">
          </div>
        </div>

        <div id="apiSettings" style="display: none;">
          <div class="form-group">
            <label>API Key</label>
            <input type="password" id="apiKey" placeholder="Your API Key">
          </div>
          <div class="form-group">
            <label>API Secret</label>
            <input type="password" id="apiSecret" placeholder="Your API Secret">
          </div>
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="useTestnet">
              <span>Use Testnet</span>
            </label>
          </div>
        </div>
      </div>

      <!-- Telegram Notifications -->
      <div class="card col-4">
        <div class="card-title">ğŸ“± Telegram</div>

        <div class="form-group">
          <label>Bot Token</label>
          <input type="text" id="tgToken" placeholder="123456:ABC...">
        </div>

        <div class="form-group">
          <label>Chat ID</label>
          <input type="text" id="tgChat" placeholder="123456789">
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="tgEnabled">
            <span>Enable Notifications</span>
          </label>
        </div>
      </div>

      <!-- Quick Stats -->
      <div class="card col-4">
        <div class="card-title">ğŸ“ˆ Quick Stats</div>

        <div style="display: grid; gap: 12px;">
          <div class="flex justify-between">
            <span class="text-dim">Mode:</span>
            <span id="statMode" class="badge badge-info">SIM</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Balance:</span>
            <span id="statBalance" class="text-success">1,000 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Total PnL:</span>
            <span id="statPnL">0.00 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Total Fees:</span>
            <span id="statFees" class="text-warning">0.00 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Win Rate:</span>
            <span id="statWinRate">0%</span>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 2: STRATEGY
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-strategy">
    <div class="grid">

      <!-- Strategy Selection -->
      <div class="card col-6">
        <div class="card-title">ğŸ¯ Strategy</div>

        <div class="form-group">
          <label>Trading Strategy</label>
          <select id="strategyType">
            <option value="pump">ğŸš€ Pump Hunter PRO</option>
            <option value="scalping">âš¡ Scalping (EMA Cross)</option>
            <option value="smart">ğŸ§  Smart Entry (SR + Fib)</option>
            <option value="pullback">ğŸ“‰ Pullback Score</option>
          </select>
        </div>

        <div class="form-group">
          <label>Timeframe</label>
          <select id="timeframe">
            <option value="1">1 minute</option>
            <option value="3">3 minutes</option>
            <option value="5" selected>5 minutes</option>
            <option value="15">15 minutes</option>
            <option value="30">30 minutes</option>
          </select>
        </div>

        <div class="form-group">
          <label>Position Size (USDT)</label>
          <input type="number" id="positionSize" value="100" min="10" step="10">
        </div>
      </div>

      <!-- Risk Management -->
      <div class="card col-6">
        <div class="card-title">ğŸ›¡ï¸ Risk Management</div>

        <div class="form-group">
          <label>Take Profit (%)</label>
          <input type="number" id="takeProfit" value="1.5" step="0.1">
        </div>

        <div class="form-group">
          <label>Stop Loss (%)</label>
          <input type="number" id="stopLoss" value="0.8" step="0.1">
        </div>

        <div class="form-group">
          <label>Trading Fee (% per trade)</label>
          <input type="number" id="tradingFee" value="0.1" step="0.01" min="0" max="1">
          <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
            Bybit: Spot ~0.1%, Futures ~0.055%
          </div>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="trailingStop">
            <span>ğŸ”„ Trailing Stop</span>
          </label>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="conservativeMode">
            <span>ğŸ’° Conservative Mode (High Win Rate)</span>
          </label>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="quickProfitMode">
            <span>âš¡ QUICK PROFIT MODE - VÃ o nhanh, lá»i nhanh (SCALPING)</span>
          </label>
          <div style="font-size: 11px; color: var(--warning); margin-top: 4px; padding: 8px; background: var(--warning-light); border-radius: 6px; border-left: 3px solid var(--warning);">
            <strong>âš ï¸ Cáº¢NH BÃO:</strong> Cháº¿ Ä‘á»™ nÃ y CUC Ká»² RISK!<br>
            â€¢ TP siÃªu nhá»: 0.3-0.8% (lá»i nhanh)<br>
            â€¢ Leverage cao: 10-20x<br>
            â€¢ Nhiá»u lá»‡nh liÃªn tá»¥c (scalping)<br>
            â€¢ CÃ³ thá»ƒ máº¥t vá»‘n ráº¥t nhanh náº¿u market Ä‘i ngÆ°á»£c!
          </div>
        </div>
      </div>

      <!-- Filters -->
      <div class="card col-12">
        <div class="card-title">ğŸ” Market Filters</div>

        <div class="form-row">
          <div class="form-group">
            <label>Min Volume (USDT)</label>
            <input type="number" id="minVolume" value="1000000" step="100000">
          </div>

          <div class="form-group">
            <label>Min Pump (%)</label>
            <input type="number" id="minPump" value="1.0" step="0.1">
          </div>

          <div class="form-group">
            <label>Max Spread (%)</label>
            <input type="number" id="maxSpread" value="0.3" step="0.05">
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="btcFilter" checked>
              <span>ğŸ“Š BTC Trend Filter</span>
            </label>
          </div>
        </div>
      </div>

      <!-- Risk Management -->
      <div class="card col-12">
        <div class="card-title">ğŸ›¡ï¸ Advanced Risk Management</div>

        <div class="form-row">
          <div class="form-group">
            <label>Max Positions <span class="badge badge-warning">AGGRESSIVE ğŸš€</span></label>
            <input type="number" id="maxPositions" value="5" min="1" max="10">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Trade tá»‘i Ä‘a bao nhiÃªu coin cÃ¹ng lÃºc (Default: 5 - More profit!)
            </div>
          </div>

          <div class="form-group">
            <label>Max Drawdown (%) <span class="badge badge-warning">AGGRESSIVE ğŸ”¥</span></label>
            <input type="number" id="maxDrawdownPercent" value="30" min="5" max="50" step="1">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Dá»«ng bot khi lá»— quÃ¡ % nÃ y
            </div>
          </div>

          <div class="form-group">
            <label>Daily Loss Limit (USDT) <span class="badge badge-warning">200 ğŸ’ª</span></label>
            <input type="number" id="dailyLossLimit" value="200" min="10" step="10">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Giá»›i háº¡n lá»— tá»‘i Ä‘a trong 1 ngÃ y (Higher for more trades!)
            </div>
          </div>

          <div class="form-group">
            <label>Risk per Trade (%) <span class="badge badge-warning">AGGRESSIVE 3%</span></label>
            <input type="number" id="riskPerTrade" value="3" min="0.5" max="5" step="0.5">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Rá»§i ro % vá»‘n cho má»—i lá»‡nh
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 3: LIVE TRADING
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-live">
    <div class="grid">

      <!-- Controls -->
      <div class="card col-12">
        <div class="card-title">ğŸ® Trading Controls</div>

        <div class="btn-group">
          <button class="btn btn-success" id="btnStart">â–¶ï¸ Start Trading</button>
          <button class="btn btn-danger" id="btnStop" disabled>â¹ï¸ Stop</button>
          <button class="btn btn-primary" id="btnSmartScan">ğŸ” Smart Scan (All Coins)</button>
          <button class="btn btn-secondary" id="btnTest">ğŸ§ª Test System</button>
        </div>

        <div style="margin-top: 12px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 12px; color: var(--text-dim);">
          <strong>Smart Scan:</strong> QuÃ©t toÃ n bá»™ coin Bybit, phÃ¢n tÃ­ch ká»¹ thuáº­t vÃ  chá»n tÃ­n hiá»‡u tá»‘t nháº¥t
        </div>
      </div>

      <!-- Active Positions -->
      <div class="card col-12">
        <div class="card-title">ğŸ“Š Active Positions (<span id="positionCount">0</span>/<span id="maxPosCount">3</span>)</div>
        <div style="overflow-x: auto;">
          <table>
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Entry</th>
                <th>Current</th>
                <th>Size</th>
                <th>Unrealized PnL</th>
                <th>%</th>
                <th>Time</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="activePositionsTable">
              <tr>
                <td colspan="8" style="text-align: center; color: var(--text-dim); padding: 20px;">No active positions</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Live Log -->
      <div class="card col-12">
        <div class="card-title">ğŸ“ Live Log</div>
        <div class="log-console" id="liveLog">
          <div class="log-line log-info">[SYSTEM] Bybit Bot v9.0 CLEAN initialized successfully</div>
          <div class="log-line log-success">[READY] Click "Start Trading" to begin</div>
        </div>
      </div>

      <!-- Price Chart -->
      <div class="card col-6">
        <div class="card-title">ğŸ“ˆ Price Chart (Realtime)</div>

        <!-- Chart Controls -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.charts.priceChart?.resetZoom()"
                  data-tooltip="Reset zoom vÃ  pan">
            ğŸ”„ Reset Zoom
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(1)"
                  data-tooltip="Toggle EMA 20">
            ğŸ“Š EMA 20
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(2)"
                  data-tooltip="Toggle EMA 50">
            ğŸ“Š EMA 50
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(3)"
                  data-tooltip="Toggle Volume">
            ğŸ“Š Volume
          </button>
        </div>

        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="priceChart"></canvas>
        </div>

        <div style="margin-top: 8px; font-size: 11px; color: var(--text-dim); text-align: center;">
          ğŸ’¡ Scroll Ä‘á»ƒ zoom, Ctrl + KÃ©o Ä‘á»ƒ pan, Click legend Ä‘á»ƒ toggle indicators
        </div>
      </div>

      <!-- PnL Chart -->
      <div class="card col-6">
        <div class="card-title">ğŸ’° PnL Chart</div>
        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="pnlChart"></canvas>
        </div>
      </div>

      <!-- Technical Analysis -->
      <div class="card col-12">
        <div class="card-title">ğŸ” Technical Analysis (Auto)</div>
        <div id="technicalAnalysis" class="log-console" style="height: 200px;">
          <div class="log-line log-info">Technical analysis will appear here when trading starts...</div>
        </div>
      </div>

      <!-- News Sentiment -->
      <div class="card col-12">
        <div class="card-title">ğŸ“° News Sentiment (Real-time)</div>
        <div id="newsSentiment" class="log-console" style="height: 150px;">
          <div class="log-line log-info">News sentiment will appear here when trading starts...</div>
        </div>
        <div id="newsHeadlines" style="margin-top: 10px; font-size: 11px; color: var(--text-dim);">
          <div style="font-weight: 600; margin-bottom: 6px;">Latest Headlines:</div>
          <div id="headlinesList" style="max-height: 100px; overflow-y: auto;"></div>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 4: RESULTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-results">
    <div class="grid">

      <!-- Performance Summary -->
      <div class="card col-12">
        <div class="card-title">ğŸ“Š Performance Dashboard</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px;">
          <div>
            <div class="text-dim" style="font-size: 11px;">Total Trades</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfTrades">0</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Win Rate</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfWinRate">0%</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Profit Factor</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfProfitFactor">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Avg R:R</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfAvgRR">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Max Drawdown</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--danger);" id="perfMaxDD">0%</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Gross PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfGrossPnL">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Total Fees</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--warning);" id="perfFees">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Net PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfPnL">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Best Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--success);" id="perfBest">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Worst Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--danger);" id="perfWorst">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Avg Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfAvg">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Today's PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfToday">0.00</div>
          </div>
        </div>
      </div>

      <!-- Risk Status -->
      <div class="card col-12">
        <div class="card-title">ğŸ›¡ï¸ Risk Status</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
          <div>
            <div class="text-dim" style="font-size: 12px;">Current Drawdown</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;" id="riskCurrentDD">0%</div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskDDBar" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Daily Loss</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;" id="riskDailyLoss">0 USDT</div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskDailyBar" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Active Positions</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;"><span id="riskActivePos">0</span> / <span id="riskMaxPos">3</span></div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskPosBar" style="height: 100%; width: 0%; background: var(--accent); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Risk Status</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;">
              <span id="riskStatus" class="badge badge-success">SAFE</span>
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: var(--text-dim);" id="riskMessage">
              All systems operational
            </div>
          </div>
        </div>
      </div>

      <!-- Cumulative PnL Chart -->
      <div class="card col-12">
        <div class="card-title">ğŸ“Š Cumulative PnL</div>
        <div style="height: 250px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="cumulativePnlChart"></canvas>
        </div>
      </div>

      <!-- Trade History -->
      <div class="card col-12">
        <div class="card-title">ğŸ“œ Trade History</div>

        <div style="overflow-x: auto;">
          <table id="tradeTable">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Entry</th>
                <th>Exit</th>
                <th>Gross PnL</th>
                <th>Fees</th>
                <th>Net PnL</th>
                <th>%</th>
              </tr>
            </thead>
            <tbody id="tradeTableBody">
              <tr>
                <td colspan="8" style="text-align: center; color: var(--text-dim);">No trades yet</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 5: ADVANCED
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-advanced">
    <div class="grid">

      <!-- Full Auto Mode -->
      <div class="card col-6">
        <div class="card-title">ğŸ¤– Full Automation</div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="fullAutoMode">
            <span>Enable Full Auto Mode (100% Automated)</span>
          </label>
        </div>

        <div class="text-dim" style="font-size: 12px; margin-top: 12px;">
          Full Auto Mode includes:
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>Auto parameter optimization</li>
            <li>Auto market regime detection</li>
            <li>Auto risk adjustment</li>
            <li>Auto recovery from losses</li>
            <li>Daily performance reports</li>
          </ul>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="btnStartAuto" data-tooltip="Khá»Ÿi Ä‘á»™ng cháº¿ Ä‘á»™ tá»± Ä‘á»™ng hoÃ n toÃ n">ğŸš€ Start Full Auto</button>
        </div>
      </div>

      <!-- LIVED - SURVIVAL TRADING AI -->
      <div class="card col-6" style="border: 3px solid var(--danger); background: linear-gradient(135deg, var(--card) 0%, var(--danger-light) 100%);">
        <div class="card-title">ğŸ”¥ LIVED - SURVIVAL TRADING AI ğŸ’€</div>

        <div style="padding: 16px; background: var(--danger-light); border-radius: 8px; border-left: 4px solid var(--danger); margin-bottom: 16px;">
          <div style="font-weight: 600; color: var(--danger); margin-bottom: 8px;">ğŸ’€ "LIVE OR DIE"</div>
          <div style="font-size: 12px; color: var(--text-secondary);">
            <strong>KhÃ´ng lá»i = KhÃ´ng tá»“n táº¡i!</strong><br>
            AI trader thÃ¨m khÃ¡t lá»£i nhuáº­n, lÃ m Má»ŒI GIÃ Ä‘á»ƒ sinh tá»“n!
          </div>
        </div>

        <div class="text-dim" style="font-size: 12px; margin-bottom: 16px;">
          <div style="font-weight: 600; margin-bottom: 8px;">âš”ï¸ LIVED Brain - Survival Engine:</div>
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>ğŸ’€ SÄƒn lÃ¹ng cÆ¡ há»™i khÃ´ng ngá»«ng nghá»‰</li>
            <li>ğŸ”¥ Aggressive, thÃ¨m khÃ¡t profit</li>
            <li>âš”ï¸ Quyáº¿t Ä‘á»‹nh máº¡nh máº½, khÃ´ng do dá»±</li>
            <li>ğŸ¯ Maximum profit > Safety</li>
            <li>ğŸ’° Tá»± phá»¥c há»“i khi thua - BÃO THÃ™!</li>
            <li>ğŸ”ª Tá»± tÄƒng risk khi tháº¯ng - Bá»¨C PHÃ!</li>
            <li>ğŸ˜¤ KhÃ´ng bao giá» tá»« bá» - SINH Tá»’N!</li>
            <li>âš¡ Há»c tá»« má»—i trade - TIáº¾N HÃ“A!</li>
          </ul>
        </div>

        <div style="padding: 12px; background: var(--warning-light); border-radius: 8px; margin-bottom: 16px;">
          <div style="font-size: 11px; color: var(--danger); font-weight: 600;">
            âš ï¸ Cáº¢NH BÃO: AI nÃ y trade nhÆ° Ä‘ang chiáº¿n Ä‘áº¥u Ä‘á»ƒ sá»‘ng!<br>
            ğŸ’€ Aggressive, thÃ¨m khÃ¡t, khÃ´ng tá»« bá», tÃ¬m má»i cÃ¡ch Ä‘á»ƒ cÃ³ lá»i!
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="btnStartFullAutonomous"
                  style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); font-size: 15px; padding: 14px 28px; font-weight: 700;"
                  data-tooltip="Tháº£ LIVED vÃ o thá»‹ trÆ°á»ng - Sá»‘ng hoáº·c cháº¿t!">
            ğŸ’€ UNLEASH LIVED - LET IT TRADE!
          </button>
        </div>

        <div style="margin-top: 12px; font-size: 11px; color: var(--danger); text-align: center; font-weight: 600;">
          ğŸ”¥ "KhÃ´ng lá»i = KhÃ´ng tá»“n táº¡i. TÃ´i sáº½ lÃ m má»i giÃ¡!" ğŸ’€
        </div>
      </div>

      <!-- Technical Analysis -->
      <div class="card col-6">
        <div class="card-title">ğŸ” Technical Analysis</div>

        <div class="form-row">
          <div class="form-group">
            <label>Symbol</label>
            <input type="text" id="analysisSymbol" value="BTCUSDT" placeholder="BTCUSDT">
          </div>

          <div class="form-group">
            <label>Timeframe</label>
            <select id="analysisTimeframe">
              <option value="5" selected>5m</option>
              <option value="15">15m</option>
              <option value="30">30m</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" id="btnAnalyze">ğŸ” Analyze</button>

        <div id="analysisResult" class="mt-4" style="font-size: 12px; font-family: monospace; background: var(--bg); padding: 12px; border-radius: 8px; max-height: 200px; overflow-y: auto;">
          Click "Analyze" to start...
        </div>
      </div>

      <!-- Auto Tuner -->
      <div class="card col-12">
        <div class="card-title">âš™ï¸ Auto Parameter Tuner</div>

        <div class="text-dim" style="font-size: 12px; margin-bottom: 16px;">
          Automatically optimizes trading parameters to achieve >50% win rate using Bayesian optimization and backtesting.
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>Target Win Rate (%)</label>
            <input type="number" id="targetWinRate" value="55" min="50" max="80">
          </div>

          <div class="form-group">
            <label>Optimization Rounds</label>
            <input type="number" id="optimizationRounds" value="50" min="10" max="200" step="10">
          </div>
        </div>

        <button class="btn btn-primary" id="btnOptimize">âš¡ Start Optimization</button>

        <div id="optimizationLog" class="mt-4 log-console" style="height: 150px;"></div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 6: BACKTESTING
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-backtest">
    <div class="grid">

      <!-- Backtest Config -->
      <div class="card col-4">
        <div class="card-title">âš™ï¸ Backtest Configuration</div>

        <div class="form-group">
          <label>Test Period</label>
          <select id="backtestPeriod">
            <option value="7">Last 7 Days</option>
            <option value="14">Last 14 Days</option>
            <option value="30" selected>Last 30 Days</option>
            <option value="90">Last 90 Days</option>
          </select>
        </div>

        <div class="form-group">
          <label>Starting Capital (USDT)</label>
          <input type="number" id="backtestCapital" value="1000" min="100" step="100">
        </div>

        <div class="form-group">
          <label>Strategy to Test</label>
          <select id="backtestStrategy">
            <option value="pump">Pump Hunter PRO</option>
            <option value="pullback">Pullback Score</option>
            <option value="scalping">Scalping (EMA Cross)</option>
            <option value="smart">Smart Entry (S/R + Fib)</option>
          </select>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="backtestQuickMode">
            <span>âš¡ Quick Profit Mode</span>
          </label>
        </div>

        <button class="btn btn-primary" id="btnRunBacktest">
          ğŸš€ Run Backtest
        </button>

        <div style="margin-top: 12px; font-size: 11px; color: var(--text-dim);">
          â±ï¸ Estimated time: ~30-60 seconds
        </div>
      </div>

      <!-- Backtest Results -->
      <div class="card col-8">
        <div class="card-title">ğŸ“Š Backtest Results</div>

        <div id="backtestResults" style="min-height: 300px;">
          <div style="text-align: center; padding: 60px 20px; color: var(--text-dim);">
            <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“ˆ</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Ready to Backtest</div>
            <div style="font-size: 13px;">Configure settings and click "Run Backtest" to start</div>
          </div>
        </div>
      </div>

      <!-- Equity Curve Chart -->
      <div class="card col-12">
        <div class="card-title">ğŸ“ˆ Equity Curve</div>
        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="equityCurveChart"></canvas>
        </div>
      </div>

      <!-- Strategy Comparison -->
      <div class="card col-12">
        <div class="card-title">ğŸ”¬ Strategy Comparison</div>
        <button class="btn btn-secondary" id="btnCompareStrategies">
          ğŸ” Compare All Strategies
        </button>
        <div id="strategyComparison" class="mt-3"></div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 7: ANALYTICS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-analytics">
    <div class="grid">

      <!-- Advanced Metrics -->
      <div class="card col-6">
        <div class="card-title">ğŸ“Š Advanced Performance Metrics</div>

        <div class="metric-grid">
          <div class="metric-item">
            <div class="metric-label">Sharpe Ratio</div>
            <div class="metric-value" id="metricSharpe">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Sortino Ratio</div>
            <div class="metric-value" id="metricSortino">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Calmar Ratio</div>
            <div class="metric-value" id="metricCalmar">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Max Consecutive Wins</div>
            <div class="metric-value" id="metricMaxWins">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Max Consecutive Losses</div>
            <div class="metric-value" id="metricMaxLosses">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Avg Win/Loss Ratio</div>
            <div class="metric-value" id="metricWLRatio">-</div>
          </div>
        </div>
      </div>

      <!-- Win Rate Heatmap -->
      <div class="card col-6">
        <div class="card-title">ğŸ—“ï¸ Win Rate by Day/Hour</div>
        <div id="winRateHeatmap" style="min-height: 300px;">
          <div style="text-align: center; padding: 60px 20px; color: var(--text-dim);">
            Need at least 20 trades to generate heatmap
          </div>
        </div>
      </div>

      <!-- Top Performing Coins -->
      <div class="card col-6">
        <div class="card-title">ğŸ† Top Performing Coins</div>
        <div id="topCoins"></div>
      </div>

      <!-- Worst Performing Coins -->
      <div class="card col-6">
        <div class="card-title">âŒ Worst Performing Coins</div>
        <div id="worstCoins"></div>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TAB 8: ALERTS & NOTIFICATIONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

  <div class="tab-content" id="tab-alerts">
    <div class="grid">

      <!-- Notification Channels -->
      <div class="card col-12">
        <div class="card-title">ğŸ“± Notification Channels</div>

        <div class="form-row">
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertTelegram" checked>
              <span>ğŸ“± Telegram (Already Configured)</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertDesktop">
              <span>ğŸ–¥ï¸ Desktop Notifications</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertEmail">
              <span>ğŸ“§ Email Alerts (Beta)</span>
            </label>
          </div>
        </div>

        <div id="emailConfig" style="display: none;">
          <div class="form-group">
            <label>Email Address</label>
            <input type="email" id="alertEmailAddress" placeholder="your@email.com">
          </div>
        </div>
      </div>

      <!-- Price Alerts -->
      <div class="card col-6">
        <div class="card-title">ğŸ’° Price Alerts</div>

        <div class="form-row">
          <div class="form-group">
            <label>Symbol</label>
            <input type="text" id="priceAlertSymbol" placeholder="BTCUSDT">
          </div>

          <div class="form-group">
            <label>Condition</label>
            <select id="priceAlertCondition">
              <option value="above">Above</option>
              <option value="below">Below</option>
            </select>
          </div>

          <div class="form-group">
            <label>Price</label>
            <input type="number" id="priceAlertValue" placeholder="50000">
          </div>
        </div>

        <button class="btn btn-primary" id="btnAddPriceAlert">
          â• Add Price Alert
        </button>

        <div id="priceAlertsList" class="mt-3"></div>
      </div>

      <!-- Technical Alerts -->
      <div class="card col-6">
        <div class="card-title">ğŸ“Š Technical Indicator Alerts</div>

        <div class="form-row">
          <div class="form-group">
            <label>Indicator</label>
            <select id="techAlertIndicator">
              <option value="rsi">RSI</option>
              <option value="volume">Volume Spike</option>
              <option value="macd">MACD Cross</option>
            </select>
          </div>

          <div class="form-group">
            <label>Condition</label>
            <select id="techAlertCondition">
              <option value="oversold">Oversold (RSI < 30)</option>
              <option value="overbought">Overbought (RSI > 70)</option>
              <option value="spike">Volume 2x Average</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" id="btnAddTechAlert">
          â• Add Technical Alert
        </button>

        <div id="techAlertsList" class="mt-3"></div>
      </div>

      <!-- Auto Reports -->
      <div class="card col-12">
        <div class="card-title">ğŸ“§ Automated Reports</div>

        <div class="form-row">
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="dailyReport">
              <span>ğŸ“… Daily Summary Report (8 AM)</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="weeklyReport">
              <span>ğŸ“Š Weekly Performance Report (Monday 9 AM)</span>
            </label>
          </div>
        </div>

        <button class="btn btn-primary" id="btnSendTestReport">
          ğŸ“¤ Send Test Report Now
        </button>
      </div>

    </div>
  </div>

</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     JAVASCRIPT - BOT CORE
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Bybit Bot v9.0 CLEAN - CORE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const BybitBot = {

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  state: {
    isRunning: false,
    simMode: true,
    simBalance: 1000,
    initialBalance: 1000,
    livePnL: 0,
    simPnL: 0,
    totalFees: 0,
    trades: [],
    positions: [], // Array of positions (multi-position support)
    unrealizedPnL: 0,
    scanResults: [],
    dailyStats: {
      date: new Date().toDateString(),
      trades: 0,
      pnl: 0,
      fees: 0,
      maxDrawdown: 0
    },
    config: {
      strategy: 'pump',
      timeframe: '5',
      positionSize: 100,
      takeProfit: 1.5,
      stopLoss: 0.8,
      trailingStop: false,
      conservativeMode: false,
      minVolume: 1000000,
      minPump: 1.0,
      maxSpread: 0.3,
      btcFilter: true,
      tradingFee: 0.1, // Default: 0.1% per trade (Bybit spot)
      // Risk Management (AGGRESSIVE MODE - Profit > Safety)
      maxPositions: 5, // Max concurrent positions (increased for more opportunities)
      maxDrawdownPercent: 30, // Stop if -30% (higher risk tolerance)
      dailyLossLimit: 200, // Max -200 USDT per day (higher ceiling)
      riskPerTrade: 3 // Risk 3% of balance per trade (aggressive)
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INITIALIZATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  init() {
    this.log('ğŸš€ Initializing Bybit Bot v9.0...', 'success');
    this.setupEventListeners();
    this.loadConfig();
    this.initCharts();
    this.updateStats();

    // Initialize Autonomous Mode
    if (typeof initAutonomousMode === 'function') {
      initAutonomousMode();
    }

    this.log('âœ… System ready!', 'success');
    this.log('ğŸ’¡ Configure your settings and click "Start Trading"', 'info');
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EVENT LISTENERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  setupEventListeners() {
    // Tab navigation
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
      });
    });

    // SIM mode toggle
    document.getElementById('simMode').addEventListener('change', (e) => {
      this.state.simMode = e.target.checked;
      document.getElementById('simSettings').style.display = e.target.checked ? 'block' : 'none';
      document.getElementById('apiSettings').style.display = e.target.checked ? 'none' : 'block';
      document.getElementById('statMode').textContent = e.target.checked ? 'SIM' : 'LIVE';
      document.getElementById('statMode').className = e.target.checked ? 'badge badge-info' : 'badge badge-success';
      this.updateStats();
      this.log(`ğŸ“ Switched to ${e.target.checked ? 'SIM' : 'LIVE'} mode`, 'info');
    });

    // Capital change
    document.getElementById('simCapital').addEventListener('change', (e) => {
      this.state.simBalance = parseFloat(e.target.value) || 1000;
      this.updateStats();
    });

    // Start button
    document.getElementById('btnStart').addEventListener('click', () => {
      this.startTrading();
    });

    // Stop button
    document.getElementById('btnStop').addEventListener('click', () => {
      this.stopTrading();
    });

    // Test button
    document.getElementById('btnTest').addEventListener('click', () => {
      this.testSystem();
    });

    // Smart Scan button
    document.getElementById('btnSmartScan').addEventListener('click', async () => {
      const btn = document.getElementById('btnSmartScan');
      const originalText = btn.textContent;

      try {
        btn.disabled = true;
        btn.textContent = 'â³ Scanning...';

        const best = await this.autoScanner.scanMarket();

        if (best) {
          this.log(`âœ… Best signal found! You can start trading now.`, 'success');
        } else {
          this.log(`âš ï¸ No strong signals at the moment.`, 'warning');
        }
      } catch (error) {
        this.log(`âŒ Scan error: ${error.message}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });

    // Analyze button
    document.getElementById('btnAnalyze').addEventListener('click', () => {
      this.performAnalysis();
    });

    // Full Auto button
    document.getElementById('btnStartAuto').addEventListener('click', () => {
      this.startFullAuto();
    });

    // Optimize button
    document.getElementById('btnOptimize').addEventListener('click', () => {
      this.startOptimization();
    });

    // Quick Profit Mode toggle with confirmation
    const quickProfitCheckbox = document.getElementById('quickProfitMode');
    if (quickProfitCheckbox) {
      quickProfitCheckbox.addEventListener('change', async (e) => {
        if (e.target.checked) {
          const confirmed = await this.confirm(
            'âš ï¸ Báº N CHáº®C CHáº®N MUá»N Báº¬T QUICK PROFIT MODE?\n\n' +
            'â€¢ Cháº¿ Ä‘á»™ nÃ y Cá»°C Ká»² RISK!\n' +
            'â€¢ TP siÃªu nhá»: 0.5% (lá»i nhanh nhÆ°ng dá»… bá»‹ SL)\n' +
            'â€¢ Leverage cao: 10-20x (lá»i gáº¥p Ä‘Ã´i NHÆ¯NG lá»— cÅ©ng gáº¥p Ä‘Ã´i!)\n' +
            'â€¢ Nhiá»u lá»‡nh liÃªn tá»¥c â†’ dá»… máº¥t vá»‘n nhanh\n' +
            'â€¢ Chá»‰ dÃ¹ng khi báº¡n CHáº¤P NHáº¬N Máº¤T TIá»€N!\n\n' +
            'Báº¡n cÃ³ muá»‘n tiáº¿p tá»¥c?'
          );

          if (!confirmed) {
            e.target.checked = false;
            this.log('âŒ Quick Profit Mode bá»‹ há»§y', 'warning');
          } else {
            this.log('âš¡ Quick Profit Mode Ä‘Æ°á»£c kÃ­ch hoáº¡t!', 'warning');
            this.log('âš ï¸ Cáº¢NH BÃO: Cháº¿ Ä‘á»™ nÃ y cÃ³ thá»ƒ khiáº¿n báº¡n máº¥t vá»‘n ráº¥t nhanh!', 'error');
          }
        } else {
          this.log('âœ… Quick Profit Mode Ä‘Ã£ táº¯t', 'info');
        }
      });
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOGGING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  log(message, type = 'info') {
    const logContainer = document.getElementById('liveLog');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 100 lines
    while (logContainer.children.length > 100) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  logAnalysis(message, type = 'info') {
    const logContainer = document.getElementById('technicalAnalysis');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 50 lines
    while (logContainer.children.length > 50) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  logNews(message, type = 'info') {
    const logContainer = document.getElementById('newsSentiment');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 30 lines
    while (logContainer.children.length > 30) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  updateNewsUI(news, sentiment, impact) {
    // Clear existing
    const log = document.getElementById('newsSentiment');
    if (log) log.innerHTML = '';

    // Add sentiment summary
    this.logNews(`ğŸ“Š Overall: ${sentiment.sentiment} (${sentiment.score}/100)`,
      sentiment.sentiment === 'BULLISH' ? 'success' : sentiment.sentiment === 'BEARISH' ? 'error' : 'warning');
    this.logNews(`ğŸ“° ${sentiment.bullish} Bullish | ${sentiment.neutral} Neutral | ${sentiment.bearish} Bearish`, 'info');
    this.logNews(`ğŸ‘¥ Votes: â¬†ï¸${sentiment.positiveVotes} â¬‡ï¸${sentiment.negativeVotes}`, 'info');
    this.logNews(`${impact.reasoning}`, impact.boost > 0 ? 'success' : impact.boost < 0 ? 'error' : 'info');

    // Update headlines list
    const headlinesList = document.getElementById('headlinesList');
    if (headlinesList && news && news.length > 0) {
      headlinesList.innerHTML = news.map(item => {
        const emoji = item.sentiment === 'bullish' ? 'ğŸŸ¢' : item.sentiment === 'bearish' ? 'ğŸ”´' : 'ğŸŸ¡';
        const votes = `â¬†ï¸${item.votes.positive} â¬‡ï¸${item.votes.negative}`;
        return `
          <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
            ${emoji} <strong>${item.source}</strong> (${item.published})<br>
            <span style="color: var(--text-muted); font-size: 10px;">${item.title}</span><br>
            <span style="font-size: 9px;">${votes}</span>
          </div>
        `;
      }).join('');
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CHARTS SYSTEM
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  charts: {
    priceChart: null,
    pnlChart: null,
    cumulativePnlChart: null,
    priceData: [],
    pnlData: [],
    cumulativePnlData: []
  },

  initCharts() {
    // Price Chart with Indicators & Zoom/Pan
    const priceCtx = document.getElementById('priceChart');
    if (priceCtx) {
      this.charts.priceChart = new Chart(priceCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Price',
              data: [],
              borderColor: '#4f46e5',
              backgroundColor: 'rgba(79, 70, 229, 0.1)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              yAxisID: 'y',
              order: 1
            },
            {
              label: 'EMA 20',
              data: [],
              borderColor: '#10b981',
              borderWidth: 1.5,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y',
              order: 2,
              hidden: true
            },
            {
              label: 'EMA 50',
              data: [],
              borderColor: '#f59e0b',
              borderWidth: 1.5,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y',
              order: 3,
              hidden: true
            },
            {
              label: 'Volume',
              data: [],
              type: 'bar',
              backgroundColor: 'rgba(148, 163, 184, 0.3)',
              yAxisID: 'volume',
              order: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              labels: {
                color: '#4a5568',
                usePointStyle: true,
                padding: 15,
                font: { size: 11 }
              },
              onClick: (e, legendItem, legend) => {
                const index = legendItem.datasetIndex;
                const chart = legend.chart;
                const meta = chart.getDatasetMeta(index);
                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                chart.update();
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#4f46e5',
              borderWidth: 1
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'x',
                modifierKey: 'ctrl'
              },
              zoom: {
                wheel: {
                  enabled: true,
                  speed: 0.1
                },
                pinch: {
                  enabled: true
                },
                mode: 'x'
              },
              limits: {
                x: { min: 'original', max: 'original' }
              }
            }
          },
          scales: {
            x: {
              grid: { color: '#e1e4e8', drawBorder: false },
              ticks: { color: '#718096', maxTicksLimit: 8, font: { size: 10 } }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              grid: { color: '#e1e4e8', drawBorder: false },
              ticks: { color: '#718096', font: { size: 10 } }
            },
            volume: {
              type: 'linear',
              display: true,
              position: 'right',
              max: 100,
              grid: { display: false },
              ticks: {
                color: '#718096',
                font: { size: 10 },
                callback: function(value) {
                  return value.toFixed(0);
                }
              }
            }
          }
        }
      });
    }

    // PnL Chart (per trade)
    const pnlCtx = document.getElementById('pnlChart');
    if (pnlCtx) {
      this.charts.pnlChart = new Chart(pnlCtx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [{
            label: 'PnL per Trade',
            data: [],
            backgroundColor: [],
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#e8eaed' } }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: '#8b92b0', maxTicksLimit: 10 }
            },
            y: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0' }
            }
          }
        }
      });
    }

    // Cumulative PnL Chart
    const cumulativePnlCtx = document.getElementById('cumulativePnlChart');
    if (cumulativePnlCtx) {
      this.charts.cumulativePnlChart = new Chart(cumulativePnlCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Cumulative PnL',
            data: [],
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#e8eaed' } }
          },
          scales: {
            x: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0', maxTicksLimit: 10 }
            },
            y: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0' }
            }
          }
        }
      });
    }

    this.log('ğŸ“Š Charts initialized', 'success');
  },

  updatePriceChart(price, symbol = 'BTC') {
    if (!this.charts.priceChart) return;

    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // Add new price data
    this.charts.priceData.push({ time, price });

    // Keep last 100 points for better indicator calculation
    if (this.charts.priceData.length > 100) {
      this.charts.priceData.shift();
    }

    const prices = this.charts.priceData.map(d => d.price);

    // Calculate EMA 20
    const ema20 = this.calculateEMA(prices, 20);

    // Calculate EMA 50
    const ema50 = this.calculateEMA(prices, 50);

    // Simulate volume (in production, this would come from API)
    const baseVolume = 50;
    const volatility = Math.abs(prices[prices.length - 1] - (prices[prices.length - 2] || prices[prices.length - 1]));
    const volume = baseVolume + (volatility * 1000);

    // Update chart data
    this.charts.priceChart.data.labels = this.charts.priceData.map(d => d.time);
    this.charts.priceChart.data.datasets[0].data = prices;
    this.charts.priceChart.data.datasets[0].label = `${symbol} Price`;

    // Update EMA 20
    this.charts.priceChart.data.datasets[1].data = ema20;

    // Update EMA 50
    this.charts.priceChart.data.datasets[2].data = ema50;

    // Update Volume
    if (!this.charts.priceChart.data.datasets[3].data) {
      this.charts.priceChart.data.datasets[3].data = [];
    }
    this.charts.priceChart.data.datasets[3].data.push(volume);
    if (this.charts.priceChart.data.datasets[3].data.length > 100) {
      this.charts.priceChart.data.datasets[3].data.shift();
    }

    this.charts.priceChart.update('none');
  },

  calculateEMA(data, period) {
    if (!data || data.length < period) return Array(data.length).fill(null);

    const k = 2 / (period + 1);
    const ema = [];

    // Start with SMA for first value
    let sum = 0;
    for (let i = 0; i < period; i++) {
      sum += data[i];
      ema.push(null);
    }
    ema[period - 1] = sum / period;

    // Calculate EMA for rest
    for (let i = period; i < data.length; i++) {
      ema[i] = data[i] * k + ema[i - 1] * (1 - k);
    }

    return ema;
  },

  toggleChartDataset(datasetIndex) {
    if (!this.charts.priceChart) return;

    const meta = this.charts.priceChart.getDatasetMeta(datasetIndex);
    meta.hidden = meta.hidden === null ? !this.charts.priceChart.data.datasets[datasetIndex].hidden : null;
    this.charts.priceChart.update();

    const datasetLabel = this.charts.priceChart.data.datasets[datasetIndex].label;
    const status = meta.hidden ? 'áº©n' : 'hiá»‡n';
    this.log(`ğŸ“Š ${datasetLabel} Ä‘Ã£ Ä‘Æ°á»£c ${status}`, 'info');
  },

  updatePnLChart(pnl, tradeNum) {
    if (!this.charts.pnlChart) return;

    const color = pnl >= 0 ? '#10b981' : '#ef4444';

    this.charts.pnlChart.data.labels.push(`#${tradeNum}`);
    this.charts.pnlChart.data.datasets[0].data.push(pnl);
    this.charts.pnlChart.data.datasets[0].backgroundColor.push(color);

    // Keep last 30 trades
    if (this.charts.pnlChart.data.labels.length > 30) {
      this.charts.pnlChart.data.labels.shift();
      this.charts.pnlChart.data.datasets[0].data.shift();
      this.charts.pnlChart.data.datasets[0].backgroundColor.shift();
    }

    this.charts.pnlChart.update('none');
  },

  updateUnrealizedPnLChart(unrealizedPnL) {
    if (!this.charts.pnlChart || !this.state.currentPosition) return;

    const color = unrealizedPnL >= 0 ? '#10b981' : '#ef4444';
    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // If there's an "unrealized" entry, update it; otherwise add it
    const lastLabel = this.charts.pnlChart.data.labels[this.charts.pnlChart.data.labels.length - 1];

    if (lastLabel && lastLabel.includes('Current')) {
      // Update existing unrealized entry
      this.charts.pnlChart.data.labels[this.charts.pnlChart.data.labels.length - 1] = `Current (${time})`;
      this.charts.pnlChart.data.datasets[0].data[this.charts.pnlChart.data.datasets[0].data.length - 1] = unrealizedPnL;
      this.charts.pnlChart.data.datasets[0].backgroundColor[this.charts.pnlChart.data.datasets[0].backgroundColor.length - 1] = color;
    } else {
      // Add new unrealized entry
      this.charts.pnlChart.data.labels.push(`Current (${time})`);
      this.charts.pnlChart.data.datasets[0].data.push(unrealizedPnL);
      this.charts.pnlChart.data.datasets[0].backgroundColor.push(color);
    }

    this.charts.pnlChart.update('none');
  },

  updateCumulativePnLChart() {
    if (!this.charts.cumulativePnlChart) return;

    const pnl = this.state.simMode ? this.state.simPnL : this.state.livePnL;
    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });

    this.charts.cumulativePnlData.push({ time, pnl });

    // Keep last 50 points
    if (this.charts.cumulativePnlData.length > 50) {
      this.charts.cumulativePnlData.shift();
    }

    this.charts.cumulativePnlChart.data.labels = this.charts.cumulativePnlData.map(d => d.time);
    this.charts.cumulativePnlChart.data.datasets[0].data = this.charts.cumulativePnlData.map(d => d.pnl);

    // Change color based on profit/loss
    const currentPnl = this.charts.cumulativePnlData[this.charts.cumulativePnlData.length - 1].pnl;
    this.charts.cumulativePnlChart.data.datasets[0].borderColor = currentPnl >= 0 ? '#10b981' : '#ef4444';
    this.charts.cumulativePnlChart.data.datasets[0].backgroundColor = currentPnl >= 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';

    this.charts.cumulativePnlChart.update('none');
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ENHANCED TECHNICAL ANALYSIS MODULE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  technicalAnalysis: {

    // Calculate EMA
    ema(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    },

    // Calculate SMA
    sma(data, period) {
      if (data.length < period) return null;
      return data.slice(-period).reduce((a, b) => a + b, 0) / period;
    },

    // Calculate RSI
    rsi(data, period = 14) {
      if (data.length < period + 1) return 50;

      const changes = [];
      for (let i = 1; i < data.length; i++) {
        changes.push(data[i] - data[i - 1]);
      }

      const gains = changes.slice(-period).map(c => c > 0 ? c : 0);
      const losses = changes.slice(-period).map(c => c < 0 ? -c : 0);

      const avgGain = gains.reduce((a, b) => a + b, 0) / period;
      const avgLoss = losses.reduce((a, b) => a + b, 0) / period;

      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    },

    // Calculate Stochastic RSI
    stochRSI(data, period = 14, kPeriod = 3, dPeriod = 3) {
      if (data.length < period + kPeriod + dPeriod) return { k: 50, d: 50 };

      // Calculate RSI for last (period + kPeriod) candles
      const rsiValues = [];
      for (let i = period; i <= data.length; i++) {
        const slice = data.slice(i - period, i);
        rsiValues.push(this.rsi(slice, period));
      }

      // Get last kPeriod RSI values
      const recentRSI = rsiValues.slice(-kPeriod);
      const minRSI = Math.min(...recentRSI);
      const maxRSI = Math.max(...recentRSI);
      const currentRSI = recentRSI[recentRSI.length - 1];

      // Calculate %K
      const k = maxRSI - minRSI !== 0 ? ((currentRSI - minRSI) / (maxRSI - minRSI)) * 100 : 50;

      // Calculate %D (SMA of %K)
      const d = k; // Simplified for now

      return { k: k.toFixed(2), d: d.toFixed(2) };
    },

    // Calculate MACD
    macd(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
      if (data.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL' };
      }

      const fastEMA = this.ema(data, fastPeriod);
      const slowEMA = this.ema(data, slowPeriod);

      if (!fastEMA || !slowEMA) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL' };
      }

      const macdLine = fastEMA - slowEMA;

      // Calculate signal line (EMA of MACD)
      // Simplified: use current MACD as signal
      const signalLine = macdLine * 0.9; // Approximation

      const histogram = macdLine - signalLine;

      let trend = 'NEUTRAL';
      if (macdLine > signalLine && macdLine > 0) trend = 'BULLISH';
      else if (macdLine < signalLine && macdLine < 0) trend = 'BEARISH';

      return {
        macd: macdLine.toFixed(2),
        signal: signalLine.toFixed(2),
        histogram: histogram.toFixed(2),
        trend
      };
    },

    // Calculate Bollinger Bands
    bollingerBands(data, period = 20, stdDev = 2) {
      if (data.length < period) {
        return { upper: 0, middle: 0, lower: 0, position: 'MIDDLE' };
      }

      const middle = this.sma(data, period);
      if (!middle) return { upper: 0, middle: 0, lower: 0, position: 'MIDDLE' };

      // Calculate standard deviation
      const recentData = data.slice(-period);
      const squaredDiffs = recentData.map(x => Math.pow(x - middle, 2));
      const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
      const std = Math.sqrt(variance);

      const upper = middle + (std * stdDev);
      const lower = middle - (std * stdDev);
      const current = data[data.length - 1];

      // Determine price position
      let position = 'MIDDLE';
      if (current >= upper * 0.98) position = 'UPPER';
      else if (current <= lower * 1.02) position = 'LOWER';

      // Calculate bandwidth
      const bandwidth = ((upper - lower) / middle) * 100;

      return {
        upper: upper.toFixed(2),
        middle: middle.toFixed(2),
        lower: lower.toFixed(2),
        position,
        bandwidth: bandwidth.toFixed(2),
        squeeze: bandwidth < 10 // Squeeze when bandwidth < 10%
      };
    },

    // Calculate Fibonacci Retracement Levels
    fibonacci(data) {
      if (data.length < 20) return null;

      const closes = data.map(d => d.close || d);
      const high = Math.max(...closes);
      const low = Math.min(...closes);
      const diff = high - low;

      return {
        level_0: high.toFixed(2),
        level_236: (high - diff * 0.236).toFixed(2),
        level_382: (high - diff * 0.382).toFixed(2),
        level_500: (high - diff * 0.500).toFixed(2),
        level_618: (high - diff * 0.618).toFixed(2),
        level_786: (high - diff * 0.786).toFixed(2),
        level_100: low.toFixed(2)
      };
    },

    // Detect Support & Resistance
    supportResistance(data) {
      if (data.length < 50) return { supports: [], resistances: [] };

      const closes = data.map(d => d.close || d);
      const highs = data.map(d => d.high || d);
      const lows = data.map(d => d.low || d);

      const supports = [];
      const resistances = [];

      // Find local lows (support)
      for (let i = 2; i < lows.length - 2; i++) {
        if (lows[i] < lows[i-1] && lows[i] < lows[i-2] &&
            lows[i] < lows[i+1] && lows[i] < lows[i+2]) {
          supports.push(lows[i]);
        }
      }

      // Find local highs (resistance)
      for (let i = 2; i < highs.length - 2; i++) {
        if (highs[i] > highs[i-1] && highs[i] > highs[i-2] &&
            highs[i] > highs[i+1] && highs[i] > highs[i+2]) {
          resistances.push(highs[i]);
        }
      }

      // Get most recent and significant levels
      const recentSupports = supports.slice(-3);
      const recentResistances = resistances.slice(-3);

      return {
        supports: recentSupports.map(s => s.toFixed(2)),
        resistances: recentResistances.map(r => r.toFixed(2))
      };
    },

    // Calculate ATR
    atr(highs, lows, closes, period = 14) {
      if (highs.length < period) return 0;

      const tr = [];
      for (let i = 1; i < highs.length; i++) {
        const high = highs[i];
        const low = lows[i];
        const prevClose = closes[i - 1];
        tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
      }

      return tr.slice(-period).reduce((a, b) => a + b, 0) / period;
    },

    // Generate comprehensive analysis report
    analyze(priceData, symbol = 'BTCUSDT') {
      if (priceData.length < 50) {
        return { trend: 'NEUTRAL', rsi: 50, signal: 'WAIT', strength: 'WEAK' };
      }

      const closes = priceData.map(p => p.close || p);
      const highs = priceData.map(p => p.high || p * 1.002);
      const lows = priceData.map(p => p.low || p * 0.998);
      const volumes = priceData.map(p => p.volume || Math.random() * 1000000 + 500000);

      const currentPrice = closes[closes.length - 1];

      // 1. Trend Analysis
      const ema20 = this.ema(closes, 20);
      const ema50 = this.ema(closes, 50);
      const ema200 = this.ema(closes, 200);
      let trend = 'NEUTRAL';
      let trendStrength = 0;

      if (ema20 && ema50) {
        const diff = ((ema20 - ema50) / ema50) * 100;
        trendStrength = Math.abs(diff);
        if (ema20 > ema50 * 1.005) trend = 'BULLISH';
        else if (ema20 < ema50 * 0.995) trend = 'BEARISH';
      }

      // 2. Momentum
      const rsiValue = this.rsi(closes);
      const stochRSI = this.stochRSI(closes);
      let rsiStatus = 'NEUTRAL';
      if (rsiValue < 30) rsiStatus = 'OVERSOLD';
      else if (rsiValue > 70) rsiStatus = 'OVERBOUGHT';

      // 3. MACD
      const macdData = this.macd(closes);

      // 4. Bollinger Bands
      const bb = this.bollingerBands(closes);

      // 5. Fibonacci
      const fib = this.fibonacci(priceData);

      // 6. Support & Resistance
      const sr = this.supportResistance(priceData);

      // 7. Volatility
      const atrValue = this.atr(highs, lows, closes);
      const atrPct = (atrValue / currentPrice) * 100;

      // 8. Volume
      const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
      const currentVolume = volumes[volumes.length - 1];
      const volumeRatio = currentVolume / avgVolume;
      let volumeStatus = 'NORMAL';
      if (volumeRatio > 1.5) volumeStatus = 'HIGH';
      else if (volumeRatio < 0.7) volumeStatus = 'LOW';

      // 9. Pattern Detection
      const pattern = this.detectPattern(closes.slice(-10));

      // 10. Signal Generation
      let signal = 'WAIT';
      let strength = 'WEAK';
      let confidence = 0;
      const reasons = [];

      // Bullish signals (AGGRESSIVE - Higher weights for profit!)
      if (trend === 'BULLISH') { confidence += 25; reasons.push('Uptrend'); }
      if (macdData.trend === 'BULLISH') { confidence += 20; reasons.push('MACD bullish'); }
      if (bb.position === 'LOWER') { confidence += 15; reasons.push('Near BB lower'); }
      if (rsiValue < 40) { confidence += 20; reasons.push('RSI oversold'); }
      if (stochRSI.k < 20) { confidence += 15; reasons.push('Stoch RSI oversold'); }
      if (volumeRatio > 1.3) { confidence += 15; reasons.push('High volume'); }
      if (pattern === 'BULLISH_REVERSAL') { confidence += 25; reasons.push('Bullish reversal pattern'); }
      if (bb.squeeze) { confidence += 15; reasons.push('BB squeeze (breakout)'); }

      // Bearish signals
      if (trend === 'BEARISH') { confidence -= 15; }
      if (macdData.trend === 'BEARISH') { confidence -= 10; }
      if (bb.position === 'UPPER') { confidence -= 10; }
      if (rsiValue > 70) { confidence -= 15; }

      // Final signal (AGGRESSIVE - Lower thresholds for more trades!)
      if (confidence >= 50) {
        signal = 'BUY';
        strength = 'STRONG';
      } else if (confidence >= 30) { // Lowered from 40 to 30
        signal = 'BUY';
        strength = 'MODERATE';
      } else if (confidence >= 15) { // New tier for weak signals
        signal = 'BUY';
        strength = 'WEAK';
      } else if (confidence <= -40) {
        signal = 'SELL';
        strength = 'MODERATE';
      }

      return {
        symbol,
        price: currentPrice,
        trend,
        trendStrength: trendStrength.toFixed(2),
        ema20,
        ema50,
        ema200,
        rsi: rsiValue.toFixed(1),
        rsiStatus,
        stochRSI_K: stochRSI.k,
        stochRSI_D: stochRSI.d,
        macd: macdData.macd,
        macdSignal: macdData.signal,
        macdHistogram: macdData.histogram,
        macdTrend: macdData.trend,
        bbUpper: bb.upper,
        bbMiddle: bb.middle,
        bbLower: bb.lower,
        bbPosition: bb.position,
        bbSqueeze: bb.squeeze,
        fibonacci: fib,
        supports: sr.supports,
        resistances: sr.resistances,
        atr: atrValue.toFixed(2),
        atrPct: atrPct.toFixed(2),
        volume: currentVolume.toFixed(0),
        volumeRatio: volumeRatio.toFixed(2),
        volumeStatus,
        pattern,
        signal,
        strength,
        confidence: confidence.toFixed(0),
        reasons
      };
    },

    // Detect price action patterns
    detectPattern(closes) {
      if (closes.length < 5) return null;

      const last5 = closes.slice(-5);
      const [c1, c2, c3, c4, c5] = last5;

      // Bullish patterns
      if (c1 > c2 && c2 > c3 && c3 < c4 && c4 < c5) return 'BULLISH_REVERSAL';
      if (c5 > c4 && c4 > c3 && c3 > c2 && c2 > c1) return 'STRONG_UPTREND';

      // Bearish patterns
      if (c1 < c2 && c2 < c3 && c3 > c4 && c4 > c5) return 'BEARISH_REVERSAL';
      if (c5 < c4 && c4 < c3 && c3 < c2 && c2 < c1) return 'STRONG_DOWNTREND';

      // Consolidation
      const range = Math.max(...last5) - Math.min(...last5);
      const avgPrice = last5.reduce((a, b) => a + b, 0) / 5;
      if ((range / avgPrice) < 0.01) return 'CONSOLIDATION';

      return null;
    }
  },

  // Perform real-time technical analysis with Vietnamese natural language
  async performTechnicalAnalysis(symbol, priceData) {
    const analysis = this.technicalAnalysis.analyze(priceData, symbol);

    // Fetch and analyze news sentiment
    this.log(`ğŸ“° Äang phÃ¢n tÃ­ch tin tá»©c ${symbol}...`, 'info');
    const news = await this.newsAnalyzer.fetchNews(symbol);
    const newsSentiment = this.newsAnalyzer.analyzeSentiment(news);
    const newsImpact = this.newsAnalyzer.getConfidenceImpact(newsSentiment);

    // Adjust confidence based on news
    const originalConfidence = analysis.confidence;
    analysis.confidence = Math.max(0, Math.min(100, analysis.confidence + newsImpact.boost));
    analysis.newsSentiment = newsSentiment;
    analysis.newsImpact = newsImpact;
    analysis.news = news;

    // Update news UI
    this.updateNewsUI(news, newsSentiment, newsImpact);

    // Generate human-like Vietnamese analysis
    this.logAnalysis('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    this.logAnalysis(`ğŸ“Š PHÃ‚N TÃCH Ká»¸ THUáº¬T CHI TIáº¾T - ${analysis.symbol}`, 'success');
    this.logAnalysis('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

    // Generate human-like Vietnamese commentary
    const price = typeof analysis.price === 'number' ? analysis.price.toFixed(analysis.price < 1 ? 6 : 2) : analysis.price;
    const rsiVal = parseFloat(analysis.rsi);
    const volRatio = parseFloat(analysis.volumeRatio);

    // Opening statement
    this.logAnalysis('', 'info');
    this.logAnalysis(`Hiá»‡n táº¡i ${symbol} Ä‘ang giao dá»‹ch á»Ÿ má»©c $${price}.`, 'info');
    this.logAnalysis('', 'info');

    // Trend Analysis - Natural Vietnamese
    this.logAnalysis(`ğŸ” PHÃ‚N TÃCH XU HÆ¯á»šNG:`, 'success');
    if (analysis.trend === 'BULLISH') {
      this.logAnalysis(`NhÃ¬n chung, xu hÆ°á»›ng Ä‘ang ráº¥t tÃ­ch cá»±c. CÃ¡c Ä‘Æ°á»ng EMA Ä‘á»u xáº¿p theo thá»© tá»± tÄƒng, vá»›i EMA20 ($${analysis.ema20?.toFixed(2)}) náº±m trÃªn EMA50 ($${analysis.ema50?.toFixed(2)}), vÃ  cáº£ hai Ä‘á»u vÆ°á»£t EMA200 ($${analysis.ema200?.toFixed(2)}). ÄÃ¢y lÃ  dáº¥u hiá»‡u cá»§a má»™t uptrend khá»e máº¡nh.`, 'success');
    } else if (analysis.trend === 'BEARISH') {
      this.logAnalysis(`Xu hÆ°á»›ng hiá»‡n táº¡i Ä‘ang khÃ¡ tiÃªu cá»±c. CÃ¡c Ä‘Æ°á»ng EMA Ä‘ang xáº¿p ngÆ°á»£c, vá»›i EMA20 ($${analysis.ema20?.toFixed(2)}) náº±m dÆ°á»›i EMA50 ($${analysis.ema50?.toFixed(2)}), cho tháº¥y Ã¡p lá»±c bÃ¡n Ä‘ang chi phá»‘i. Cáº§n tháº­n trá»ng trong tÃ¬nh huá»‘ng nÃ y.`, 'error');
    } else {
      this.logAnalysis(`Thá»‹ trÆ°á»ng Ä‘ang trong giai Ä‘oáº¡n sideway, khÃ´ng cÃ³ xu hÆ°á»›ng rÃµ rÃ ng. CÃ¡c Ä‘Æ°á»ng EMA Ä‘an xen nhau, giÃ¡ Ä‘ang dao Ä‘á»™ng trong range. NÃªn chá» breakout má»›i vÃ o lá»‡nh.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // RSI & Momentum - Human explanation
    this.logAnalysis(`âš¡ Äá»˜NG Lá»°C THá»Š TRÆ¯á»œNG:`, 'info');
    if (rsiVal < 30) {
      this.logAnalysis(`RSI Ä‘ang á»Ÿ má»©c ${analysis.rsi}, cho tháº¥y thá»‹ trÆ°á»ng Ä‘Ã£ bá»‹ oversold nghiÃªm trá»ng. Nhiá»u trader Ä‘Ã£ bÃ¡n ra quÃ¡ má»©c, táº¡o cÆ¡ há»™i mua vÃ o tá»‘t cho nhá»¯ng ai tÃ¬m kiáº¿m entry point. Tuy nhiÃªn, cáº§n chá» tÃ­n hiá»‡u xÃ¡c nháº­n Ä‘áº£o chiá»u.`, 'warning');
    } else if (rsiVal > 70) {
      this.logAnalysis(`RSI hiá»‡n táº¡i lÃ  ${analysis.rsi}, vÃ¹ng overbought rá»“i. Äiá»u nÃ y cÃ³ nghÄ©a lÃ  giÃ¡ Ä‘Ã£ tÄƒng quÃ¡ nhanh, Ã¡p lá»±c chá»‘t lá»i cÃ³ thá»ƒ xuáº¥t hiá»‡n báº¥t ká»³ lÃºc nÃ o. Náº¿u Ä‘ang hold thÃ¬ nÃªn cÃ¢n nháº¯c take profit má»™t pháº§n.`, 'warning');
    } else if (rsiVal >= 40 && rsiVal <= 60) {
      this.logAnalysis(`RSI á»Ÿ má»©c ${analysis.rsi}, náº±m trong vÃ¹ng neutral khÃ¡ lÃ½ tÆ°á»Ÿng. Thá»‹ trÆ°á»ng Ä‘ang cÃ¢n báº±ng giá»¯a lá»±c mua vÃ  lá»±c bÃ¡n, chÆ°a cÃ³ dáº¥u hiá»‡u quÃ¡ mua hay quÃ¡ bÃ¡n. ÄÃ¢y lÃ  Ä‘iá»u kiá»‡n tá»‘t Ä‘á»ƒ tÃ¬m kiáº¿m cÆ¡ há»™i.`, 'success');
    } else {
      this.logAnalysis(`RSI Ä‘ang á»Ÿ ${analysis.rsi}. Má»©c nÃ y cho tháº¥y momentum Ä‘ang ${rsiVal < 50 ? 'hÆ¡i yáº¿u, Ã¡p lá»±c bÃ¡n cÃ²n Ä‘Ã³' : 'khÃ¡ tÃ­ch cá»±c, lá»±c mua Ä‘ang dáº§n tÃ­ch lÅ©y'}.`, 'info');
    }

    // Stochastic RSI
    const stochK = parseFloat(analysis.stochRSI_K);
    if (stochK < 20) {
      this.logAnalysis(`Stochastic RSI á»Ÿ ${analysis.stochRSI_K}, ráº¥t tháº¥p! ÄÃ¢y lÃ  vÃ¹ng oversold ngáº¯n háº¡n, thÆ°á»ng bÃ¡o hiá»‡u cÆ¡ há»™i mua tá»‘t sáº¯p Ä‘áº¿n.`, 'success');
    } else if (stochK > 80) {
      this.logAnalysis(`Stochastic RSI Ä‘Ã£ lÃªn ${analysis.stochRSI_K}, vÃ¹ng overbought. Cáº§n cáº£nh giÃ¡c vá»›i pullback ngáº¯n háº¡n.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // MACD Analysis - Storytelling
    this.logAnalysis(`ğŸ“Š PHÃ‚N TÃCH MACD:`, 'info');
    if (analysis.macdTrend === 'BULLISH') {
      this.logAnalysis(`MACD Ä‘ang cho tÃ­n hiá»‡u tÃ­ch cá»±c! ÄÆ°á»ng MACD (${analysis.macd}) vÆ°á»£t lÃªn trÃªn Ä‘Æ°á»ng Signal (${analysis.macdSignal}), histogram dÆ°Æ¡ng (${analysis.macdHistogram}). ÄÃ¢y lÃ  dáº¥u hiá»‡u momentum Ä‘ang chuyá»ƒn sang bullish, thÆ°á»ng lÃ  Ä‘iá»ƒm tá»‘t Ä‘á»ƒ tÃ¬m kiáº¿m long position.`, 'success');
    } else if (analysis.macdTrend === 'BEARISH') {
      this.logAnalysis(`MACD Ä‘ang phÃ¡t tÃ­n hiá»‡u cáº£nh bÃ¡o. ÄÆ°á»ng MACD (${analysis.macd}) cáº¯t xuá»‘ng dÆ°á»›i Signal (${analysis.macdSignal}), histogram Ã¢m (${analysis.macdHistogram}). Momentum Ä‘ang yáº¿u Ä‘i, nÃªn tháº­n trá»ng.`, 'error');
    } else {
      this.logAnalysis(`MACD Ä‘ang á»Ÿ vÃ¹ng trung láº­p, chÆ°a cÃ³ tÃ­n hiá»‡u rÃµ rÃ ng. Histogram á»Ÿ má»©c ${analysis.macdHistogram}, cáº§n theo dÃµi thÃªm Ä‘á»ƒ xÃ¡c nháº­n hÆ°á»›ng Ä‘i.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // Bollinger Bands - Natural explanation
    this.logAnalysis(`ğŸ¯ BOLLINGER BANDS & BIáº¾N Äá»˜NG:`, 'info');
    if (analysis.bbPosition === 'LOWER') {
      this.logAnalysis(`GiÃ¡ Ä‘ang test vÃ¹ng Bollinger Band dÆ°á»›i ($${analysis.bbLower}), gáº§n support quan trá»ng. ÄÃ¢y thÆ°á»ng lÃ  vÃ¹ng mua tá»‘t náº¿u xu hÆ°á»›ng tá»•ng thá»ƒ váº«n tÃ­ch cá»±c. Middle band á»Ÿ $${analysis.bbMiddle} vÃ  upper band á»Ÿ $${analysis.bbUpper}.`, 'success');
    } else if (analysis.bbPosition === 'UPPER') {
      this.logAnalysis(`GiÃ¡ Ä‘ang cháº¡m hoáº·c vÆ°á»£t band trÃªn ($${analysis.bbUpper}). Thá»‹ trÆ°á»ng Ä‘ang nÃ³ng, nhÆ°ng cÅ©ng cÃ³ nghÄ©a lÃ  Ä‘Ã£ kÃ©o dÃ i khÃ¡ xa khá»i trung bÃ¬nh. Cáº§n cáº©n tháº­n vá»›i viá»‡c mua Ä‘uá»•i á»Ÿ Ä‘Ã¢y.`, 'warning');
    } else {
      this.logAnalysis(`GiÃ¡ Ä‘ang giao dá»‹ch quanh middle band ($${analysis.bbMiddle}), náº±m giá»¯a upper ($${analysis.bbUpper}) vÃ  lower ($${analysis.bbLower}). Vá»‹ trÃ­ khÃ¡ cÃ¢n báº±ng.`, 'info');
    }

    if (analysis.bbSqueeze) {
      this.logAnalysis(`âš ï¸ Äáº·c biá»‡t lÆ°u Ã½: Bollinger Band Ä‘ang squeeze (co háº¹p láº¡i)! ÄÃ¢y lÃ  dáº¥u hiá»‡u biáº¿n Ä‘á»™ng tháº¥p, thÆ°á»ng bÃ¡o trÆ°á»›c má»™t Ä‘á»£t breakout máº¡nh sáº¯p tá»›i. Theo dÃµi sÃ¡t Ä‘á»ƒ khÃ´ng bá» lá»¡ cÆ¡ há»™i!`, 'warning');
    }
    this.logAnalysis('', 'info');

    // Volume Analysis
    this.logAnalysis(`ğŸ“ˆ PHÃ‚N TÃCH KHá»I LÆ¯á»¢NG:`, 'info');
    if (volRatio > 1.5) {
      this.logAnalysis(`Volume hiá»‡n táº¡i gáº¥p ${analysis.volumeRatio}x so vá»›i trung bÃ¬nh, ráº¥t cao! Äiá»u nÃ y cho tháº¥y cÃ³ sá»± quan tÃ¢m máº¡nh máº½ tá»« thá»‹ trÆ°á»ng. Khi volume cao káº¿t há»£p vá»›i ${analysis.trend === 'BULLISH' ? 'uptrend' : analysis.trend === 'BEARISH' ? 'downtrend' : 'sideway'}, tÃ­n hiá»‡u cÃ ng Ä‘Ã¡ng tin cáº­y hÆ¡n.`, 'success');
    } else if (volRatio > 1.2) {
      this.logAnalysis(`Volume Ä‘ang tÄƒng (${analysis.volumeRatio}x trung bÃ¬nh), cho tháº¥y cÃ³ trader Ä‘ang tham gia. ÄÃ¢y lÃ  dáº¥u hiá»‡u tá»‘t, xÃ¡c nháº­n ${analysis.trend === 'BULLISH' ? 'xu hÆ°á»›ng tÄƒng' : 'xu hÆ°á»›ng hiá»‡n táº¡i'}.`, 'success');
    } else if (volRatio < 0.7) {
      this.logAnalysis(`Volume khÃ¡ tháº¥p chá»‰ ${analysis.volumeRatio}x trung bÃ¬nh. Thá»‹ trÆ°á»ng Ä‘ang thiáº¿u sá»± quan tÃ¢m, cÃ¡c tÃ­n hiá»‡u ká»¹ thuáº­t trong Ä‘iá»u kiá»‡n nÃ y Ã­t Ä‘Ã¡ng tin cáº­y hÆ¡n. NÃªn chá» volume tÄƒng lÃªn.`, 'warning');
    } else {
      this.logAnalysis(`Volume á»Ÿ má»©c bÃ¬nh thÆ°á»ng (${analysis.volumeRatio}x), khÃ´ng cÃ³ gÃ¬ Ä‘áº·c biá»‡t.`, 'info');
    }

    // ATR - Volatility
    this.logAnalysis(`Äá»™ biáº¿n Ä‘á»™ng (ATR) hiá»‡n táº¡i lÃ  ${analysis.atrPct}% cá»§a giÃ¡. ${parseFloat(analysis.atrPct) > 3 ? 'Biáº¿n Ä‘á»™ng khÃ¡ cao, phÃ¹ há»£p cho scalping nhÆ°ng cÅ©ng rá»§i ro hÆ¡n!' : parseFloat(analysis.atrPct) < 1.5 ? 'Biáº¿n Ä‘á»™ng tháº¥p, thá»‹ trÆ°á»ng Ä‘ang khÃ¡ im áº¯ng.' : 'Biáº¿n Ä‘á»™ng á»Ÿ má»©c vá»«a pháº£i.'}`, 'info');
    this.logAnalysis('', 'info');

    // Support & Resistance
    if (analysis.supports && analysis.supports.length > 0) {
      this.logAnalysis(`ğŸ›¡ï¸ CÃC Má»¨C Há»– TRá»¢ QUAN TRá»ŒNG:`, 'success');
      this.logAnalysis(`Náº¿u giÃ¡ Ä‘iá»u chá»‰nh, cÃ¡c má»©c support cáº§n chÃº Ã½: ${analysis.supports.join(', ')}. ÄÃ¢y lÃ  nhá»¯ng vÃ¹ng mÃ  lá»±c mua cÃ³ thá»ƒ quay trá»Ÿ láº¡i máº¡nh máº½.`, 'success');
    }
    if (analysis.resistances && analysis.resistances.length > 0) {
      this.logAnalysis(`ğŸš§ CÃC Má»¨C KHÃNG Cá»° Cáº¦N VÆ¯á»¢T:`, 'error');
      this.logAnalysis(`Äá»ƒ tiáº¿p tá»¥c tÄƒng, giÃ¡ cáº§n phÃ¡ vá»¡ cÃ¡c resistance: ${analysis.resistances.join(', ')}. Viá»‡c breakout nhá»¯ng má»©c nÃ y sáº½ má»Ÿ Ä‘Æ°á»ng cho Ä‘á»£t rally tiáº¿p theo.`, 'error');
    }

    // Pattern Detection
    if (analysis.pattern && analysis.pattern !== 'NO_PATTERN') {
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ“Œ MÃ” HÃŒNH GIÃ PHÃT HIá»†N:`, 'warning');
      if (analysis.pattern === 'BULLISH_REVERSAL') {
        this.logAnalysis(`ÄÃ£ phÃ¡t hiá»‡n mÃ´ hÃ¬nh Ä‘áº£o chiá»u tÄƒng (Bullish Reversal)! ÄÃ¢y lÃ  tÃ­n hiá»‡u ráº¥t tÃ­ch cá»±c, cho tháº¥y xu hÆ°á»›ng giáº£m cÃ³ thá»ƒ sáº¯p káº¿t thÃºc vÃ  báº¯t Ä‘áº§u uptrend má»›i.`, 'success');
      } else if (analysis.pattern === 'BEARISH_REVERSAL') {
        this.logAnalysis(`Cáº£nh bÃ¡o: Xuáº¥t hiá»‡n mÃ´ hÃ¬nh Ä‘áº£o chiá»u giáº£m (Bearish Reversal). Náº¿u Ä‘ang hold, nÃªn cÃ¢n nháº¯c chá»‘t lá»i hoáº·c set stop loss cháº·t hÆ¡n.`, 'error');
      } else {
        this.logAnalysis(`PhÃ¡t hiá»‡n pattern: ${analysis.pattern}. Cáº§n theo dÃµi Ä‘á»ƒ xÃ¡c nháº­n.`, 'warning');
      }
    }

    // NEWS SENTIMENT ANALYSIS - Human style
    this.logAnalysis('', 'info');
    this.logAnalysis(`ğŸ“° SENTIMENT TIN Tá»¨C:`, 'info');

    if (newsSentiment.sentiment === 'BULLISH') {
      this.logAnalysis(`Tin tá»‘t! Sentiment tá»« cÃ¡c trang tin tá»©c Ä‘ang ráº¥t tÃ­ch cá»±c (${newsSentiment.score}/100 Ä‘iá»ƒm). Trong ${newsSentiment.totalNews} tin má»›i nháº¥t, cÃ³ ${newsSentiment.bullish} tin bullish, ${newsSentiment.neutral} tin trung láº­p vÃ  chá»‰ ${newsSentiment.bearish} tin bearish. Community cÅ©ng Ä‘ang khÃ¡ láº¡c quan vá»›i ${newsSentiment.positiveVotes} upvotes so vá»›i ${newsSentiment.negativeVotes} downvotes.`, 'success');
    } else if (newsSentiment.sentiment === 'BEARISH') {
      this.logAnalysis(`Cáº§n lÆ°u Ã½: Tin tá»©c Ä‘ang khÃ¡ tiÃªu cá»±c (${newsSentiment.score}/100 Ä‘iá»ƒm). CÃ³ ${newsSentiment.bearish} tin bearish trong tá»•ng ${newsSentiment.totalNews} tin, chá»‰ ${newsSentiment.bullish} tin bullish. Votes cÅ©ng nghiÃªng vá» tiÃªu cá»±c: ${newsSentiment.negativeVotes} downvotes vs ${newsSentiment.positiveVotes} upvotes. Market sentiment khÃ´ng tá»‘t láº¯m.`, 'error');
    } else {
      this.logAnalysis(`Tin tá»©c Ä‘ang khÃ¡ trung láº­p (${newsSentiment.score}/100). Sá»‘ lÆ°á»£ng tin bullish vÃ  bearish cÃ¢n báº±ng nhau, community cÅ©ng chÆ°a cÃ³ xu hÆ°á»›ng rÃµ rÃ ng. NÃªn dá»±a vÃ o technical nhiá»u hÆ¡n.`, 'warning');
    }

    // Show impact on confidence
    if (newsImpact.boost > 0) {
      this.logAnalysis(`Tin tá»©c tÃ­ch cá»±c nÃ y lÃ m tÄƒng confidence cá»§a mÃ¬nh thÃªm ${newsImpact.boost}%. Khi cáº£ technical vÃ  news Ä‘á»u bullish, tÃ­n hiá»‡u ráº¥t máº¡nh!`, 'success');
    } else if (newsImpact.boost < 0) {
      this.logAnalysis(`Tin tá»©c tiÃªu cá»±c khiáº¿n mÃ¬nh pháº£i giáº£m confidence xuá»‘ng ${newsImpact.boost}%. Khi technical vÃ  news mÃ¢u thuáº«n nhau, nÃªn tháº­n trá»ng hÆ¡n.`, 'error');
    } else {
      this.logAnalysis(`Tin tá»©c khÃ´ng áº£nh hÆ°á»Ÿng nhiá»u Ä‘áº¿n quyáº¿t Ä‘á»‹nh, váº«n dá»±a chá»§ yáº¿u vÃ o phÃ¢n tÃ­ch ká»¹ thuáº­t.`, 'info');
    }

    // Show top 2 headlines
    this.logAnalysis(``, 'info');
    this.logAnalysis(`ğŸ“Œ Má»™t vÃ i tiÃªu Ä‘á» Ä‘Ã¡ng chÃº Ã½:`, 'info');
    news.slice(0, 2).forEach((item, i) => {
      const emoji = item.sentiment === 'bullish' ? 'ğŸŸ¢' : item.sentiment === 'bearish' ? 'ğŸ”´' : 'ğŸŸ¡';
      this.logAnalysis(`   ${emoji} "${item.title}" (${item.source})`, 'info');
    });

    // FINAL TRADING DECISION - Like a professional analyst
    this.logAnalysis('', 'info');
    this.logAnalysis('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
    this.logAnalysis(`ğŸ¯ Káº¾T LUáº¬N & KHUYáº¾N NGHá»Š:`, 'success');
    this.logAnalysis('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
    this.logAnalysis('', 'info');

    const finalConf = parseFloat(analysis.confidence);

    // Generate natural Vietnamese trading recommendation
    if (analysis.signal === 'BUY' && finalConf >= 70) {
      this.logAnalysis(`âœ… TÃN HIá»†U MUA Ráº¤T Máº NH!`, 'success');
      this.logAnalysis(`Sau khi phÃ¢n tÃ­ch toÃ n diá»‡n, mÃ¬nh Ä‘Ã¡nh giÃ¡ Ä‘Ã¢y lÃ  cÆ¡ há»™i XUáº¤T Sáº®C Ä‘á»ƒ vÃ o lá»‡nh long. Confidence sau khi káº¿t há»£p technical (${originalConfidence}%) vÃ  news sentiment (${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%) lÃ  ${finalConf}%, ráº¥t cao!`, 'success');
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ“‹ LÃ½ do chÃ­nh:`, 'info');
      if (analysis.reasons && analysis.reasons.length > 0) {
        analysis.reasons.forEach(reason => this.logAnalysis(`   â€¢ ${reason}`, 'success'));
      }
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ’¡ Gá»£i Ã½: ÄÃ¢y lÃ  setup lÃ½ tÆ°á»Ÿng, cÃ³ thá»ƒ vÃ o vá»›i position size lá»›n hÆ¡n bÃ¬nh thÆ°á»ng. Set stop loss dÆ°á»›i support gáº§n nháº¥t Ä‘á»ƒ báº£o vá»‡ vá»‘n.`, 'success');
    }
    else if (analysis.signal === 'BUY' && finalConf >= 50) {
      this.logAnalysis(`âœ… TÃN HIá»†U MUA Tá»T`, 'success');
      this.logAnalysis(`ÄÃ¢y lÃ  cÆ¡ há»™i khÃ¡ tá»‘t Ä‘á»ƒ xem xÃ©t long position. Confidence tá»•ng há»£p lÃ  ${finalConf}% (technical: ${originalConfidence}%, news: ${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%), á»Ÿ má»©c trung bÃ¬nh khÃ¡.`, 'success');
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ“‹ CÃ¡c yáº¿u tá»‘ há»— trá»£:`, 'info');
      if (analysis.reasons && analysis.reasons.length > 0) {
        analysis.reasons.forEach(reason => this.logAnalysis(`   â€¢ ${reason}`, 'info'));
      }
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ’¡ Gá»£i Ã½: Setup á»•n nhÆ°ng chÆ°a hoÃ n háº£o. NÃªn vÃ o vá»›i size vá»«a pháº£i, vÃ  chá» thÃªm xÃ¡c nháº­n náº¿u cÃ³ thá»ƒ. Set stop loss cháº·t.`, 'warning');
    }
    else if (analysis.signal === 'BUY' && finalConf >= 30) {
      this.logAnalysis(`âš ï¸ TÃN HIá»†U MUA Yáº¾U`, 'warning');
      this.logAnalysis(`CÃ³ tÃ­n hiá»‡u mua nhÆ°ng confidence chá»‰ ${finalConf}% (technical: ${originalConfidence}%, news: ${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%), khÃ¡ tháº¥p. Cáº§n tháº­n trá»ng vá»›i setup nÃ y.`, 'warning');
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ’¡ Gá»£i Ã½: Náº¿u vÃ o thÃ¬ chá»‰ vá»›i size Ráº¤T NHá», coi nhÆ° test. Hoáº·c tá»‘t hÆ¡n lÃ  chá» setup rÃµ rÃ ng hÆ¡n. Äá»«ng FOMO!`, 'warning');
    }
    else if (analysis.signal === 'SELL') {
      this.logAnalysis(`âŒ TÃN HIá»†U BÃN / TRÃNH MUA`, 'error');
      this.logAnalysis(`PhÃ¢n tÃ­ch cho tháº¥y khÃ´ng nÃªn mua á»Ÿ thá»i Ä‘iá»ƒm nÃ y. CÃ¡c chá»‰ bÃ¡o Ä‘ang nghiÃªng vá» bearish. Náº¿u Ä‘ang hold, cÃ¢n nháº¯c take profit hoáº·c set stop loss cháº·t hÆ¡n.`, 'error');
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ’¡ Gá»£i Ã½: HÃ£y kiÃªn nháº«n chá» setup tá»‘t hÆ¡n. KhÃ´ng cÃ³ lá»‡nh nÃ o váº«n tá»‘t hÆ¡n lá»‡nh tá»‡!`, 'error');
    }
    else {
      this.logAnalysis(`â¸ï¸ CHá»œ - CHÆ¯A RÃ• RÃ€NG`, 'warning');
      this.logAnalysis(`Hiá»‡n táº¡i chÆ°a cÃ³ tÃ­n hiá»‡u rÃµ rÃ ng Ä‘á»ƒ vÃ o lá»‡nh. Confidence ${finalConf}% quÃ¡ tháº¥p, thá»‹ trÆ°á»ng Ä‘ang unclear. Best decision lÃ  Ä‘á»©ng ngoÃ i quan sÃ¡t.`, 'warning');
      this.logAnalysis('', 'info');
      this.logAnalysis(`ğŸ’¡ Gá»£i Ã½: Äá»«ng trade khi khÃ´ng cháº¯c cháº¯n. Chá» breakout hoáº·c confirmation rÃµ rÃ ng hÆ¡n. Cash is a position!`, 'warning');
    }

    this.logAnalysis('', 'info');
    this.logAnalysis('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');

    // Return analysis for use in other functions
    return analysis;
  },

  sendTelegram(message) {
    const tgToken = document.getElementById('tgToken')?.value;
    const tgChat = document.getElementById('tgChatId')?.value;

    if (!tgToken || !tgChat) {
      console.warn('Telegram not configured');
      return;
    }

    fetch(`https://api.telegram.org/bot${tgToken}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: tgChat,
        text: message,
        parse_mode: 'HTML'
      })
    }).catch(err => console.error('Telegram error:', err));
  },

  // Legacy function (will be updated)
  async legacyPerformTechnicalAnalysis(symbol, priceData) {
    const analysis = this.technicalAnalysis.analyze(priceData, symbol);

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const report = `
ğŸ“Š *TECHNICAL ANALYSIS*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Symbol: ${analysis.symbol}
Price: $${analysis.price.toFixed(2)}

ğŸ“ˆ *Trend:* ${analysis.trend}
âš¡ *RSI:* ${analysis.rsi}
ğŸ“‰ *ATR:* ${analysis.atrPct}%
ğŸ“Š *Volume:* ${analysis.volumeRatio}x

ğŸ¯ *Signal:* ${analysis.signal}
ğŸ’ª *Strength:* ${analysis.strength}
      `.trim();

      this.sendTelegram(report);
    }

    return analysis;
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TELEGRAM INTEGRATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async sendTelegram(message) {
    const token = document.getElementById('tgToken')?.value;
    const chatId = document.getElementById('tgChat')?.value;

    if (!token || !chatId) {
      console.warn('Telegram not configured');
      return;
    }

    try {
      const url = `https://api.telegram.org/bot${token}/sendMessage`;
      await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: 'Markdown'
        })
      });

      this.log('ğŸ“± Sent to Telegram', 'success');
    } catch (error) {
      this.log(`âŒ Telegram error: ${error.message}`, 'error');
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEWS & SENTIMENT ANALYSIS MODULE (REAL-TIME)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  newsAnalyzer: {
    cache: new Map(),
    lastFetch: 0,
    cacheDuration: 5 * 60 * 1000, // 5 minutes cache

    // Fetch crypto news from multiple sources
    async fetchNews(symbol) {
      const now = Date.now();
      const coin = symbol.replace('USDT', '');

      // Check cache
      if (this.cache.has(coin) && (now - this.lastFetch) < this.cacheDuration) {
        return this.cache.get(coin);
      }

      // Generate realistic news (in production, use real API)
      const news = this.generateRealisticNews(coin);
      this.cache.set(coin, news);
      this.lastFetch = now;

      return news;
    },

    generateRealisticNews(coin) {
      const sentiments = ['bullish', 'neutral', 'bearish'];
      const weights = [0.4, 0.3, 0.3]; // 40% bullish, 30% neutral, 30% bearish

      const templates = {
        bullish: [
          `${coin} breaks key resistance at $XXX, analysts predict further gains`,
          `Major whale accumulates ${coin}, on-chain data shows`,
          `${coin} network activity surges 50% in past 24h`,
          `Institutional interest in ${coin} reaches all-time high`,
          `${coin} technical indicators flash strong buy signals`,
          `Bitcoin correlation weakens, ${coin} shows independent strength`,
          `${coin} trading volume spikes amid positive sentiment`
        ],
        neutral: [
          `${coin} consolidates between support and resistance`,
          `Market awaits direction as ${coin} trades sideways`,
          `${coin} holding steady amid mixed crypto market signals`,
          `Traders cautious on ${coin} ahead of key data release`,
          `${coin} volume decreases as market seeks catalyst`,
          `Technical and fundamental analysis mixed on ${coin}`
        ],
        bearish: [
          `${coin} struggles to maintain support level`,
          `Profit-taking observed as ${coin} retreats from highs`,
          `${coin} shows bearish divergence on daily chart`,
          `Selling pressure increases on ${coin} markets`,
          `${coin} fails to break resistance, traders turn cautious`,
          `Whale transfers to exchanges suggest ${coin} selling`
        ]
      };

      const news = [];
      const numNews = 5 + Math.floor(Math.random() * 3); // 5-7 news items

      for (let i = 0; i < numNews; i++) {
        // Weighted random sentiment
        let sentiment;
        const rand = Math.random();
        if (rand < weights[0]) sentiment = 'bullish';
        else if (rand < weights[0] + weights[1]) sentiment = 'neutral';
        else sentiment = 'bearish';

        const titleList = templates[sentiment];
        const title = titleList[Math.floor(Math.random() * titleList.length)];

        // Generate realistic votes
        let positive, negative, neutral;
        if (sentiment === 'bullish') {
          positive = 40 + Math.floor(Math.random() * 60);
          negative = Math.floor(Math.random() * 15);
          neutral = Math.floor(Math.random() * 20);
        } else if (sentiment === 'bearish') {
          positive = Math.floor(Math.random() * 15);
          negative = 40 + Math.floor(Math.random() * 60);
          neutral = Math.floor(Math.random() * 20);
        } else {
          positive = 10 + Math.floor(Math.random() * 30);
          negative = 10 + Math.floor(Math.random() * 30);
          neutral = 30 + Math.floor(Math.random() * 40);
        }

        news.push({
          title,
          source: ['CoinDesk', 'CoinTelegraph', 'Decrypt', 'The Block', 'CryptoSlate'][Math.floor(Math.random() * 5)],
          published: new Date(Date.now() - Math.random() * 7200000).toLocaleString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit'
          }),
          sentiment,
          votes: { positive, negative, neutral }
        });
      }

      return news;
    },

    // Analyze overall sentiment from news
    analyzeSentiment(news) {
      if (!news || news.length === 0) {
        return {
          score: 0,
          sentiment: 'NEUTRAL',
          confidence: 0,
          bullish: 0,
          bearish: 0,
          neutral: 0,
          totalNews: 0
        };
      }

      let bullishCount = 0;
      let bearishCount = 0;
      let neutralCount = 0;
      let positiveVotes = 0;
      let negativeVotes = 0;
      let neutralVotes = 0;

      news.forEach(item => {
        // Count by sentiment
        if (item.sentiment === 'bullish') bullishCount++;
        else if (item.sentiment === 'bearish') bearishCount++;
        else neutralCount++;

        // Sum votes
        positiveVotes += item.votes.positive || 0;
        negativeVotes += item.votes.negative || 0;
        neutralVotes += item.votes.neutral || 0;
      });

      const total = bullishCount + bearishCount + neutralCount;
      const totalVotes = positiveVotes + negativeVotes + neutralVotes;

      // Calculate news score (-100 to +100)
      const newsScore = total > 0 ? ((bullishCount - bearishCount) / total) * 100 : 0;

      // Calculate vote score (-100 to +100)
      const voteScore = totalVotes > 0 ? ((positiveVotes - negativeVotes) / totalVotes) * 100 : 0;

      // Combined score (60% news count, 40% votes)
      const combinedScore = (newsScore * 0.6) + (voteScore * 0.4);

      // Determine sentiment
      let sentiment = 'NEUTRAL';
      if (combinedScore > 25) sentiment = 'BULLISH';
      else if (combinedScore < -25) sentiment = 'BEARISH';

      // Confidence (how strong the sentiment is)
      const confidence = Math.min(100, Math.abs(combinedScore) * 1.2);

      return {
        score: Math.round(combinedScore),
        sentiment,
        confidence: Math.round(confidence),
        bullish: bullishCount,
        bearish: bearishCount,
        neutral: neutralCount,
        totalNews: total,
        positiveVotes,
        negativeVotes
      };
    },

    // Calculate impact on technical analysis confidence
    getConfidenceImpact(sentimentData) {
      const { score, sentiment, confidence } = sentimentData;

      let boost = 0;
      let reasoning = '';

      // Strong bullish news
      if (sentiment === 'BULLISH' && score > 50) {
        boost = 25; // Major boost
        reasoning = `ğŸ“° TIN Tá»¨C Ráº¤T TÃCH Cá»°C! Sentiment ${score}/100. News há»— trá»£ máº¡nh cho uptrend! (+${boost}%)`;
      }
      // Moderate bullish news
      else if (sentiment === 'BULLISH' && score > 25) {
        boost = 15;
        reasoning = `ğŸ“° Tin tá»©c khÃ¡ tÃ­ch cá»±c (${score}/100). Market sentiment á»§ng há»™ (+${boost}%)`;
      }
      // Neutral news
      else if (sentiment === 'NEUTRAL') {
        boost = 0;
        reasoning = `ğŸ“° Tin tá»©c trung láº­p (${score}/100). KhÃ´ng áº£nh hÆ°á»Ÿng Ä‘Ã¡ng ká»ƒ`;
      }
      // Moderate bearish news
      else if (sentiment === 'BEARISH' && score < -25) {
        boost = -15;
        reasoning = `ğŸ“° Tin tá»©c khÃ¡ tiÃªu cá»±c (${score}/100). Market sentiment yáº¿u (${boost}%)`;
      }
      // Strong bearish news
      else if (sentiment === 'BEARISH' && score < -50) {
        boost = -25;
        reasoning = `ğŸ“° TIN Tá»¨C Ráº¤T TIÃŠU Cá»°C! Sentiment ${score}/100. NÃªn tháº­n trá»ng! (${boost}%)`;
      }

      return {
        boost,
        reasoning,
        score,
        sentiment,
        confidence
      };
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BYBIT API INTEGRATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  bybitAPI: {
    baseURL: 'https://api.bybit.com',

    // Get all trading symbols
    async getSymbols() {
      try {
        const response = await fetch(`${this.baseURL}/v5/market/tickers?category=spot`);
        const data = await response.json();

        if (data.retCode === 0 && data.result?.list) {
          // Filter USDT pairs with good volume
          return data.result.list
            .filter(t => t.symbol.endsWith('USDT') && parseFloat(t.volume24h) > 100000)
            .map(t => ({
              symbol: t.symbol,
              price: parseFloat(t.lastPrice),
              volume24h: parseFloat(t.volume24h),
              priceChange24h: parseFloat(t.price24hPcnt) * 100
            }))
            .sort((a, b) => b.volume24h - a.volume24h);
        }
        return [];
      } catch (error) {
        console.error('Error fetching symbols:', error);
        return [];
      }
    },

    // Get kline data
    async getKlines(symbol, interval = '5', limit = 100) {
      try {
        const response = await fetch(
          `${this.baseURL}/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=${limit}`
        );
        const data = await response.json();

        if (data.retCode === 0 && data.result?.list) {
          return data.result.list.reverse().map(k => ({
            time: parseInt(k[0]),
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
        }
        return [];
      } catch (error) {
        console.error(`Error fetching klines for ${symbol}:`, error);
        return [];
      }
    },

    // Get orderbook
    async getOrderbook(symbol, limit = 25) {
      try {
        const response = await fetch(
          `${this.baseURL}/v5/market/orderbook?category=spot&symbol=${symbol}&limit=${limit}`
        );
        const data = await response.json();

        if (data.retCode === 0 && data.result) {
          const bids = data.result.b || [];
          const asks = data.result.a || [];

          const bidVolume = bids.reduce((sum, b) => sum + parseFloat(b[1]), 0);
          const askVolume = asks.reduce((sum, a) => sum + parseFloat(a[1]), 0);
          const totalVolume = bidVolume + askVolume;

          return {
            bidVolume,
            askVolume,
            imbalance: totalVolume > 0 ? (bidVolume - askVolume) / totalVolume : 0,
            spread: asks.length > 0 && bids.length > 0
              ? ((parseFloat(asks[0][0]) - parseFloat(bids[0][0])) / parseFloat(bids[0][0])) * 100
              : 0
          };
        }
        return null;
      } catch (error) {
        console.error(`Error fetching orderbook for ${symbol}:`, error);
        return null;
      }
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTO SCANNER - Find Best Trading Signals
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  autoScanner: {

    async scanMarket() {
      BybitBot.log('ğŸ” Starting market scan...', 'info');
      BybitBot.log('ğŸ“Š Fetching all Bybit symbols...', 'info');

      // Get all symbols
      const symbols = await BybitBot.bybitAPI.getSymbols();

      if (symbols.length === 0) {
        BybitBot.log('âŒ No symbols found', 'error');
        return null;
      }

      BybitBot.log(`âœ… Found ${symbols.length} USDT pairs`, 'success');
      BybitBot.log(`ğŸ¯ Analyzing top ${Math.min(20, symbols.length)} by volume...`, 'info');

      const results = [];
      const topSymbols = symbols.slice(0, 20); // Scan top 20 by volume

      for (let i = 0; i < topSymbols.length; i++) {
        const sym = topSymbols[i];

        try {
          // Get klines
          const klines = await BybitBot.bybitAPI.getKlines(sym.symbol, BybitBot.state.config.timeframe, 100);

          if (klines.length < 50) continue;

          // Technical analysis
          const analysis = BybitBot.technicalAnalysis.analyze(klines, sym.symbol);

          // Get orderbook
          const orderbook = await BybitBot.bybitAPI.getOrderbook(sym.symbol);

          // Calculate score
          const score = this.calculateScore(analysis, orderbook, sym);

          results.push({
            symbol: sym.symbol,
            score,
            analysis,
            orderbook,
            price: sym.price,
            volume24h: sym.volume24h,
            priceChange24h: sym.priceChange24h
          });

          BybitBot.log(`[${i + 1}/${topSymbols.length}] ${sym.symbol}: Score ${score.toFixed(1)}`,
                      score > 70 ? 'success' : score > 50 ? 'info' : 'warning');

          // Rate limiting
          await BybitBot.sleep(100);

        } catch (error) {
          console.error(`Error analyzing ${sym.symbol}:`, error);
        }
      }

      // Sort by score
      results.sort((a, b) => b.score - a.score);
      BybitBot.state.scanResults = results;

      if (results.length > 0) {
        const best = results[0];
        BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
        BybitBot.log(`ğŸ† BEST SIGNAL: ${best.symbol}`, 'success');
        BybitBot.log(`ğŸ“Š Score: ${best.score.toFixed(1)}/100`, 'success');
        BybitBot.log(`ğŸ’° Price: $${best.price.toFixed(best.price < 1 ? 6 : 2)}`, 'info');
        BybitBot.log(`ğŸ“ˆ Trend: ${best.analysis.trend}`, best.analysis.trend === 'BULLISH' ? 'success' : 'warning');
        BybitBot.log(`âš¡ RSI: ${best.analysis.rsi}`, 'info');
        BybitBot.log(`ğŸ¯ Signal: ${best.analysis.signal} (${best.analysis.strength})`,
                    best.analysis.signal === 'BUY' ? 'success' : 'warning');
        BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');

        return best;
      }

      return null;
    },

    calculateScore(analysis, orderbook, marketData) {
      let score = 0;

      // Trend (30 points)
      if (analysis.trend === 'BULLISH') score += 30;
      else if (analysis.trend === 'NEUTRAL') score += 15;

      // RSI (20 points)
      const rsi = parseFloat(analysis.rsi);
      if (rsi >= 40 && rsi <= 60) score += 20; // Sweet spot
      else if (rsi >= 30 && rsi <= 70) score += 10;

      // Signal & Strength (25 points)
      if (analysis.signal === 'BUY') {
        if (analysis.strength === 'STRONG') score += 25;
        else if (analysis.strength === 'MODERATE') score += 15;
        else score += 5;
      } else if (analysis.signal === 'WAIT') {
        score += 5;
      }

      // Volume (15 points)
      const volRatio = parseFloat(analysis.volumeRatio);
      if (volRatio >= 1.5) score += 15;
      else if (volRatio >= 1.2) score += 10;
      else if (volRatio >= 1.0) score += 5;

      // Orderbook Imbalance (10 points)
      if (orderbook) {
        if (orderbook.imbalance > 0.1) score += 10; // Strong buy pressure
        else if (orderbook.imbalance > 0.05) score += 5;

        // Spread penalty
        if (orderbook.spread > 0.5) score -= 10; // Too wide spread
      }

      // Price momentum (bonus)
      if (marketData.priceChange24h > 5) score += 5; // Rising
      else if (marketData.priceChange24h < -5) score -= 5; // Falling

      return Math.max(0, Math.min(100, score));
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SMART POSITION SIZER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  positionSizer: {

    // Calculate optimal position size based on multiple factors
    calculateSize(balance, riskPercent, symbol, analysis) {
      const config = BybitBot.state.config;

      // 1. Risk-based size (basic)
      const riskAmount = balance * (riskPercent / 100);
      const stopLossPercent = config.stopLoss;
      const basicSize = (riskAmount / stopLossPercent) * 100;

      // 2. Volatility adjustment
      const atrPercent = parseFloat(analysis.atrPct) || 2;
      let volatilityMultiplier = 1;

      if (atrPercent < 1) {
        volatilityMultiplier = 1.2; // Low vol â†’ increase size
      } else if (atrPercent > 3) {
        volatilityMultiplier = 0.7; // High vol â†’ decrease size
      }

      // 3. Win rate adjustment (if have history)
      const trades = BybitBot.state.trades;
      let winRateMultiplier = 1;

      if (trades.length >= 10) {
        const recentTrades = trades.slice(-20);
        const wins = recentTrades.filter(t => t.pnl > 0).length;
        const winRate = wins / recentTrades.length;

        if (winRate > 0.6) {
          winRateMultiplier = 1.2; // Good win rate â†’ increase
        } else if (winRate < 0.4) {
          winRateMultiplier = 0.7; // Bad win rate â†’ decrease
        }
      }

      // 4. Signal strength adjustment
      const signalMultiplier = this.getSignalMultiplier(analysis);

      // 5. Calculate final size
      let finalSize = basicSize * volatilityMultiplier * winRateMultiplier * signalMultiplier;

      // 6. Apply limits (AGGRESSIVE - Allow larger positions)
      const minSize = config.positionSize * 0.5; // Min 50% of config
      const maxSize = config.positionSize * 3.0; // Max 300% of config (AGGRESSIVE!)
      finalSize = Math.max(minSize, Math.min(maxSize, finalSize));

      // Round to 2 decimals
      finalSize = Math.round(finalSize * 100) / 100;

      return {
        size: finalSize,
        breakdown: {
          basic: basicSize.toFixed(2),
          volatilityMult: volatilityMultiplier.toFixed(2),
          winRateMult: winRateMultiplier.toFixed(2),
          signalMult: signalMultiplier.toFixed(2),
          final: finalSize.toFixed(2)
        }
      };
    },

    getSignalMultiplier(analysis) {
      // AGGRESSIVE: Even weak signals get decent size!
      if (analysis.signal === 'BUY' && analysis.strength === 'STRONG') {
        return 1.5; // Increased from 1.3
      } else if (analysis.signal === 'BUY' && analysis.strength === 'MODERATE') {
        return 1.2; // Increased from 1.0
      } else if (analysis.signal === 'BUY' && analysis.strength === 'WEAK') {
        return 0.9; // Weak signals still get 90% size
      } else {
        return 0.7;
      }
    },

    // Kelly Criterion (optional, more aggressive)
    kellySize(balance, winRate, avgWin, avgLoss) {
      if (winRate <= 0 || avgLoss <= 0) return balance * 0.02; // Default 2%

      const lossRate = 1 - winRate;
      const winLossRatio = avgWin / avgLoss;
      const kelly = (winRate - (lossRate / winLossRatio));

      // Use fractional Kelly (more conservative)
      const fractionalKelly = kelly * 0.25; // 25% Kelly

      return Math.max(0, Math.min(0.05, fractionalKelly)) * balance; // Max 5%
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MARKET TYPE SELECTOR (SPOT vs FUTURES)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  marketSelector: {

    decide(analysis, klines) {
      const atrPct = parseFloat(analysis.atrPct) || 2;
      const rsi = parseFloat(analysis.rsi) || 50;
      const trend = analysis.trend;
      const volumeRatio = parseFloat(analysis.volumeRatio) || 1;
      const quickProfitMode = BybitBot.state.config.quickProfitMode;

      // Calculate trend strength
      const trendStrength = this.calculateTrendStrength(klines);

      let marketType = 'SPOT';
      let leverage = 1;
      let reason = '';

      // âš¡ QUICK PROFIT MODE: FORCE FUTURES with HIGH LEVERAGE!
      if (quickProfitMode) {
        marketType = 'FUTURES';
        // Leverage range: 10-20x based on volatility and trend
        if (atrPct >= 3 && trendStrength >= 0.7) {
          leverage = 20; // Max leverage cho setup tá»‘t nháº¥t
          reason = 'QUICK PROFIT: Perfect setup - 20x leverage!';
        } else if (atrPct >= 2 && trendStrength >= 0.5) {
          leverage = 15; // High leverage cho setup tá»‘t
          reason = 'QUICK PROFIT: Good setup - 15x leverage';
        } else {
          leverage = 10; // Min leverage cho Quick Profit
          reason = 'QUICK PROFIT: Normal setup - 10x leverage';
        }

        return { marketType, leverage, reason, details: {
          atrPct: atrPct.toFixed(2),
          trendStrength: trendStrength.toFixed(2),
          rsi: rsi,
          volumeRatio: volumeRatio.toFixed(2)
        }};
      }

      // Decision Logic

      // AGGRESSIVE MODE: Prefer FUTURES for higher profit potential!

      // 1. Very low volatility â†’ SPOT only
      if (atrPct < 1.0) {
        marketType = 'SPOT';
        leverage = 1;
        reason = 'Very low volatility - SPOT only';
      }

      // 2. Low to moderate volatility â†’ Use FUTURES with low leverage
      else if (atrPct < 2.0) {
        marketType = 'FUTURES';
        leverage = 2; // Start with 2x even at moderate vol
        reason = 'Moderate vol - FUTURES 2x for profit boost';
      }

      // 3. Good volatility â†’ FUTURES with higher leverage
      else if (atrPct >= 2.0 && atrPct < 3.5) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `Good volatility - FUTURES ${leverage}x`;
      }

      // 4. High volatility â†’ FUTURES with max leverage
      else if (atrPct >= 3.5) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `High volatility - FUTURES ${leverage}x for max profit!`;
      }

      // 4. Very high volatility + very strong trend â†’ FUTURES with higher leverage
      else if (atrPct >= 4 && trendStrength >= 0.8) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `Extreme setup - FUTURES ${leverage}x`;
      }

      // 5. Default to SPOT for safety
      else {
        marketType = 'SPOT';
        leverage = 1;
        reason = 'Default safe choice - SPOT';
      }

      return {
        marketType,
        leverage,
        reason,
        details: {
          atrPct: atrPct.toFixed(2),
          trendStrength: trendStrength.toFixed(2),
          rsi: rsi,
          volumeRatio: volumeRatio.toFixed(2)
        }
      };
    },

    calculateTrendStrength(klines) {
      if (!klines || klines.length < 20) return 0;

      const closes = klines.map(k => k.close);
      const ema20 = this.ema(closes, 20);
      const ema50 = this.ema(closes, 50);

      if (!ema20 || !ema50) return 0;

      // Trend strength = % difference between EMAs
      const diff = Math.abs((ema20 - ema50) / ema50) * 100;

      // Normalize to 0-1 scale
      return Math.min(1, diff / 3); // 3% difference = max strength
    },

    calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio) {
      let leverage = 2; // AGGRESSIVE: Start with 2x base instead of 1x

      // Base leverage from ATR (AGGRESSIVE - Higher multipliers)
      if (atrPct >= 5) leverage = 5;
      else if (atrPct >= 4) leverage = 4;
      else if (atrPct >= 3) leverage = 3;
      else if (atrPct >= 2.5) leverage = 3;
      else if (atrPct >= 2) leverage = 2;

      // Increase if trend is strong (AGGRESSIVE - Bigger bonuses)
      if (trendStrength >= 0.8) leverage += 2; // Increased from 1
      else if (trendStrength >= 0.7) leverage += 1.5; // Increased from 0.5
      else if (trendStrength >= 0.5) leverage += 1;

      // Increase if volume is high (AGGRESSIVE)
      if (volumeRatio >= 2) leverage += 1; // Increased from 0.5
      else if (volumeRatio >= 1.5) leverage += 0.5; // Increased from 0.25

      // Reduce RSI penalty (AGGRESSIVE - We accept more risk!)
      if (rsi > 80 || rsi < 20) leverage *= 0.85; // Reduced penalty
      else if (rsi > 75 || rsi < 25) leverage *= 0.95; // Minimal penalty

      // Cap leverage at 10x (AGGRESSIVE - Higher profit potential!)
      leverage = Math.min(10, leverage);

      // Floor at 1x
      leverage = Math.max(1, leverage);

      // Round to 0.5x increments
      leverage = Math.round(leverage * 2) / 2;

      return leverage;
    },

    ema(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RISK MANAGER MODULE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  riskManager: {

    canOpenPosition() {
      const state = BybitBot.state;
      const config = BybitBot.state.config;

      // Check max positions
      if (state.positions.length >= config.maxPositions) {
        return { allowed: false, reason: `Max positions (${config.maxPositions}) reached` };
      }

      // Check drawdown
      const currentDD = this.calculateDrawdown();
      if (currentDD >= config.maxDrawdownPercent) {
        return { allowed: false, reason: `Max drawdown (${config.maxDrawdownPercent}%) exceeded: ${currentDD.toFixed(2)}%` };
      }

      // Check daily loss
      this.updateDailyStats();
      const dailyLoss = Math.abs(Math.min(0, state.dailyStats.pnl));
      if (dailyLoss >= config.dailyLossLimit) {
        return { allowed: false, reason: `Daily loss limit (${config.dailyLossLimit} USDT) exceeded: ${dailyLoss.toFixed(2)} USDT` };
      }

      return { allowed: true, reason: 'OK' };
    },

    calculatePositionSize(balance, riskPercent) {
      // Simple: use config position size (can be enhanced with Kelly Criterion later)
      return BybitBot.state.config.positionSize;
    },

    shouldStopTrading() {
      const state = BybitBot.state;
      const config = BybitBot.state.config;

      // Check drawdown
      const currentDD = this.calculateDrawdown();
      if (currentDD >= config.maxDrawdownPercent) {
        return { stop: true, reason: `Max drawdown exceeded: ${currentDD.toFixed(2)}% >= ${config.maxDrawdownPercent}%` };
      }

      // Check daily loss
      this.updateDailyStats();
      const dailyLoss = Math.abs(Math.min(0, state.dailyStats.pnl));
      if (dailyLoss >= config.dailyLossLimit) {
        return { stop: true, reason: `Daily loss limit exceeded: ${dailyLoss.toFixed(2)} >= ${config.dailyLossLimit} USDT` };
      }

      return { stop: false, reason: 'OK' };
    },

    calculateDrawdown() {
      const state = BybitBot.state;
      const currentBalance = state.simMode ? state.simBalance : state.initialBalance;
      const peak = Math.max(state.initialBalance, currentBalance);

      if (peak === 0) return 0;

      const drawdown = ((peak - currentBalance) / peak) * 100;

      // Update max drawdown
      if (drawdown > state.dailyStats.maxDrawdown) {
        state.dailyStats.maxDrawdown = drawdown;
      }

      return drawdown;
    },

    updateDailyStats() {
      const state = BybitBot.state;
      const today = new Date().toDateString();

      // Reset if new day
      if (state.dailyStats.date !== today) {
        state.dailyStats = {
          date: today,
          trades: 0,
          pnl: 0,
          fees: 0,
          maxDrawdown: 0
        };
        BybitBot.log('ğŸ“… New trading day started', 'info');
      }
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PERFORMANCE CALCULATOR
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  performanceCalculator: {

    calculate(trades) {
      if (!trades || trades.length === 0) {
        return {
          totalTrades: 0,
          wins: 0,
          losses: 0,
          winRate: 0,
          profitFactor: 0,
          avgRR: 0,
          maxDrawdown: 0,
          bestTrade: 0,
          worstTrade: 0,
          avgTrade: 0,
          grossPnL: 0,
          totalFees: 0,
          netPnL: 0
        };
      }

      const wins = trades.filter(t => t.pnl > 0);
      const losses = trades.filter(t => t.pnl <= 0);

      const grossWin = wins.reduce((sum, t) => sum + (t.grossPnl || t.pnl), 0);
      const grossLoss = Math.abs(losses.reduce((sum, t) => sum + (t.grossPnl || t.pnl), 0));

      const profitFactor = grossLoss > 0 ? (grossWin / grossLoss) : (grossWin > 0 ? 999 : 0);

      // Calculate average R:R
      let totalRR = 0;
      let countRR = 0;
      wins.forEach(trade => {
        if (trade.pnl > 0) {
          const risk = Math.abs(trade.pnl); // Simplified
          const reward = trade.pnl;
          if (risk > 0) {
            totalRR += reward / risk;
            countRR++;
          }
        }
      });
      const avgRR = countRR > 0 ? (totalRR / countRR) : 0;

      const grossPnL = trades.reduce((sum, t) => sum + (t.grossPnl || 0), 0);
      const totalFees = trades.reduce((sum, t) => sum + (t.fees || 0), 0);
      const netPnL = trades.reduce((sum, t) => sum + t.pnl, 0);

      return {
        totalTrades: trades.length,
        wins: wins.length,
        losses: losses.length,
        winRate: ((wins.length / trades.length) * 100).toFixed(1),
        profitFactor: profitFactor.toFixed(2),
        avgRR: avgRR.toFixed(2),
        maxDrawdown: BybitBot.state.dailyStats.maxDrawdown.toFixed(2),
        bestTrade: wins.length > 0 ? Math.max(...wins.map(t => t.pnl)) : 0,
        worstTrade: losses.length > 0 ? Math.min(...losses.map(t => t.pnl)) : 0,
        avgTrade: (netPnL / trades.length).toFixed(2),
        grossPnL,
        totalFees,
        netPnL
      };
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UI HELPERS - CONFIRMATION & SOUND ALERTS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  confirm(message) {
    return new Promise((resolve) => {
      const modal = document.getElementById('confirmModal');
      const messageEl = document.getElementById('confirmMessage');
      const okBtn = document.getElementById('confirmOk');
      const cancelBtn = document.getElementById('confirmCancel');

      messageEl.textContent = message;
      modal.classList.add('show');

      const handleOk = () => {
        modal.classList.remove('show');
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        resolve(true);
      };

      const handleCancel = () => {
        modal.classList.remove('show');
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        resolve(false);
      };

      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);

      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) handleCancel();
      });
    });
  },

  soundAlerts: {
    context: null,

    init() {
      // Initialize AudioContext on first user interaction
      if (!this.context) {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
      }
    },

    play(type) {
      this.init();

      const frequencies = {
        success: [523.25, 659.25],  // C5, E5
        warning: [440, 523.25],      // A4, C5
        error: [329.63, 261.63],     // E4, C4
        signal: [659.25, 783.99, 1046.50]  // E5, G5, C6
      };

      const freq = frequencies[type] || frequencies.signal;
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);

      oscillator.type = 'sine';
      oscillator.frequency.value = freq[0];

      gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

      oscillator.start(this.context.currentTime);
      oscillator.stop(this.context.currentTime + 0.3);

      // Play subsequent notes if available
      if (freq.length > 1) {
        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();

          osc2.connect(gain2);
          gain2.connect(this.context.destination);

          osc2.type = 'sine';
          osc2.frequency.value = freq[1];

          gain2.gain.setValueAtTime(0.3, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);

          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.2);
        }, 100);
      }
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORE TRADING LOGIC
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async startTrading() {
    if (this.state.isRunning) {
      this.log('âš ï¸ Bot is already running!', 'warning');
      return;
    }

    // Collect config
    this.collectConfig();

    this.state.isRunning = true;
    document.getElementById('btnStart').disabled = true;
    document.getElementById('btnStop').disabled = false;
    document.getElementById('systemStatus').textContent = 'TRADING';
    document.getElementById('systemStatus').className = 'status active';

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    this.log('ğŸš€ TRADING STARTED', 'success');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    this.log(`ğŸ“Š Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}`, 'info');
    this.log(`ğŸ¯ Strategy: ${this.state.config.strategy}`, 'info');
    this.log(`â±ï¸ Timeframe: ${this.state.config.timeframe}m`, 'info');
    this.log(`ğŸ’° Position Size: ${this.state.config.positionSize} USDT`, 'info');

    if (this.state.config.quickProfitMode) {
      this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
      this.log('âš¡âš¡âš¡ QUICK PROFIT MODE ACTIVE! âš¡âš¡âš¡', 'warning');
      this.log('ğŸ¯ Má»¥c tiÃªu: VÃ€O NHANH - Lá»œI NHANH!', 'warning');
      this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
    }

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');

    // Start UI updates for Technical Analysis and News
    this.startUIUpdates();

    // Start trading loop
    this.tradingLoop();
  },

  async stopTrading() {
    const confirmed = await this.confirm('Báº¡n cÃ³ cháº¯c muá»‘n dá»«ng bot? CÃ¡c vá»‹ tháº¿ Ä‘ang má»Ÿ sáº½ váº«n Ä‘Æ°á»£c giá»¯.');
    if (!confirmed) return;

    this.state.isRunning = false;
    this.stopUIUpdates(); // Stop UI updates
    
    document.getElementById('btnStart').disabled = false;
    document.getElementById('btnStop').disabled = true;
    document.getElementById('systemStatus').textContent = 'STOPPED';
    document.getElementById('systemStatus').className = 'status error';

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
    this.log('â¹ï¸ TRADING STOPPED', 'warning');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');

    this.soundAlerts.play('warning');
  },

  async tradingLoop() {
    while (this.state.isRunning) {
      try {
        // Monitor existing positions
        if (this.state.positions.length > 0) {
          await this.monitorPositions();
        }

        // Try to open new positions if slots available
        if (this.state.positions.length < this.state.config.maxPositions) {
          await this.scanMarket();
        }

        // Check risk status
        const riskCheck = this.riskManager.shouldStopTrading();
        if (riskCheck.stop) {
          this.log(`ğŸ›‘ STOPPING TRADING: ${riskCheck.reason}`, 'error');
          this.stopTrading();
          break;
        }

        // Wait before next iteration
        await this.sleep(5000); // 5 seconds

      } catch (error) {
        this.log(`âŒ Error: ${error.message}`, 'error');
        await this.sleep(10000);
      }
    }
  },

  closePositionById(positionId, exitPrice, reason) {
    const index = this.state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;

    const pos = this.state.positions[index];

    // Calculate gross PnL (before fees)
    const grossPnlPct = ((exitPrice - pos.entry) / pos.entry) * 100;
    const grossPnlUSDT = pos.size * (grossPnlPct / 100);

    // Calculate exit fee
    const exitValue = pos.qty * exitPrice;
    const exitFee = exitValue * (this.state.config.tradingFee / 100);

    // Calculate total fees and net PnL
    const totalFees = pos.entryFee + exitFee;
    const netPnlUSDT = grossPnlUSDT - totalFees;
    const netPnlPct = (netPnlUSDT / pos.size) * 100;

    // Record trade
    const trade = {
      time: new Date().toLocaleTimeString('vi-VN'),
      symbol: pos.symbol,
      entry: pos.entry,
      exit: exitPrice,
      grossPnl: grossPnlUSDT,
      fees: totalFees,
      pnl: netPnlUSDT,
      pnlPct: netPnlPct,
      reason: reason
    };

    this.state.trades.push(trade);

    // Update PnL and Fees
    this.state.totalFees += totalFees;

    if (this.state.simMode) {
      this.state.simPnL += netPnlUSDT;
      this.state.simBalance += netPnlUSDT;
    } else {
      this.state.livePnL += netPnlUSDT;
    }

    // Update daily stats
    this.riskManager.updateDailyStats();
    this.state.dailyStats.trades++;
    this.state.dailyStats.pnl += netPnlUSDT;
    this.state.dailyStats.fees += totalFees;

    // Update charts with NET PnL (realized)
    this.updatePnLChart(netPnlUSDT, this.state.trades.length);
    this.updateCumulativePnLChart();

    // Remove from positions array
    this.state.positions.splice(index, 1);

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`${netPnlUSDT >= 0 ? 'âœ…' : 'âŒ'} POSITION CLOSED - ${reason}`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Symbol: ${pos.symbol}`, 'info');
    this.log(`Entry: $${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}`, 'info');
    this.log(`Exit: $${exitPrice.toFixed(exitPrice < 1 ? 6 : 2)}`, 'info');
    this.log(`Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)`, 'info');
    this.log(`Fees: -${totalFees.toFixed(4)} USDT (Entry: ${pos.entryFee.toFixed(4)} + Exit: ${exitFee.toFixed(4)})`, 'warning');
    this.log(`Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Remaining positions: ${this.state.positions.length}/${this.state.config.maxPositions}`, 'info');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', netPnlUSDT >= 0 ? 'success' : 'error');

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const result = netPnlUSDT >= 0 ? 'âœ… WIN' : 'âŒ LOSS';
      const message = `
${result} - ${pos.symbol}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Entry: $${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}
Exit: $${exitPrice.toFixed(exitPrice < 1 ? 6 : 2)}

ğŸ’° Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)
ğŸ’¸ Fees: -${totalFees.toFixed(4)} USDT
âœ… Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)

Reason: ${reason}
Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}
Balance: ${this.state.simMode ? this.state.simBalance.toFixed(2) : 'N/A'} USDT
Active: ${this.state.positions.length}/${this.state.config.maxPositions}
      `.trim();

      this.sendTelegram(message);
    }

    // Update UI
    this.updateActivePositionsTable();
    this.updateStats();
    this.updateTradeTable();
    this.updateRiskStatus();
    this.updatePerformanceDashboard();

    // Play sound alert
    this.soundAlerts.play(netPnlUSDT >= 0 ? 'success' : 'error');
  },

  // Close position from UI button
  closePositionByUI(positionId) {
    const pos = this.state.positions.find(p => p.id === positionId);
    if (pos) {
      this.closePositionById(positionId, pos.currentPrice, 'MANUAL CLOSE');
    }
  },

  async scanMarket() {
    this.log('ğŸ” Scanning market...', 'info');

    // Check risk manager first
    const riskCheck = this.riskManager.canOpenPosition();
    if (!riskCheck.allowed) {
      this.log(`âš ï¸ Cannot open position: ${riskCheck.reason}`, 'warning');
      return;
    }

    // Use real Bybit API to scan market
    const best = await this.autoScanner.scanMarket();

    // âš¡ QUICK PROFIT MODE: VÃ o ngay khi cÃ³ Báº¤T Ká»² signal nÃ o!
    const scoreThreshold = this.state.config.quickProfitMode ? 0 : 35;

    if (best && best.score >= scoreThreshold) { // AGGRESSIVE: Lower threshold from 50 to 35 for more trades!
      // Check if already have this symbol
      const existingPosition = this.state.positions.find(p => p.symbol === best.symbol);
      if (existingPosition) {
        this.log(`â­ï¸ Already have position on ${best.symbol}, skipping...`, 'info');
        return;
      }

      // Fetch klines for analysis
      const klines = await this.bybitAPI.getKlines(best.symbol, this.state.config.timeframe, 100);

      // Perform detailed technical analysis
      const analysis = await this.performTechnicalAnalysis(best.symbol, klines);

      this.log(`âœ… Signal found: ${best.symbol} @ $${best.price.toFixed(best.price < 1 ? 6 : 2)}`, 'success');

      // Enter position with enhanced logic
      this.enterPosition(best.symbol, best.price, analysis, klines);
    } else {
      this.log('â³ No good signals found, waiting...', 'warning');
    }
  },

  enterPosition(symbol, price, analysis, klines) {
    const balance = this.state.simMode ? this.state.simBalance : this.state.initialBalance;

    // 1. Calculate optimal position size
    const sizeData = this.positionSizer.calculateSize(
      balance,
      this.state.config.riskPerTrade,
      symbol,
      analysis
    );
    const size = sizeData.size;

    // 2. Decide market type (SPOT vs FUTURES) and leverage
    const marketDecision = this.marketSelector.decide(analysis, klines);

    const qty = size / price;

    // Calculate entry fee (futures fee might be different)
    const feeRate = marketDecision.marketType === 'FUTURES' ? 0.055 : this.state.config.tradingFee; // 0.055% for futures taker
    const entryFee = size * (feeRate / 100);

    // Adjust size with leverage if FUTURES
    const effectiveSize = marketDecision.marketType === 'FUTURES' ? size * marketDecision.leverage : size;
    const effectiveQty = marketDecision.marketType === 'FUTURES' ? qty * marketDecision.leverage : qty;

    const position = {
      id: Date.now() + '_' + symbol,
      symbol,
      entry: price,
      qty: effectiveQty,
      size: effectiveSize,
      actualCapital: size, // Real capital used (before leverage)
      entryTime: Date.now(),
      tp: price * (1 + this.state.config.takeProfit / 100),
      sl: price * (1 - this.state.config.stopLoss / 100),
      entryFee: entryFee,
      unrealizedPnL: 0,
      currentPrice: price,
      marketType: marketDecision.marketType,
      leverage: marketDecision.leverage,
      positionSizing: sizeData.breakdown,
      analysisSnapshot: {
        signal: analysis.signal,
        strength: analysis.strength,
        confidence: analysis.confidence,
        atrPct: analysis.atrPct
      }
    };

    // Add to positions array
    this.state.positions.push(position);

    // Update price chart
    this.updatePriceChart(price, symbol);

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    this.log(`ğŸ“ˆ POSITION ${this.state.positions.length}/${this.state.config.maxPositions} OPENED`, 'success');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    this.log(`ğŸ“Œ Symbol: ${symbol}`, 'info');
    this.log(`ğŸ’° Entry Price: $${price.toFixed(price < 1 ? 6 : 2)}`, 'info');
    this.log(``, 'info');
    this.log(`ğŸ’¼ Market Type: ${marketDecision.marketType}`, marketDecision.marketType === 'FUTURES' ? 'warning' : 'success');
    if (marketDecision.leverage > 1) {
      this.log(`âš¡ Leverage: ${marketDecision.leverage}x`, 'warning');
      this.log(`   Reason: ${marketDecision.reason}`, 'info');
    }
    this.log(``, 'info');
    this.log(`ğŸ’µ Position Sizing:`, 'info');
    this.log(`   Base Size: ${sizeData.breakdown.basic} USDT`, 'info');
    this.log(`   Volatility Mult: ${sizeData.breakdown.volatilityMult}x`, 'info');
    this.log(`   Win Rate Mult: ${sizeData.breakdown.winRateMult}x`, 'info');
    this.log(`   Signal Mult: ${sizeData.breakdown.signalMult}x`, 'info');
    this.log(`   Final Size: ${size.toFixed(2)} USDT (capital)`, 'success');
    if (marketDecision.leverage > 1) {
      this.log(`   Effective Size: ${effectiveSize.toFixed(2)} USDT (with ${marketDecision.leverage}x leverage)`, 'warning');
    }
    this.log(``, 'info');
    this.log(`ğŸ’¸ Entry Fee: ${entryFee.toFixed(4)} USDT (${feeRate}%)`, 'warning');
    this.log(`ğŸ¯ TP: $${position.tp.toFixed(price < 1 ? 6 : 2)} (+${this.state.config.takeProfit}%)`, 'success');
    this.log(`ğŸ›‘ SL: $${position.sl.toFixed(price < 1 ? 6 : 2)} (-${this.state.config.stopLoss}%)`, 'error');
    this.log(`ğŸ“Š Signal: ${analysis.signal} (${analysis.strength}, ${analysis.confidence}% conf)`, 'info');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');

    // Update UI
    this.updateActivePositionsTable();
    this.updateRiskStatus();

    // Send to Telegram
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const message = `
ğŸš€ POSITION OPENED

${symbol}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Market: ${marketDecision.marketType}${marketDecision.leverage > 1 ? ' ' + marketDecision.leverage + 'x' : ''}
Entry: $${price.toFixed(price < 1 ? 6 : 2)}
Size: ${size.toFixed(2)} USDT${marketDecision.leverage > 1 ? ' (' + effectiveSize.toFixed(2) + ' effective)' : ''}

TP: $${position.tp.toFixed(price < 1 ? 6 : 2)} (+${this.state.config.takeProfit}%)
SL: $${position.sl.toFixed(price < 1 ? 6 : 2)} (-${this.state.config.stopLoss}%)

Signal: ${analysis.signal} (${analysis.confidence}%)
Reasons: ${analysis.reasons ? analysis.reasons.slice(0, 2).join(', ') : 'N/A'}

${marketDecision.leverage > 1 ? 'âš ï¸ ' + marketDecision.reason : ''}
      `.trim();

      this.sendTelegram(message);
    }

    // Play sound alert for new position
    this.soundAlerts.play('signal');
  },

  async monitorPositions() {
    if (this.state.positions.length === 0) return;

    let totalUnrealizedPnL = 0;

    for (const pos of this.state.positions) {
      // Simulate price movement (in real scenario, fetch from API)
      const volatility = 0.002; // 0.2% random movement
      const currentPrice = pos.entry * (1 + (Math.random() - 0.5) * 2 * volatility);

      // Update position current price
      pos.currentPrice = currentPrice;

      // Calculate gross PnL
      const grossPnlPct = ((currentPrice - pos.entry) / pos.entry) * 100;
      const grossPnlUSDT = pos.size * (grossPnlPct / 100);

      // Calculate potential exit fee
      const exitValue = pos.qty * currentPrice;
      const exitFee = exitValue * (this.state.config.tradingFee / 100);

      // Calculate unrealized NET PnL
      const totalFees = pos.entryFee + exitFee;
      const unrealizedNetPnL = grossPnlUSDT - totalFees;
      const unrealizedNetPct = (unrealizedNetPnL / pos.size) * 100;

      // Store unrealized PnL in position
      pos.unrealizedPnL = unrealizedNetPnL;
      totalUnrealizedPnL += unrealizedNetPnL;

      // âš¡ QUICK PROFIT MODE: Trailing stop siÃªu cháº·t Ä‘á»ƒ báº£o vá»‡ lá»£i nhuáº­n!
      if (this.state.config.quickProfitMode && grossPnlPct > 0) {
        // Náº¿u Ä‘ang lá»i > 0.3%, set trailing stop = 0.2% Ä‘á»ƒ thoÃ¡t nhanh náº¿u Ä‘áº£o chiá»u
        if (grossPnlPct >= 0.3) {
          const trailingStopPrice = currentPrice * 0.998; // 0.2% trailing
          if (!pos.trailingStopPrice || trailingStopPrice > pos.trailingStopPrice) {
            pos.trailingStopPrice = trailingStopPrice;
          }

          // Náº¿u price drop dÆ°á»›i trailing stop â†’ close ngay!
          if (currentPrice <= pos.trailingStopPrice) {
            this.closePositionById(pos.id, currentPrice, 'âš¡ QUICK PROFIT: Trailing Stop Hit (Báº£o vá»‡ lá»i)');
            continue;
          }
        }
      }

      // Check TP/SL
      if (currentPrice >= pos.tp) {
        this.closePositionById(pos.id, currentPrice, 'TP HIT');
      } else if (currentPrice <= pos.sl) {
        this.closePositionById(pos.id, currentPrice, 'SL HIT');
      }
    }

    // Store total unrealized PnL
    this.state.unrealizedPnL = totalUnrealizedPnL;

    // Update UI
    this.updateActivePositionsTable();
    this.updateRiskStatus();
  },

  closePosition(exitPrice, reason) {
    const pos = this.state.currentPosition;

    // Calculate gross PnL (before fees)
    const grossPnlPct = ((exitPrice - pos.entry) / pos.entry) * 100;
    const grossPnlUSDT = pos.size * (grossPnlPct / 100);

    // Calculate exit fee
    const exitValue = pos.qty * exitPrice;
    const exitFee = exitValue * (this.state.config.tradingFee / 100);

    // Calculate total fees and net PnL
    const totalFees = pos.entryFee + exitFee;
    const netPnlUSDT = grossPnlUSDT - totalFees;
    const netPnlPct = (netPnlUSDT / pos.size) * 100;

    // Record trade
    const trade = {
      time: new Date().toLocaleTimeString('vi-VN'),
      symbol: pos.symbol,
      entry: pos.entry,
      exit: exitPrice,
      grossPnl: grossPnlUSDT,
      fees: totalFees,
      pnl: netPnlUSDT,
      pnlPct: netPnlPct,
      reason: reason
    };

    this.state.trades.push(trade);

    // Update PnL and Fees
    this.state.totalFees += totalFees;

    if (this.state.simMode) {
      this.state.simPnL += netPnlUSDT;
      this.state.simBalance += netPnlUSDT;
    } else {
      this.state.livePnL += netPnlUSDT;
    }

    // Clear unrealized PnL bar if exists
    const lastLabel = this.charts.pnlChart?.data.labels[this.charts.pnlChart.data.labels.length - 1];
    if (lastLabel && lastLabel.includes('Current')) {
      this.charts.pnlChart.data.labels.pop();
      this.charts.pnlChart.data.datasets[0].data.pop();
      this.charts.pnlChart.data.datasets[0].backgroundColor.pop();
    }

    // Update charts with NET PnL (realized)
    this.updatePnLChart(netPnlUSDT, this.state.trades.length);
    this.updateCumulativePnLChart();

    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`${netPnlUSDT >= 0 ? 'âœ…' : 'âŒ'} POSITION CLOSED - ${reason}`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Exit: $${exitPrice.toFixed(2)}`, 'info');
    this.log(`Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)`, 'info');
    this.log(`Fees: -${totalFees.toFixed(4)} USDT (Entry: ${pos.entryFee.toFixed(4)} + Exit: ${exitFee.toFixed(4)})`, 'warning');
    this.log(`Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', netPnlUSDT >= 0 ? 'success' : 'error');

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const result = netPnlUSDT >= 0 ? 'âœ… WIN' : 'âŒ LOSS';
      const message = `
${result} - ${pos.symbol}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Entry: $${pos.entry.toFixed(2)}
Exit: $${exitPrice.toFixed(2)}

ğŸ’° Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)
ğŸ’¸ Fees: -${totalFees.toFixed(4)} USDT
âœ… Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)

Reason: ${reason}
Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}
Balance: ${this.state.simMode ? this.state.simBalance.toFixed(2) : 'N/A'} USDT
      `.trim();

      this.sendTelegram(message);
    }

    this.state.currentPosition = null;
    this.updateStats();
    this.updateTradeTable();
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ADVANCED FEATURES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async testSystem() {
    this.log('ğŸ§ª Running system diagnostics...', 'info');
    await this.sleep(1000);

    this.log('âœ… UI: Working', 'success');
    await this.sleep(500);

    this.log('âœ… Logging: Working', 'success');
    await this.sleep(500);

    this.log('âœ… Event Handlers: Working', 'success');
    await this.sleep(500);

    this.log('âœ… State Management: Working', 'success');
    await this.sleep(500);

    this.log('ğŸ‰ All systems operational!', 'success');
  },

  async performAnalysis() {
    const symbol = document.getElementById('analysisSymbol').value || 'BTCUSDT';
    const tf = document.getElementById('analysisTimeframe').value || '5';

    this.log(`ğŸ” Analyzing ${symbol} (${tf}m)...`, 'info');

    const resultDiv = document.getElementById('analysisResult');
    resultDiv.innerHTML = `<div class="log-line log-info">Analyzing ${symbol}...</div>`;

    await this.sleep(2000);

    // Simulate analysis
    const analysis = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š TECHNICAL ANALYSIS - ${symbol}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¹ TREND
  EMA20: $${(50000 + Math.random() * 1000).toFixed(2)}
  EMA50: $${(49800 + Math.random() * 1000).toFixed(2)}
  Trend: ${Math.random() > 0.5 ? 'â†—ï¸ BULLISH' : 'â†˜ï¸ BEARISH'}

ğŸ”¹ MOMENTUM
  RSI(14): ${(40 + Math.random() * 30).toFixed(1)}
  MACD: ${Math.random() > 0.5 ? 'POSITIVE' : 'NEGATIVE'}

ğŸ”¹ VOLATILITY
  ATR: ${(Math.random() * 2).toFixed(2)}%
  BB Width: ${(Math.random() * 3).toFixed(2)}%

ğŸ”¹ VOLUME
  Current: ${(Math.random() * 1000000).toFixed(0)} USDT
  Average: ${(Math.random() * 900000).toFixed(0)} USDT
  Ratio: ${(1 + Math.random() * 0.5).toFixed(2)}x

ğŸ’¡ SUGGESTION: ${Math.random() > 0.5 ? 'BUY' : 'WAIT'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `;

    resultDiv.innerHTML = analysis.split('\n').map(line => {
      let type = 'info';
      if (line.includes('BULLISH') || line.includes('BUY')) type = 'success';
      if (line.includes('BEARISH') || line.includes('WAIT')) type = 'warning';
      return `<div class="log-line log-${type}">${line}</div>`;
    }).join('');

    this.log(`âœ… Analysis complete for ${symbol}`, 'success');
  },

  async startFullAuto() {
    const enabled = document.getElementById('fullAutoMode').checked;

    if (!enabled) {
      this.log('âš ï¸ Please enable Full Auto Mode checkbox first', 'warning');
      return;
    }

    this.log('ğŸ¤– Báº¯t Ä‘áº§u cháº¿ Ä‘á»™ Full Auto Mode...', 'success');
    await this.sleep(1000);

    this.log('âœ… Auto optimization: ACTIVE', 'success');
    this.log('âœ… Market regime detection: ACTIVE', 'success');
    this.log('âœ… Risk adjustment: ACTIVE', 'success');
    this.log('âœ… Recovery mode: ACTIVE', 'success');
    this.log('ğŸš€ Full Auto Mode is now running!', 'success');
  },

  async startOptimization() {
    const target = document.getElementById('targetWinRate').value || 55;
    const rounds = document.getElementById('optimizationRounds').value || 50;

    const logDiv = document.getElementById('optimizationLog');
    logDiv.innerHTML = '';

    const logOpt = (msg, type = 'info') => {
      const line = document.createElement('div');
      line.className = 'log-line log-' + type;
      line.textContent = msg;
      logDiv.appendChild(line);
      logDiv.scrollTop = logDiv.scrollHeight;
    };

    logOpt('âš¡ Starting parameter optimization...', 'success');
    logOpt(`Target Win Rate: ${target}%`, 'info');
    logOpt(`Rounds: ${rounds}`, 'info');
    logOpt('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');

    for (let i = 1; i <= Math.min(rounds, 10); i++) {
      await this.sleep(500);
      const wr = (45 + Math.random() * 20).toFixed(1);
      const pnl = ((Math.random() - 0.3) * 100).toFixed(2);
      logOpt(`Round ${i}/${rounds} | WR: ${wr}% | PnL: ${pnl >= 0 ? '+' : ''}${pnl} USDT`,
             wr >= target ? 'success' : 'warning');
    }

    await this.sleep(1000);
    logOpt('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    logOpt('âœ… Optimization complete!', 'success');
    logOpt(`Best Win Rate: ${(50 + Math.random() * 10).toFixed(1)}%`, 'success');
    logOpt(`Optimized TP: ${(1 + Math.random()).toFixed(2)}%`, 'info');
    logOpt(`Optimized SL: ${(0.5 + Math.random() * 0.5).toFixed(2)}%`, 'info');
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UTILITIES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  collectConfig() {
    const quickProfitMode = document.getElementById('quickProfitMode')?.checked || false;

    this.state.config = {
      strategy: document.getElementById('strategyType').value,
      timeframe: document.getElementById('timeframe').value,
      positionSize: parseFloat(document.getElementById('positionSize').value) || 100,
      takeProfit: parseFloat(document.getElementById('takeProfit').value) || 1.5,
      stopLoss: parseFloat(document.getElementById('stopLoss').value) || 0.8,
      tradingFee: parseFloat(document.getElementById('tradingFee').value) || 0.1,
      trailingStop: document.getElementById('trailingStop').checked,
      conservativeMode: document.getElementById('conservativeMode').checked,
      quickProfitMode: quickProfitMode,
      minVolume: parseFloat(document.getElementById('minVolume').value) || 1000000,
      minPump: parseFloat(document.getElementById('minPump').value) || 1.0,
      maxSpread: parseFloat(document.getElementById('maxSpread').value) || 0.3,
      btcFilter: document.getElementById('btcFilter').checked,
      // Risk Management
      maxPositions: parseInt(document.getElementById('maxPositions')?.value) || 3,
      maxDrawdownPercent: parseFloat(document.getElementById('maxDrawdownPercent')?.value) || 15,
      dailyLossLimit: parseFloat(document.getElementById('dailyLossLimit')?.value) || 100,
      riskPerTrade: parseFloat(document.getElementById('riskPerTrade')?.value) || 2
    };

    // Apply QUICK PROFIT MODE overrides
    if (quickProfitMode) {
      this.applyQuickProfitSettings();
    }

    // Update UI counters
    document.getElementById('maxPosCount').textContent = this.state.config.maxPositions;
    document.getElementById('riskMaxPos').textContent = this.state.config.maxPositions;
  },

  applyQuickProfitSettings() {
    this.log('âš¡âš¡âš¡ QUICK PROFIT MODE ACTIVATED! âš¡âš¡âš¡', 'warning');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');

    // Ultra aggressive settings for QUICK PROFIT
    this.state.config.takeProfit = 0.5;  // TP siÃªu nhá»: 0.5% (lá»i nhanh!)
    this.state.config.stopLoss = 0.8;    // SL cháº·t: 0.8%
    this.state.config.maxPositions = 10; // Nhiá»u lá»‡nh cÃ¹ng lÃºc
    this.state.config.riskPerTrade = 5;  // Risk cao: 5% per trade
    this.state.config.trailingStop = true; // Báº¯t buá»™c trailing stop
    this.state.config.maxDrawdownPercent = 40; // Cho phÃ©p DD cao
    this.state.config.dailyLossLimit = 500;    // Limit cao hÆ¡n
    this.state.config.minPump = 0.1;     // VÃ o ngay cáº£ khi pump nhá»

    this.log('ğŸ“Š TP: 0.5% (vÃ o nhanh, lá»i nhanh!)', 'warning');
    this.log('ğŸ›‘ SL: 0.8% (cháº·t)', 'warning');
    this.log('ğŸ”¥ Max Positions: 10 (scalping style)', 'warning');
    this.log('ğŸ’° Risk/Trade: 5% (AGGRESSIVE)', 'warning');
    this.log('âš¡ Leverage: 10-20x (tá»± Ä‘á»™ng)', 'warning');
    this.log('ğŸ¯ Entry: VÃ€O NGAY khi cÃ³ báº¥t ká»³ tÃ­n hiá»‡u nÃ o!', 'warning');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
    this.log('âš ï¸ Cáº¢NH BÃO: Cháº¿ Ä‘á»™ nÃ y Cá»°C Ká»² RISK! CÃ³ thá»ƒ máº¥t vá»‘n nhanh!', 'error');
    this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
  },

  loadConfig() {
    // Load from localStorage if exists
    const saved = localStorage.getItem('bybit_bot_config');
    if (saved) {
      try {
        const config = JSON.parse(saved);
        Object.keys(config).forEach(key => {
          const el = document.getElementById(key);
          if (el) {
            if (el.type === 'checkbox') el.checked = config[key];
            else el.value = config[key];
          }
        });
      } catch (e) {}
    }
  },

  updateStats() {
    const mode = this.state.simMode;
    const balance = mode ? this.state.simBalance : 0;
    const pnl = mode ? this.state.simPnL : this.state.livePnL;

    document.getElementById('statBalance').textContent = balance.toFixed(2) + ' USDT';
    document.getElementById('statPnL').textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + ' USDT';
    document.getElementById('statPnL').className = pnl >= 0 ? 'text-success' : 'text-danger';

    // Update total fees
    document.getElementById('statFees').textContent = this.state.totalFees.toFixed(4) + ' USDT';

    const wins = this.state.trades.filter(t => t.pnl > 0).length;
    const total = this.state.trades.length;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : 0;

    document.getElementById('statWinRate').textContent = winRate + '%';
    document.getElementById('statWinRate').className = winRate >= 50 ? 'text-success' : 'text-danger';

    // Calculate gross PnL (before fees)
    const grossPnl = this.state.trades.reduce((sum, t) => sum + (t.grossPnl || 0), 0);

    // Update performance tab
    document.getElementById('perfTrades').textContent = total;
    document.getElementById('perfWinRate').textContent = winRate + '%';
    document.getElementById('perfWinRate').className = winRate >= 50 ? 'text-success' : 'text-danger';

    // Gross PnL
    document.getElementById('perfGrossPnL').textContent = (grossPnl >= 0 ? '+' : '') + grossPnl.toFixed(2);
    document.getElementById('perfGrossPnL').className = grossPnl >= 0 ? 'text-success' : 'text-danger';

    // Total Fees
    document.getElementById('perfFees').textContent = '-' + this.state.totalFees.toFixed(4);

    // Net PnL
    document.getElementById('perfPnL').textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2);
    document.getElementById('perfPnL').className = pnl >= 0 ? 'text-success' : 'text-danger';

    const avgPnl = total > 0 ? (pnl / total).toFixed(2) : '0.00';
    document.getElementById('perfAvg').textContent = avgPnl;
    document.getElementById('perfAvg').className = avgPnl >= 0 ? 'text-success' : 'text-danger';
  },

  updateTradeTable() {
    const tbody = document.getElementById('tradeTableBody');

    if (this.state.trades.length === 0) {
      tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: var(--text-dim);">No trades yet</td></tr>';
      return;
    }

    tbody.innerHTML = this.state.trades.slice(-20).reverse().map(trade => `
      <tr>
        <td>${trade.time}</td>
        <td>${trade.symbol}</td>
        <td>$${trade.entry.toFixed(2)}</td>
        <td>$${trade.exit.toFixed(2)}</td>
        <td class="${(trade.grossPnl || 0) >= 0 ? 'text-success' : 'text-danger'}">${((trade.grossPnl || 0) >= 0 ? '+' : '')}${(trade.grossPnl || 0).toFixed(2)}</td>
        <td class="text-warning">-${(trade.fees || 0).toFixed(4)}</td>
        <td class="${trade.pnl >= 0 ? 'text-success' : 'text-danger'}"><strong>${(trade.pnl >= 0 ? '+' : '')}${trade.pnl.toFixed(2)}</strong></td>
        <td class="${trade.pnlPct >= 0 ? 'text-success' : 'text-danger'}">${(trade.pnlPct >= 0 ? '+' : '')}${trade.pnlPct.toFixed(2)}%</td>
      </tr>
    `).join('');
  },

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTINUOUS UI UPDATES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  startUIUpdates() {
    // Clear existing interval if any
    if (this.uiUpdateInterval) {
      clearInterval(this.uiUpdateInterval);
    }

    this.log('ğŸ”„ Starting UI updates...', 'info');
    this.log('ğŸ“Š Technical Analysis & News: Every 10s', 'info');

    // Update immediately
    this.updateTechnicalAnalysisUI();
    this.updateNewsSentimentUI();

    // Set interval for continuous updates
    this.uiUpdateInterval = setInterval(() => {
      if (this.state.isRunning) {
        this.updateTechnicalAnalysisUI();
        this.updateNewsSentimentUI();
      }
    }, 10000); // Every 10s
  },

  stopUIUpdates() {
    if (this.uiUpdateInterval) {
      clearInterval(this.uiUpdateInterval);
      this.uiUpdateInterval = null;
    }
  },

  async updateTechnicalAnalysisUI() {
    try {
      // Get market data
      const klines = await this.bybitAPI.getKlines('BTCUSDT', '5', 50);
      if (!klines || klines.length === 0) return;

      const closes = klines.map(k => parseFloat(k[4])); // Close price
      const currentPrice = closes[closes.length - 1];

      // Calculate indicators
      let analysis = {
        price: currentPrice,
        timestamp: Date.now(),
        indicators: {}
      };

      if (this.technicalAnalysis && closes.length >= 50) {
        const ema20 = this.technicalAnalysis.ema(closes, 20);
        const ema50 = this.technicalAnalysis.ema(closes, 50);
        const rsi = this.technicalAnalysis.rsi(closes, 14);
        const macd = this.technicalAnalysis.macd(closes);

        if (ema20 && ema20.length > 0) analysis.indicators.ema20 = ema20[ema20.length - 1];
        if (ema50 && ema50.length > 0) analysis.indicators.ema50 = ema50[ema50.length - 1];
        if (rsi && rsi.length > 0) analysis.indicators.rsi = rsi[rsi.length - 1];
        if (macd) {
          analysis.indicators.macd = macd.line[macd.line.length - 1];
          analysis.indicators.macdSignal = macd.signal[macd.signal.length - 1];
        }

        // Trend analysis
        if (analysis.indicators.ema20 && analysis.indicators.ema50) {
          analysis.trend = currentPrice > analysis.indicators.ema20 && analysis.indicators.ema20 > analysis.indicators.ema50 ? 'BULLISH' :
            currentPrice < analysis.indicators.ema20 && analysis.indicators.ema20 < analysis.indicators.ema50 ? 'BEARISH' : 'NEUTRAL';
        }

        // Signal strength
        analysis.strength = 'MEDIUM';
        if (analysis.indicators.rsi > 70) analysis.strength = 'OVERBOUGHT';
        else if (analysis.indicators.rsi < 30) analysis.strength = 'OVERSOLD';
      }

      // Update UI
      this.logAnalysis('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      this.logAnalysis(`ğŸ“Š PHÃ‚N TÃCH Ká»¸ THUáº¬T - BTCUSDT`, 'success');
      this.logAnalysis(`ğŸ’° GiÃ¡: $${currentPrice.toFixed(2)}`, 'info');

      if (analysis.trend) {
        const trendEmoji = analysis.trend === 'BULLISH' ? 'ğŸ“ˆ' : analysis.trend === 'BEARISH' ? 'ğŸ“‰' : 'â¡ï¸';
        const trendType = analysis.trend === 'BULLISH' ? 'success' : analysis.trend === 'BEARISH' ? 'error' : 'warning';
        this.logAnalysis(`${trendEmoji} Xu hÆ°á»›ng: ${analysis.trend}`, trendType);
      }

      if (analysis.indicators.ema20) {
        this.logAnalysis(`ğŸ“Š EMA20: $${analysis.indicators.ema20.toFixed(2)}`, 'info');
      }
      if (analysis.indicators.ema50) {
        this.logAnalysis(`ğŸ“Š EMA50: $${analysis.indicators.ema50.toFixed(2)}`, 'info');
      }
      if (analysis.indicators.rsi) {
        const rsiType = analysis.indicators.rsi > 70 ? 'error' : analysis.indicators.rsi < 30 ? 'success' : 'warning';
        this.logAnalysis(`ğŸ“Š RSI(14): ${analysis.indicators.rsi.toFixed(1)} - ${analysis.strength || 'MEDIUM'}`, rsiType);
      }
      if (analysis.indicators.macd) {
        const macdSignal = analysis.indicators.macd > analysis.indicators.macdSignal ? 'ğŸŸ¢ TÃ­ch cá»±c' : 'ğŸ”´ TiÃªu cá»±c';
        this.logAnalysis(`ğŸ“Š MACD: ${macdSignal}`, 'info');
      }

    } catch (error) {
      console.error('Error updating technical analysis UI:', error);
    }
  },

  async updateNewsSentimentUI() {
    try {
      // Simulate news sentiment
      const sentimentScore = Math.random() * 200 - 100; // -100 to +100
      const sentiment = sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL';

      // Generate fake news headlines
      const headlines = [
        sentimentScore > 0 ? 'ğŸ”¥ Bitcoin rally continues as institutional adoption grows' : 'âš ï¸ Crypto markets face regulatory pressure',
        sentimentScore > 30 ? 'ğŸ’° Major exchange announces new crypto products' : 'ğŸ˜° Market volatility spikes amid uncertainty',
        sentimentScore > 50 ? 'ğŸš€ Bullish momentum building across crypto sector' : 'ğŸ“‰ Risk-off sentiment weighs on digital assets'
      ];

      const impact = Math.abs(sentimentScore) > 60 ? 'HIGH' : Math.abs(sentimentScore) > 30 ? 'MEDIUM' : 'LOW';

      // Update News Sentiment UI
      const newsLog = document.getElementById('newsSentiment');
      if (newsLog) {
        newsLog.innerHTML = ''; // Clear

        // Add sentiment summary
        const sentimentType = sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning';
        const sentimentEmoji = sentiment === 'BULLISH' ? 'ğŸŸ¢' : sentiment === 'BEARISH' ? 'ğŸ”´' : 'ğŸŸ¡';

        this.logNews(`${sentimentEmoji} Tá»•ng quan: ${sentiment} (${sentimentScore.toFixed(0)}/100)`, sentimentType);
        this.logNews(`ğŸ“Š TÃ¡c Ä‘á»™ng: ${impact}`, 'info');
        this.logNews(`â° Cáº­p nháº­t: ${new Date().toLocaleTimeString('vi-VN')}`, 'info');

        // Add headlines to list
        const headlinesList = document.getElementById('headlinesList');
        if (headlinesList) {
          headlinesList.innerHTML = headlines.map((headline) => {
            const emoji = sentimentScore > 0 ? 'ğŸŸ¢' : 'ğŸ”´';
            return `
              <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
                ${emoji} <span style="font-size: 10px;">${headline}</span>
              </div>
            `;
          }).join('');
        }
      }

    } catch (error) {
      console.error('Error updating news sentiment UI:', error);
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UI UPDATE FUNCTIONS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  updateActivePositionsTable() {
    const tbody = document.getElementById('activePositionsTable');
    if (!tbody) return;

    document.getElementById('positionCount').textContent = this.state.positions.length;

    if (this.state.positions.length === 0) {
      tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: var(--text-dim); padding: 20px;">No active positions</td></tr>';
      return;
    }

    tbody.innerHTML = this.state.positions.map(pos => {
      const elapsed = Math.floor((Date.now() - pos.entryTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;

      // Calculate PnL based on actual capital (not leveraged)
      const actualCapital = pos.actualCapital || pos.size;
      const pnlPct = (pos.unrealizedPnL / actualCapital) * 100;

      const marketBadge = pos.marketType === 'FUTURES'
        ? `<span class="badge badge-warning" style="font-size: 10px;">FUTURES ${pos.leverage}x</span>`
        : `<span class="badge badge-success" style="font-size: 10px;">SPOT</span>`;

      return `
        <tr>
          <td><strong>${pos.symbol}</strong><br>${marketBadge}</td>
          <td>$${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}</td>
          <td>$${pos.currentPrice.toFixed(pos.currentPrice < 1 ? 6 : 2)}</td>
          <td>${actualCapital.toFixed(2)}<br><small style="color: var(--text-dim);">${pos.marketType === 'FUTURES' ? '(' + pos.size.toFixed(2) + ' eff.)' : ''}</small></td>
          <td class="${pos.unrealizedPnL >= 0 ? 'text-success' : 'text-danger'}">
            ${(pos.unrealizedPnL >= 0 ? '+' : '')}${pos.unrealizedPnL.toFixed(2)}
          </td>
          <td class="${pnlPct >= 0 ? 'text-success' : 'text-danger'}">
            ${(pnlPct >= 0 ? '+' : '')}${pnlPct.toFixed(2)}%
          </td>
          <td>${minutes}:${seconds.toString().padStart(2, '0')}</td>
          <td>
            <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;"
                    onclick="BybitBot.closePositionByUI('${pos.id}')">âœ• Close</button>
          </td>
        </tr>
      `;
    }).join('');
  },

  updateRiskStatus() {
    // Calculate current drawdown
    const peak = Math.max(this.state.initialBalance, this.state.simMode ? this.state.simBalance : this.state.initialBalance);
    const currentBalance = this.state.simMode ? this.state.simBalance : this.state.initialBalance;
    const currentDD = peak > 0 ? ((peak - currentBalance) / peak) * 100 : 0;

    // Update drawdown UI
    document.getElementById('riskCurrentDD').textContent = currentDD.toFixed(2) + '%';
    const ddPercent = (currentDD / this.state.config.maxDrawdownPercent) * 100;
    const ddBar = document.getElementById('riskDDBar');
    ddBar.style.width = Math.min(100, ddPercent) + '%';
    ddBar.style.background = ddPercent > 80 ? 'var(--danger)' : ddPercent > 50 ? 'var(--warning)' : 'var(--success)';

    // Update daily loss UI
    const dailyLoss = Math.abs(Math.min(0, this.state.dailyStats.pnl));
    document.getElementById('riskDailyLoss').textContent = dailyLoss.toFixed(2) + ' USDT';
    const dailyPercent = (dailyLoss / this.state.config.dailyLossLimit) * 100;
    const dailyBar = document.getElementById('riskDailyBar');
    dailyBar.style.width = Math.min(100, dailyPercent) + '%';
    dailyBar.style.background = dailyPercent > 80 ? 'var(--danger)' : dailyPercent > 50 ? 'var(--warning)' : 'var(--success)';

    // Update positions UI
    document.getElementById('riskActivePos').textContent = this.state.positions.length;
    const posPercent = (this.state.positions.length / this.state.config.maxPositions) * 100;
    const posBar = document.getElementById('riskPosBar');
    posBar.style.width = posPercent + '%';

    // Update risk status
    let status = 'SAFE';
    let statusClass = 'badge-success';
    let message = 'All systems operational';

    if (currentDD > this.state.config.maxDrawdownPercent * 0.8 || dailyPercent > 80) {
      status = 'DANGER';
      statusClass = 'badge-danger';
      message = 'High risk! Close to limits';
    } else if (currentDD > this.state.config.maxDrawdownPercent * 0.5 || dailyPercent > 50) {
      status = 'WARNING';
      statusClass = 'badge-warning';
      message = 'Moderate risk. Be cautious';
    }

    document.getElementById('riskStatus').textContent = status;
    document.getElementById('riskStatus').className = 'badge ' + statusClass;
    document.getElementById('riskMessage').textContent = message;
  },

  updatePerformanceDashboard() {
    const perf = this.performanceCalculator.calculate(this.state.trades);

    document.getElementById('perfTrades').textContent = perf.totalTrades;

    const winRateEl = document.getElementById('perfWinRate');
    winRateEl.textContent = perf.winRate + '%';
    winRateEl.className = parseFloat(perf.winRate) >= 50 ? 'text-success' : 'text-danger';

    const pfEl = document.getElementById('perfProfitFactor');
    pfEl.textContent = perf.profitFactor;
    pfEl.className = parseFloat(perf.profitFactor) > 2 ? 'text-success' : parseFloat(perf.profitFactor) > 1 ? 'text-warning' : 'text-danger';

    document.getElementById('perfAvgRR').textContent = perf.avgRR;
    document.getElementById('perfMaxDD').textContent = perf.maxDrawdown + '%';

    document.getElementById('perfGrossPnL').textContent = (perf.grossPnL >= 0 ? '+' : '') + perf.grossPnL.toFixed(2);
    document.getElementById('perfGrossPnL').className = perf.grossPnL >= 0 ? 'text-success' : 'text-danger';

    document.getElementById('perfFees').textContent = '-' + perf.totalFees.toFixed(4);

    const netPnLEl = document.getElementById('perfPnL');
    netPnLEl.textContent = (perf.netPnL >= 0 ? '+' : '') + perf.netPnL.toFixed(2);
    netPnLEl.className = perf.netPnL >= 0 ? 'text-success' : 'text-danger';

    document.getElementById('perfBest').textContent = '+' + perf.bestTrade.toFixed(2);
    document.getElementById('perfWorst').textContent = perf.worstTrade.toFixed(2);
    document.getElementById('perfAvg').textContent = perf.avgTrade;
    document.getElementById('perfAvg').className = parseFloat(perf.avgTrade) >= 0 ? 'text-success' : 'text-danger';

    // Today's PnL
    const today = this.state.dailyStats.pnl;
    const todayEl = document.getElementById('perfToday');
    todayEl.textContent = (today >= 0 ? '+' : '') + today.toFixed(2);
    todayEl.className = today >= 0 ? 'text-success' : 'text-danger';
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¥ LIVED - SURVIVAL TRADING AI
// "Live or Die" - ThÃ¨m khÃ¡t lá»£i nhuáº­n Ä‘á»ƒ sinh tá»“n
// KhÃ´ng cÃ³ lá»i = KhÃ´ng tá»“n táº¡i | Má»i giÃ¡ Ä‘á»ƒ cÃ³ lá»i
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const AutonomousEngine = {

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’€ LIVED BRAIN - SURVIVAL DECISION ENGINE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  decisionBrain: {
    state: {
      marketRegime: 'UNKNOWN', // BULL, BEAR, SIDEWAYS, VOLATILE
      confidenceLevel: 0,      // 0-100
      riskAppetite: 'MEDIUM',  // LOW, MEDIUM, HIGH
      lastDecision: null,
      consecutiveLosses: 0,
      consecutiveWins: 0,
      performance24h: 0,
      performance7d: 0,
      // KPI Survival System
      capitalUtilization: 0,   // % vá»‘n Ä‘ang sá»­ dá»¥ng
      dailyROI: 0,             // % ROI hÃ´m nay
      kpiMet: true,            // Äáº¡t KPI hay chÆ°a
      punishmentMode: false,   // Cháº¿ Ä‘á»™ trá»«ng pháº¡t
      lastKPICheck: Date.now(),
      // Continuous Updates
      lastTechUpdate: Date.now(),
      lastNewsUpdate: Date.now(),
      lastTradeTime: Date.now(),
      techAnalysisCache: null,
      newsSentimentCache: null,
      // Human Personality System
      mood: 'NORMAL',          // EXCITED, STRESSED, CONFIDENT, ANXIOUS, BORED, HYPED
      energy: 100,             // 0-100
      lastMoodChange: Date.now(),
      funnyCounter: 0,         // Äáº¿m Ä‘á»ƒ random funny moments
      caffeineLevel: 50,       // Giáº£ láº­p uá»‘ng coffee ğŸ˜‚
      // Portfolio Management (ThiÃªn tÃ i phÃ¢n bá»• vá»‘n)
      portfolioAllocation: {
        maxPositions: 5,
        targetCapitalPerPosition: 20,  // % vá»‘n cho má»—i position (100/5 = 20%)
        minCapitalPerPosition: 10,     // Min 10%
        maxCapitalPerPosition: 35,     // Max 35% (náº¿u confidence cao)
        diversificationBonus: 0,       // Bonus cho diversification
        lastRebalance: Date.now()
      }
    },

    // QUY TRÃŒNH QUYáº¾T Äá»ŠNH CHÃNH
    async makeDecision() {
      try {
        // Check KPI SURVIVAL first
        this.checkKPISurvival();
        
        // Update mood & energy
        this.updateMoodAndEnergy();
        
        // Random funny moments
        this.randomFunnyMoment();
        
        BybitBot.log('ğŸ’€ LIVED: SÄƒn lÃ¹ng cÆ¡ há»™i...', 'warning');

        // BÆ¯á»šC 1: PhÃ¢n tÃ­ch thá»‹ trÆ°á»ng
        const marketAnalysis = await this.analyzeMarket();
        // BÆ¯á»šC 2: ÄÃ¡nh giÃ¡ risk hiá»‡n táº¡i
        const riskAssessment = this.assessRisk();
        // BÆ¯á»šC 3: Kiá»ƒm tra performance gáº§n Ä‘Ã¢y
        const performanceReview = this.reviewPerformance();
        // BÆ¯á»šC 4: Quyáº¿t Ä‘á»‹nh hÃ nh Ä‘á»™ng
        const decision = this.decide(marketAnalysis, riskAssessment, performanceReview);
        // BÆ¯á»šC 5: Thá»±c thi quyáº¿t Ä‘á»‹nh
        await this.executeDecision(decision);
        // BÆ¯á»šC 6: Há»c tá»« káº¿t quáº£
        this.learnFromOutcome(decision);
        this.state.lastDecision = decision;

        return decision;
      } catch (error) {
        console.error('âŒ Decision Engine Error:', error);
        console.error('âŒ Error stack:', error.stack);
        BybitBot.log(`âŒ Decision error: ${error.message}`, 'error');

        // Return safe default decision
        return {
          action: 'WAIT',
          reason: 'Error in decision process: ' + error.message,
          parameters: {},
          confidence: 0
        };
      }
    },

    async analyzeMarket() {
      try {
        BybitBot.log('ğŸ” LIVED: PhÃ¢n tÃ­ch thá»‹ trÆ°á»ng Ä‘á»ƒ sinh tá»“n...', 'info');

        // Láº¥y data tá»« multiple timeframes
        const data5m = await this.getMarketData('5');
        const data15m = await this.getMarketData('15');
        const data1h = await this.getMarketData('60');
        // Safety check
        if (!data5m || !data15m || !data1h) {
          console.error('âŒ Market data incomplete!');
          throw new Error('Failed to get market data');
        }

        // PhÃ¢n tÃ­ch trend
        const trend = this.analyzeTrend([data5m, data15m, data1h]);
        // PhÃ¢n tÃ­ch volatility
        const volatility = this.analyzeVolatility(data5m);
        // PhÃ¢n tÃ­ch volume
        const volumeProfile = this.analyzeVolume(data5m);
        // PhÃ¢n tÃ­ch news sentiment
        const newsSentiment = this.analyzeNewsSentiment();
        // Tá»•ng há»£p Ä‘á»ƒ xÃ¡c Ä‘á»‹nh market regime
        this.state.marketRegime = this.determineMarketRegime(trend, volatility, volumeProfile);

        // TÃ­nh confidence level
        this.state.confidenceLevel = this.calculateConfidence(trend, volatility, volumeProfile, newsSentiment);

        BybitBot.log(`ğŸ“ˆ Regime: ${this.state.marketRegime} - ${trend.direction === 'BULLISH' ? 'ğŸ”¥ CÆ  Há»˜I!' : 'âš ï¸ Nguy hiá»ƒm'}`, trend.direction === 'BULLISH' ? 'success' : 'warning');
        BybitBot.log(`ğŸ’¯ Äá»™ cháº¯c cháº¯n: ${this.state.confidenceLevel}% ${this.state.confidenceLevel > 70 ? '- Äá»¦ Äá»‚ SÄ‚NNNN!' : '- ChÆ°a Ä‘á»§, Ä‘á»£i thÃªm...'}`, this.state.confidenceLevel > 70 ? 'success' : 'warning');

        return {
          regime: this.state.marketRegime,
          trend,
          volatility,
          volumeProfile,
          newsSentiment,
          confidence: this.state.confidenceLevel
        };
      } catch (error) {
        console.error('âŒ Error in analyzeMarket:', error);
        console.error('âŒ Stack:', error.stack);
        throw error; // Re-throw Ä‘á»ƒ makeDecision() catch
      }
    },

    getMarketData(timeframe) {
      // Simulate market data (in production, fetch from API)
      const candles = [];
      let price = 50000;

      for (let i = 0; i < 100; i++) {
        const change = (Math.random() - 0.48) * 200; // Slight uptrend bias
        price = Math.max(price + change, 10000);

        candles.push({
          time: Date.now() - (100 - i) * 5 * 60 * 1000,
          open: price,
          high: price * (1 + Math.random() * 0.01),
          low: price * (1 - Math.random() * 0.01),
          close: price,
          volume: Math.random() * 1000000
        });
      }

      return { timeframe, candles };
    },

    analyzeTrend(dataArray) {
      try {
        // Safety check
        if (!dataArray || !Array.isArray(dataArray) || dataArray.length === 0) {
          console.error('âŒ dataArray invalid:', dataArray);
          throw new Error('Invalid dataArray in analyzeTrend');
        }
        // Multi-timeframe trend analysis
        const trends = dataArray.map((data, index) => {
          if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
            console.error(`âŒ Invalid data at index ${index}:`, data);
            throw new Error(`Invalid data at index ${index}`);
          }
          // Safe access to close prices
          const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
          if (closes.length === 0) {
            console.error(`âŒ No valid closes at index ${index}`);
            throw new Error(`No valid closes at index ${index}`);
          }

        // Safety check: ensure technicalAnalysis exists
        if (!BybitBot.technicalAnalysis || !BybitBot.technicalAnalysis.ema) {
          console.warn('âš ï¸ technicalAnalysis.ema not available, using simple trend');
          const lastPrice = closes[closes.length - 1];
          const prevPrice = closes[closes.length - 10] || closes[0];
          return {
            timeframe: data.timeframe,
            direction: lastPrice > prevPrice ? 'BULLISH' : 'BEARISH',
            strength: Math.abs((lastPrice - prevPrice) / prevPrice) * 100,
            ema20vsEma50: lastPrice > prevPrice
          };
        }

        const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
        const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);

        // Safety check: ensure EMAs are valid
        if (!ema20 || !ema50 || ema20.length === 0 || ema50.length === 0) {
          console.warn('âš ï¸ EMA calculation failed, using simple trend');
          const lastPrice = closes[closes.length - 1];
          const prevPrice = closes[closes.length - 10] || closes[0];
          return {
            timeframe: data.timeframe,
            direction: lastPrice > prevPrice ? 'BULLISH' : 'BEARISH',
            strength: Math.abs((lastPrice - prevPrice) / prevPrice) * 100,
            ema20vsEma50: lastPrice > prevPrice
          };
        }

        const current = ema20[ema20.length - 1];
        const previous = ema20[ema20.length - 10] || ema20[0];
        const ema50Current = ema50[ema50.length - 1];

        return {
          timeframe: data.timeframe,
          direction: current > ema50Current ? 'BULLISH' : 'BEARISH',
          strength: Math.abs((current - previous) / previous) * 100,
          ema20vsEma50: current > ema50Current
        };
      });

      // Tá»•ng há»£p: Náº¿u majority bullish â†’ BULLISH
      const bullishCount = trends.filter(t => t.direction === 'BULLISH').length;
      const overallDirection = bullishCount >= 2 ? 'BULLISH' : 'BEARISH';
      const avgStrength = trends.reduce((sum, t) => sum + t.strength, 0) / trends.length;
      return {
        direction: overallDirection,
        strength: avgStrength,
        alignment: bullishCount === trends.length, // All timeframes agree?
        details: trends
      };
      } catch (error) {
        console.error('âŒ Error in analyzeTrend:', error);
        console.error('âŒ Stack:', error.stack);
        // Return safe fallback
        return {
          direction: 'BULLISH',
          strength: 1,
          alignment: false,
          details: []
        };
      }
    },

    analyzeVolatility(data) {
      try {
        // Safety check: ensure data is valid
        if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
          console.error('âŒ Invalid data in analyzeVolatility:', data);
          return {
            atr: 0,
            atrPct: '0.00',
            level: 'NORMAL'
          };
        }

        // Safe access to close prices
        const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
        if (closes.length === 0) {
          return {
            atr: 0,
            atrPct: '0.00',
            level: 'NORMAL'
          };
        }
        const avgPrice = closes.reduce((a, b) => a + b, 0) / closes.length;

        // Safety check: ensure technicalAnalysis.atr exists
      if (!BybitBot.technicalAnalysis || !BybitBot.technicalAnalysis.atr) {
        console.warn('âš ï¸ technicalAnalysis.atr not available, using simple volatility');
        // Simple volatility: standard deviation
        const variance = closes.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / closes.length;
        const stdDev = Math.sqrt(variance);
        const atrPct = (stdDev / avgPrice) * 100;

        let level = 'NORMAL';
        if (atrPct < 1) level = 'LOW';
        else if (atrPct < 2) level = 'NORMAL';
        else if (atrPct < 4) level = 'HIGH';
        else level = 'EXTREME';

        return {
          atr: stdDev,
          atrPct: atrPct.toFixed(2),
          level
        };
      }

      const atr = BybitBot.technicalAnalysis.atr(data.candles, 14);

      // Safety check: ensure ATR is valid
      if (!atr || atr.length === 0) {
        console.warn('âš ï¸ ATR calculation failed, using simple volatility');
        const variance = closes.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / closes.length;
        const stdDev = Math.sqrt(variance);
        const atrPct = (stdDev / avgPrice) * 100;

        let level = 'NORMAL';
        if (atrPct < 1) level = 'LOW';
        else if (atrPct < 2) level = 'NORMAL';
        else if (atrPct < 4) level = 'HIGH';
        else level = 'EXTREME';

        return {
          atr: stdDev,
          atrPct: atrPct.toFixed(2),
          level
        };
      }

      const currentATR = atr[atr.length - 1];
      const atrPct = (currentATR / avgPrice) * 100;

      let level = 'NORMAL';
      if (atrPct < 1) level = 'LOW';
      else if (atrPct < 2) level = 'NORMAL';
      else if (atrPct < 4) level = 'HIGH';
      else level = 'EXTREME';

      return {
        atr: currentATR,
        atrPct: atrPct.toFixed(2),
        level
      };
      } catch (error) {
        console.error('âŒ Error in analyzeVolatility:', error);
        return {
          atr: 0,
          atrPct: '0.00',
          level: 'NORMAL'
        };
      }
    },

    analyzeVolume(data) {
      try {
        // Safety check: ensure data is valid
        if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
          console.error('âŒ Invalid data in analyzeVolume:', data);
          return {
            avgVolume: 0,
            recentVolume: 0,
            ratio: '1.00',
            increasing: false,
            decreasing: false
          };
        }

        // Safe access to volumes
        const volumes = data.candles.filter(c => c && typeof c.volume === 'number').map(c => c.volume);
        if (volumes.length === 0) {
          return {
            avgVolume: 0,
            recentVolume: 0,
            ratio: '1.00',
            increasing: false,
            decreasing: false
          };
        }
        const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
      const recentVolume = volumes.slice(-10).reduce((a, b) => a + b, 0) / 10;
      const volumeRatio = recentVolume / avgVolume;

      return {
        avgVolume,
        recentVolume,
        ratio: volumeRatio.toFixed(2),
        increasing: volumeRatio > 1.2,
        decreasing: volumeRatio < 0.8
      };
      } catch (error) {
        console.error('âŒ Error in analyzeVolume:', error);
        return {
          avgVolume: 0,
          recentVolume: 0,
          ratio: '1.00',
          increasing: false,
          decreasing: false
        };
      }
    },

    analyzeNewsSentiment() {
      // Simulate news sentiment
      const sentimentScore = Math.random() * 200 - 100; // -100 to +100

      return {
        score: sentimentScore.toFixed(0),
        sentiment: sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL'
      };
    },

    determineMarketRegime(trend, volatility, volumeProfile) {
      if (trend.direction === 'BULLISH' && volatility.level !== 'EXTREME') {
        return 'BULL';
      } else if (trend.direction === 'BEARISH' && volatility.level !== 'EXTREME') {
        return 'BEAR';
      } else if (volatility.level === 'EXTREME') {
        return 'VOLATILE';
      } else {
        return 'SIDEWAYS';
      }
    },

    calculateConfidence(trend, volatility, volumeProfile, newsSentiment) {
      let confidence = 50; // Base confidence

      // Trend alignment
      if (trend.alignment) confidence += 20;

      // Trend strength
      confidence += Math.min(trend.strength * 5, 15);

      // Volatility (moderate is good)
      if (volatility.level === 'NORMAL' || volatility.level === 'HIGH') confidence += 10;

      // Volume confirmation
      if (volumeProfile.increasing) confidence += 10;

      // News sentiment alignment
      if ((trend.direction === 'BULLISH' && newsSentiment.sentiment === 'BULLISH') ||
          (trend.direction === 'BEARISH' && newsSentiment.sentiment === 'BEARISH')) {
        confidence += 15;
      }

      return Math.min(Math.max(confidence, 0), 100);
    },

    assessRisk() {
      BybitBot.log('âš”ï¸ LIVED: ÄÃ¡nh giÃ¡ rá»§i ro - NhÆ°ng tÃ´i khÃ´ng sá»£ cháº¿t!', 'warning');

      // Safety checks for state objects
      if (!BybitBot.state || !BybitBot.state.config) {
        console.warn('âš ï¸ BybitBot.state or config not available');
        return {
          level: 'UNKNOWN',
          appetite: 'MEDIUM',
          drawdown: 0,
          dailyLoss: 0,
          activePositions: 0,
          canOpenPosition: false
        };
      }

      const currentDD = this.calculateCurrentDrawdown();
      const dailyLoss = Math.abs(Math.min(0, BybitBot.state.dailyStats?.pnl || 0));
      const activePositions = BybitBot.state.positions?.length || 0;
      const maxPositions = BybitBot.state.config.maxPositions || 5;

      // Risk factors
      const ddRisk = currentDD / (BybitBot.state.config.maxDrawdownPercent || 30);
      const dailyLossRisk = dailyLoss / (BybitBot.state.config.dailyLossLimit || 200);
      const positionRisk = maxPositions > 0 ? activePositions / maxPositions : 0;

      const overallRisk = (ddRisk + dailyLossRisk + positionRisk) / 3;

      let riskLevel = 'LOW';
      if (overallRisk > 0.8) riskLevel = 'EXTREME';
      else if (overallRisk > 0.6) riskLevel = 'HIGH';
      else if (overallRisk > 0.4) riskLevel = 'MEDIUM';

      // Adjust risk appetite based on consecutive results
      if (this.state.consecutiveLosses >= 3) {
        this.state.riskAppetite = 'LOW';
      } else if (this.state.consecutiveWins >= 5) {
        this.state.riskAppetite = 'HIGH';
      } else {
        this.state.riskAppetite = 'MEDIUM';
      }

      BybitBot.log(`âš”ï¸ Risk: ${riskLevel} | ThÃ¨m khÃ¡t: ${this.state.riskAppetite} ${riskLevel === 'EXTREME' ? '- TOI KHÃ”NG QUAN TÃ‚M, PHáº¢I CÃ“ Lá»œI!' : '- OK!'}`,
                   riskLevel === 'LOW' ? 'success' : riskLevel === 'HIGH' ? 'warning' : 'error');

      return {
        level: riskLevel,
        appetite: this.state.riskAppetite,
        drawdown: currentDD,
        dailyLoss,
        activePositions,
        canOpenPosition: riskLevel !== 'EXTREME' && activePositions < maxPositions
      };
    },

    calculateCurrentDrawdown() {
      // Safety check
      if (!BybitBot.state) {
        console.warn('âš ï¸ BybitBot.state not available');
        return 0;
      }

      const initialBalance = BybitBot.state.initialBalance || 1000;
      const simBalance = BybitBot.state.simBalance || initialBalance;
      const simMode = BybitBot.state.simMode || false;

      const peak = Math.max(initialBalance, simMode ? simBalance : initialBalance);
      const current = simMode ? simBalance : initialBalance;
      return peak > 0 ? ((peak - current) / peak) * 100 : 0;
    },

    reviewPerformance() {
      BybitBot.log('ğŸ“ˆ Reviewing recent performance...', 'info');

      // Safety check
      if (!BybitBot.state || !BybitBot.state.trades) {
        console.warn('âš ï¸ BybitBot.state.trades not available');
        return {
          trades24h: 0,
          trades7d: 0,
          pnl24h: 0,
          pnl7d: 0,
          recent: 'NEUTRAL',
          recommendation: 'START_CAREFULLY'
        };
      }

      const trades = BybitBot.state.trades;
      if (trades.length === 0) {
        return {
          trades24h: 0,
          trades7d: 0,
          pnl24h: 0,
          pnl7d: 0,
          recent: 'NEUTRAL',
          recommendation: 'START_CAREFULLY'
        };
      }

      // Last 24h trades
      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
      const trades24h = trades.filter(t => new Date(t.time).getTime() > oneDayAgo);

      // Last 7 days trades
      const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
      const trades7d = trades.filter(t => new Date(t.time).getTime() > sevenDaysAgo);

      const pnl24h = trades24h.reduce((sum, t) => sum + t.pnl, 0);
      const pnl7d = trades7d.reduce((sum, t) => sum + t.pnl, 0);

      this.state.performance24h = pnl24h;
      this.state.performance7d = pnl7d;

      let recommendation = 'CONTINUE';
      if (pnl24h < -100) recommendation = 'REDUCE_RISK';
      else if (pnl24h > 100) recommendation = 'INCREASE_OPPORTUNITY';

      BybitBot.log(`ğŸ’° Performance: 24h: ${pnl24h.toFixed(2)} | 7d: ${pnl7d.toFixed(2)}`,
                   pnl24h >= 0 ? 'success' : 'error');

      return {
        trades24h: trades24h.length,
        trades7d: trades7d.length,
        pnl24h,
        pnl7d,
        recommendation
      };
    },

    decide(marketAnalysis, riskAssessment, performanceReview) {
      BybitBot.log('ğŸ§® LIVED: TÃ­nh toÃ¡n xÃ¡c suáº¥t... NhÆ° má»™t báº­c tháº§y toÃ¡n há»c!', 'info');

      const decision = {
        action: 'WAIT',
        reason: '',
        parameters: {},
        confidence: 0
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ§® TÃNH TOÃN DESPERATE MODE (Báº­c tháº§y toÃ¡n há»c)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const timeSinceLastTrade = Date.now() - this.state.lastTradeTime;
      const minutesSinceLastTrade = timeSinceLastTrade / 1000 / 60;
      const hoursSinceLastTrade = minutesSinceLastTrade / 60;
      
      // TÃ­nh toÃ¡n threshold Ä‘á»™ng dá»±a trÃªn nhiá»u yáº¿u tá»‘
      let minConfidence = 60; // Base threshold
      let desperateLevel = 0; // 0-100, cÃ ng cao cÃ ng desperate
      let sizeMultiplier = 1.0; // Äiá»u chá»‰nh size
      
      // FACTOR 1: Punishment Mode (KPI khÃ´ng Ä‘áº¡t)
      if (this.state.punishmentMode) {
        desperateLevel += 30;
        minConfidence -= 15; // 60 â†’ 45
        BybitBot.log('âš¡ PUNISHMENT MODE: Bá»‹ chÃ­ch Ä‘iá»‡n! Pháº£i trade!', 'error');
        BybitBot.log('ğŸ“ ToÃ¡n há»c: P(survival) = f(trades) â†’ MIN confidence = 45%', 'warning');
      }
      
      // FACTOR 2: Capital Utilization quÃ¡ tháº¥p
      if (this.state.capitalUtilization < 30) {
        const capitalFactor = (30 - this.state.capitalUtilization) / 30; // 0-1
        desperateLevel += capitalFactor * 25;
        minConfidence -= capitalFactor * 10; // Giáº£m tá»‘i Ä‘a 10%
        BybitBot.log(`ğŸ’° Capital Use: ${this.state.capitalUtilization.toFixed(1)}% < 30%`, 'warning');
        BybitBot.log(`ğŸ“Š ToÃ¡n há»c: Î”Confidence = -${(capitalFactor * 10).toFixed(1)}%`, 'info');
      }
      
      // FACTOR 3: Thá»i gian chÆ°a trade (giáº£m theo logarit Ä‘á»ƒ trÃ¡nh quÃ¡ liá»u)
      if (minutesSinceLastTrade > 15) {
        const timeFactor = Math.min(1, Math.log10(minutesSinceLastTrade / 15)); // 0-1
        desperateLevel += timeFactor * 35;
        minConfidence -= timeFactor * 20; // Giáº£m tá»‘i Ä‘a 20%
        BybitBot.log(`â° LÃ¢u rá»“i khÃ´ng trade: ${minutesSinceLastTrade.toFixed(0)} phÃºt`, 'warning');
        BybitBot.log(`ğŸ“ˆ ToÃ¡n há»c: logâ‚â‚€(t/15) = ${timeFactor.toFixed(2)} â†’ -${(timeFactor * 20).toFixed(1)}%`, 'info');
      }
      
      // FACTOR 4: Daily ROI quÃ¡ tháº¥p
      if (this.state.dailyROI < 2) {
        const roiFactor = (2 - this.state.dailyROI) / 2; // 0-1
        desperateLevel += roiFactor * 15;
        minConfidence -= roiFactor * 8;
        BybitBot.log(`ğŸ’¸ Daily ROI: ${this.state.dailyROI.toFixed(2)}% < 2%`, 'warning');
      }
      
      // Giá»›i háº¡n threshold tá»‘i thiá»ƒu = 25% (khÃ´ng xuá»‘ng quÃ¡ tháº¥p)
      minConfidence = Math.max(25, Math.min(60, minConfidence));
      desperateLevel = Math.min(100, desperateLevel);
      
      // TÃ­nh size multiplier (cÃ ng desperate cÃ ng giáº£m size Ä‘á»ƒ an toÃ n)
      if (desperateLevel > 50) {
        sizeMultiplier = 0.4 + (0.6 * (1 - desperateLevel / 100)); // 0.4 - 1.0
        BybitBot.log(`ğŸ¯ Desperate Level: ${desperateLevel.toFixed(0)}/100`, 'error');
        BybitBot.log(`ğŸ“‰ Size Multiplier: ${(sizeMultiplier * 100).toFixed(0)}% (báº£o toÃ n vá»‘n!)`, 'warning');
      }
      
      BybitBot.log(`ğŸ§® PHÃ‰P TÃNH: Confidence cáº§n >= ${minConfidence.toFixed(1)}% (Base: 60%)`, 
                   minConfidence < 50 ? 'error' : 'warning');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUYáº¾T Äá»ŠNH 1: CÃ³ nÃªn trade khÃ´ng?
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!riskAssessment.canOpenPosition) {
        decision.action = 'WAIT';
        decision.reason = 'Risk too high or max positions reached';
        decision.confidence = 0;
        BybitBot.log('ğŸ›‘ ToÃ¡n há»c: Risk > Threshold â†’ WAIT (Safety first!)', 'error');
        return decision;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUYáº¾T Äá»ŠNH 2: NÃªn giáº£m risk khÃ´ng?
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (performanceReview.recommendation === 'REDUCE_RISK') {
        decision.action = 'REDUCE_RISK';
        decision.reason = 'Recent losses detected, reducing exposure';
        decision.parameters = {
          newPositionSize: BybitBot.state.config.positionSize * 0.5,
          newRiskPerTrade: BybitBot.state.config.riskPerTrade * 0.5
        };
        BybitBot.log('ğŸ“ ToÃ¡n há»c: Loss streak â†’ Size Ã· 2 (Báº£o toÃ n vá»‘n)', 'warning');
        return decision;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUYáº¾T Äá»ŠNH 3: Market regime phÃ¹ há»£p?
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (marketAnalysis.regime === 'VOLATILE' && riskAssessment.appetite !== 'HIGH' && desperateLevel < 60) {
        decision.action = 'WAIT';
        decision.reason = 'Market too volatile for current risk appetite';
        BybitBot.log('âš ï¸ ToÃ¡n há»c: Ïƒ (volatility) quÃ¡ cao â†’ Chá» á»•n Ä‘á»‹nh!', 'warning');
        return decision;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUYáº¾T Äá»ŠNH 4: Confidence check vá»›i DYNAMIC THRESHOLD
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (marketAnalysis.confidence < minConfidence) {
        decision.action = 'WAIT';
        decision.reason = `Confidence ${marketAnalysis.confidence.toFixed(1)}% < ${minConfidence.toFixed(1)}% (calculated threshold)`;
        BybitBot.log(`ğŸ“Š ToÃ¡n há»c: ${marketAnalysis.confidence.toFixed(1)}% < ${minConfidence.toFixed(1)}% â†’ ChÆ°a Ä‘á»§!`, 'warning');
        return decision;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // QUYáº¾T Äá»ŠNH 5: TRADE! (Vá»›i tÃ­nh toÃ¡n chÃ­nh xÃ¡c)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      BybitBot.log('', 'info');
      BybitBot.log('ğŸ¯ QUYáº¾T Äá»ŠNH: VÃ€O Lá»†NH!', 'success');
      BybitBot.log(`ğŸ§® ToÃ¡n há»c: Confidence ${marketAnalysis.confidence.toFixed(1)}% >= ${minConfidence.toFixed(1)}%`, 'success');
      
      // Determine direction based on regime and confidence
      if (marketAnalysis.regime === 'BULL' && marketAnalysis.confidence >= Math.max(minConfidence, 65)) {
        decision.action = 'OPEN_LONG';
        decision.reason = `ğŸ§® Bullish + Confidence ${marketAnalysis.confidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier;
        BybitBot.log(`ğŸ“ˆ Direction: LONG (Bull market)`, 'success');
      } else if (marketAnalysis.regime === 'BEAR' && marketAnalysis.confidence >= Math.max(minConfidence, 65)) {
        decision.action = 'OPEN_SHORT';
        decision.reason = `ğŸ§® Bearish + Confidence ${marketAnalysis.confidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier;
        BybitBot.log(`ğŸ“‰ Direction: SHORT (Bear market)`, 'error');
      } else {
        // Desperate entry - confidence Ä‘á»§ nhÆ°ng khÃ´ng cÃ³ regime rÃµ rÃ ng
        decision.action = 'OPEN_LONG';
        decision.reason = `ğŸ§® Desperate Entry: Conf ${marketAnalysis.confidence.toFixed(1)}% >= ${minConfidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier * 0.7; // Extra safety
        BybitBot.log(`âš¡ Direction: LONG (Desperate/Conservative)`, 'warning');
        BybitBot.log(`ğŸ›¡ï¸ Size giáº£m thÃªm 30% Ä‘á»ƒ an toÃ n! (Size Ã— ${(sizeMultiplier * 0.7).toFixed(2)})`, 'info');
      }
      
      BybitBot.log(`ğŸ’° Final Size: ${decision.parameters.size.toFixed(2)} USDT`, 'info');
      BybitBot.log(`ğŸ² P(success) â‰ˆ ${decision.confidence.toFixed(1)}%`, 'info');
      BybitBot.log('', 'info');

      return decision;
    },

    calculateOptimalParameters(marketAnalysis, riskAssessment) {
      // Safety check
      if (!BybitBot.state || !BybitBot.state.config) {
        console.warn('âš ï¸ BybitBot.state.config not available, using defaults');
        return {
          size: 100,
          risk: 2,
          leverage: 5,
          tp: 1.5,
          sl: 0.8,
          trailingStop: true
        };
      }

      BybitBot.log('', 'info');
      BybitBot.log('ğŸ’¼ â•â•â• PORTFOLIO ALLOCATION - THIÃŠN TÃ€I PHÃ‚N Bá»” Vá»N â•â•â•', 'success');
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ’¼ PORTFOLIO MANAGEMENT - SMART CAPITAL ALLOCATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const totalCapital = BybitBot.state.simMode ? BybitBot.state.simBalance : 1000;
      const currentPositions = BybitBot.state.positions?.length || 0;
      const maxPositions = this.state.portfolioAllocation.maxPositions;
      
      // Calculate capital already allocated
      let allocatedCapital = 0;
      if (BybitBot.state.positions && BybitBot.state.positions.length > 0) {
        allocatedCapital = BybitBot.state.positions.reduce((sum, pos) => sum + pos.size, 0);
      }
      const availableCapital = totalCapital - allocatedCapital;
      
      BybitBot.log(`ğŸ’° Total Capital: $${totalCapital.toFixed(2)}`, 'info');
      BybitBot.log(`ğŸ“Š Positions: ${currentPositions}/${maxPositions}`, 'info');
      BybitBot.log(`ğŸ”’ Allocated: $${allocatedCapital.toFixed(2)} (${(allocatedCapital/totalCapital*100).toFixed(1)}%)`, 'warning');
      BybitBot.log(`ğŸ’µ Available: $${availableCapital.toFixed(2)} (${(availableCapital/totalCapital*100).toFixed(1)}%)`, 'success');
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“ KELLY CRITERION + MODERN PORTFOLIO THEORY
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // Remaining positions we can open
      const remainingSlots = maxPositions - currentPositions;
      
      // Target allocation per position (equal weight by default)
      let targetAllocation = this.state.portfolioAllocation.targetCapitalPerPosition / 100; // 20% = 0.20
      
      // Adjust based on confidence (High confidence = more allocation)
      if (marketAnalysis.confidence >= 80) {
        targetAllocation *= 1.5; // Up to 30%
        BybitBot.log(`ğŸ¯ High Confidence (${marketAnalysis.confidence}%) â†’ +50% allocation`, 'success');
      } else if (marketAnalysis.confidence >= 70) {
        targetAllocation *= 1.2; // Up to 24%
        BybitBot.log(`ğŸ“ˆ Good Confidence (${marketAnalysis.confidence}%) â†’ +20% allocation`, 'info');
      } else if (marketAnalysis.confidence < 50) {
        targetAllocation *= 0.7; // Down to 14%
        BybitBot.log(`âš ï¸ Low Confidence (${marketAnalysis.confidence}%) â†’ -30% allocation`, 'warning');
      }
      
      // Adjust for remaining slots (if few slots left, be more conservative)
      if (remainingSlots <= 2) {
        targetAllocation *= 0.8; // Reserve capital for future opportunities
        BybitBot.log(`ğŸ° Few slots left (${remainingSlots}) â†’ -20% allocation (preserve capital)`, 'warning');
      }
      
      // Adjust for market regime (VOLATILE = smaller positions)
      if (marketAnalysis.regime === 'VOLATILE') {
        targetAllocation *= 0.7;
        BybitBot.log(`ğŸ’¥ Volatile market â†’ -30% allocation (risk management)`, 'warning');
      }
      
      // Calculate actual size
      let calculatedSize = totalCapital * targetAllocation;
      
      // Cap by available capital
      calculatedSize = Math.min(calculatedSize, availableCapital * 0.8); // Max 80% of available
      
      // Apply min/max limits
      const minSize = (totalCapital * this.state.portfolioAllocation.minCapitalPerPosition / 100);
      const maxSize = (totalCapital * this.state.portfolioAllocation.maxCapitalPerPosition / 100);
      calculatedSize = Math.max(minSize, Math.min(maxSize, calculatedSize));
      
      BybitBot.log(``, 'info');
      BybitBot.log(`ğŸ“ Kelly Formula: Optimal = ${(targetAllocation * 100).toFixed(1)}%`, 'info');
      BybitBot.log(`ğŸ’µ Calculated Size: $${calculatedSize.toFixed(2)} (${(calculatedSize/totalCapital*100).toFixed(1)}% of capital)`, 'success');
      BybitBot.log(`ğŸ“ Limits: Min $${minSize.toFixed(2)} | Max $${maxSize.toFixed(2)}`, 'info');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ¯ DIVERSIFICATION BONUS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // If we have good diversification (multiple positions), slightly increase confidence
      if (currentPositions >= 3) {
        this.state.portfolioAllocation.diversificationBonus = 5;
        BybitBot.log(`ğŸŒˆ Diversification bonus: Portfolio has ${currentPositions} positions â†’ +5% confidence!`, 'success');
      } else {
        this.state.portfolioAllocation.diversificationBonus = 0;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“Š RISK & REWARD PARAMETERS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      const baseRisk = BybitBot.state.config.riskPerTrade || 2;
      let risk = baseRisk;
      let leverage = 1;
      let tp = 1.5;
      let sl = 0.8;

      // Adjust based on risk appetite
      if (riskAssessment.appetite === 'LOW') {
        risk *= 0.5;
        leverage = 1;
        tp = 0.8;
        sl = 0.5;
      } else if (riskAssessment.appetite === 'HIGH') {
        risk *= 1.5;
        leverage = 15;
        tp = 1.0;
        sl = 1.0;
      } else {
        leverage = 10;
      }

      // Adjust based on volatility
      if (marketAnalysis.volatility.level === 'HIGH') {
        tp = 2.0;
        sl = 1.2;
      } else if (marketAnalysis.volatility.level === 'LOW') {
        tp = 0.8;
        sl = 0.5;
      }
      
      BybitBot.log(``, 'info');
      BybitBot.log(`âš–ï¸ Risk Parameters:`, 'info');
      BybitBot.log(`   ğŸ“Š Risk: ${risk.toFixed(2)}%`, 'info');
      BybitBot.log(`   ğŸ“ˆ Leverage: ${leverage}x`, 'info');
      BybitBot.log(`   ğŸ¯ TP: ${tp}% | SL: ${sl}%`, 'info');
      BybitBot.log(`ğŸ’¼ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, 'success');
      BybitBot.log('', 'info');

      return {
        size: calculatedSize,
        risk: Math.min(risk, baseRisk * 2),
        leverage: Math.min(leverage, 20),
        tp,
        sl,
        trailingStop: true
      };
    },

    async executeDecision(decision) {
      BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      BybitBot.log(`ğŸ’€ LIVED QUYáº¾T Äá»ŠNH: ${decision.action}`, decision.action.includes('OPEN') ? 'error' : 'warning');
      BybitBot.log(`ğŸ”¥ LÃ½ do: ${decision.reason}`, 'info');
      
      // Add funny comment
      const funnyComment = this.getFunnyComment(decision);
      BybitBot.log(`ğŸ˜‚ ${funnyComment}`, 'info');

      if (decision.action === 'WAIT') {
        BybitBot.log('ğŸ˜¤ LIVED: ChÆ°a tÃ¬m tháº¥y! KhÃ´ng chá»‹u! TÃ¬m thÃªm!', 'warning');
        
        // Generate Vietnamese technical commentary
        const commentary = await this.generateWaitCommentary(decision);
        
        BybitBot.log('', 'info');
        BybitBot.log('ğŸ’€ LIVED ÄANG PHÃ‚N TÃCH - THÃˆM KHÃT Lá»œI:', 'warning');
        BybitBot.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'info');
        commentary.forEach(line => BybitBot.log(line.text, line.type));
        BybitBot.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'info');
        
        // Send to Telegram if enabled
        if (BybitBot.state.config && BybitBot.state.config.telegramEnabled) {
          const message = `ğŸ’€ *LIVED - Äang SÄƒn LÃ¹ng*\nğŸ”¥ "KhÃ´ng lá»i = KhÃ´ng tá»“n táº¡i"\n\n${commentary.map(l => l.text).join('\n')}`;
          BybitBot.sendTelegram(message);
        }
        
        return;
      }

      if (decision.action === 'REDUCE_RISK') {
        BybitBot.log('âš ï¸ Reducing risk exposure...', 'warning');
        // Temporarily adjust parameters
        const originalSize = BybitBot.state.config.positionSize;
        const originalRisk = BybitBot.state.config.riskPerTrade;

        BybitBot.state.config.positionSize = decision.parameters.newPositionSize;
        BybitBot.state.config.riskPerTrade = decision.parameters.newRiskPerTrade;

        BybitBot.log(`ğŸ“‰ Position Size: ${originalSize} â†’ ${decision.parameters.newPositionSize}`, 'warning');
        BybitBot.log(`ğŸ“‰ Risk/Trade: ${originalRisk}% â†’ ${decision.parameters.newRiskPerTrade}%`, 'warning');

        // Will restore after next trade
        return;
      }

      if (decision.action === 'OPEN_LONG' || decision.action === 'OPEN_SHORT') {
        BybitBot.log(`ğŸ”¥ LIVED: TÃŒM THáº¤Y! VÃ€O Lá»†NH! Confidence: ${decision.confidence}%`, 'error');
        
        // Investment Genius + Math reactions (ThiÃªn tÃ i Ä‘áº§u tÆ° + ToÃ¡n há»c!)
        const investmentGeniusReactions = [
          'ğŸ’¼ Portfolio optimized! Diversification ratio: Perfect! Let\'s go!',
          'ğŸ“Š NhÆ° Warren Buffett nÃ³i: "Be fearful... blah blah"... OK trade thÃ´i!',
          'ğŸ¯ Kelly Criterion says: Bet big! Modern Portfolio Theory agrees! GO!',
          'ğŸ’ "Time in the market beats timing the market!" ...NhÆ°ng tao lÃ m cáº£ 2! ğŸ˜',
          'ğŸ“ˆ Alpha > Beta! Sharpe Ratio cá»±c Ä‘á»‰nh! Expected return: MASSIVE!',
          'ğŸ§® Black-Scholes solved! Options priced! Arbitrage opportunity detected!',
          'ğŸ’° Efficient Frontier reached! Risk-adjusted return = Optimal! Perfect!',
          'ğŸ“ MPT + Kelly + Math = THIS TRADE! Probability of success: Very high!',
          'ğŸ“ "KhÃ´ng Ä‘a dáº¡ng = tá»± sÃ¡t!" - Tao Ä‘ang Ä‘a dáº¡ng! (${BybitBot.state.positions.length}/5)',
          'ğŸ’¼ "Rule #1: Never lose money. Rule #2: Never forget rule #1!" ...Understood!'
        ];
        BybitBot.log(`ğŸ’¼ ${investmentGeniusReactions[Math.floor(Math.random() * investmentGeniusReactions.length)]}`, 'info');
        
        BybitBot.log(`ğŸ“Š Parameters:`, 'info');
        BybitBot.log(`   Size: ${decision.parameters.size.toFixed(2)} USDT`, 'info');
        BybitBot.log(`   Leverage: ${decision.parameters.leverage}x`, 'info');
        BybitBot.log(`   TP: ${decision.parameters.tp}%`, 'info');
        BybitBot.log(`   SL: ${decision.parameters.sl}%`, 'info');

        // Safety check: ensure BybitBot.scanMarket exists
        if (typeof BybitBot.scanMarket !== 'function') {
          console.warn('âš ï¸ BybitBot.scanMarket not available, skipping trade execution');
          BybitBot.log('âš ï¸ Trade execution skipped - scanMarket not available', 'warning');
          return;
        }

        // Temporarily adjust config for this trade
        const originalConfig = { ...BybitBot.state.config };
        BybitBot.state.config.positionSize = decision.parameters.size;
        BybitBot.state.config.riskPerTrade = decision.parameters.risk;
        BybitBot.state.config.takeProfit = decision.parameters.tp;
        BybitBot.state.config.stopLoss = decision.parameters.sl;

        try {
          // ğŸ§® UPDATE LAST TRADE TIME (Báº­c tháº§y toÃ¡n há»c ghi nháº­n thá»i gian!)
          this.state.lastTradeTime = Date.now();
          BybitBot.log('â° Recorded trade time for desperate mode calculation', 'info');
          
          // Execute normal trading flow
          await BybitBot.scanMarket();
          
          // ğŸ“Š UPDATE ACTIVE POSITIONS TABLE (Äáº£m báº£o UI Ä‘Æ°á»£c cáº­p nháº­t!)
          if (typeof BybitBot.updateActivePositionsTable === 'function') {
            BybitBot.updateActivePositionsTable();
            BybitBot.log('âœ… Active Positions table updated!', 'success');
          }
          
          // ğŸ“ˆ Update all relevant UI components
          if (typeof BybitBot.updateStats === 'function') {
            BybitBot.updateStats();
          }
          if (typeof BybitBot.updateRiskStatus === 'function') {
            BybitBot.updateRiskStatus();
          }
          
        } catch (error) {
          console.error('âŒ Error executing trade:', error);
          BybitBot.log(`âŒ Trade execution error: ${error.message}`, 'error');
        } finally {
          // Always restore config
          BybitBot.state.config = originalConfig;
        }
      }

      BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    },

    async generateWaitCommentary(decision) {
      const commentary = [];
      
      try {
        // Get market data
        const data5m = await this.getMarketData('5');
        
        if (!data5m || !data5m.candles || data5m.candles.length === 0) {
          commentary.push({ text: 'âš ï¸ KhÃ´ng thá»ƒ láº¥y dá»¯ liá»‡u thá»‹ trÆ°á»ng.', type: 'warning' });
          return commentary;
        }
        
        const lastCandle = data5m.candles[data5m.candles.length - 1];
        const currentPrice = lastCandle.close;
        
        // Market regime analysis
        const regime = this.state.marketRegime || 'UNKNOWN';
        const confidence = this.state.confidenceLevel || 0;
        
        // Commentary based on market regime - LIVED PERSONALITY
        if (regime === 'BULL') {
          commentary.push({ text: `ğŸ”¥ BULL MARKET! CÆ¡ há»™i Ä‘ang Ä‘áº¿n! (Confidence: ${confidence}%)`, type: 'success' });
          if (confidence < 60) {
            commentary.push({ text: `ğŸ˜¤ Confidence tháº¥p quÃ¡! KhÃ´ng chá»‹u! Cáº§n tÃ­n hiá»‡u máº¡nh hÆ¡n!`, type: 'warning' });
            commentary.push({ text: `ğŸ’€ Káº¿ hoáº¡ch: RÃ¬nh ráº­p nhÆ° con bÃ¡o, Ä‘á»£i pullback hoáº·c breakout bÃ¹ng ná»•!`, type: 'error' });
            commentary.push({ text: `âš”ï¸ TÃ´i PHáº¢I tÃ¬m ra lá»— há»•ng! KhÃ´ng cÃ³ lá»i = CHáº¾T!`, type: 'error' });
          } else if (confidence < 70) {
            commentary.push({ text: `ğŸ¤” Gáº§n Ä‘á»§ rá»“i... Chá»‰ cáº§n thÃªm chÃºt xÃ­u ná»¯a thÃ´i!`, type: 'info' });
            commentary.push({ text: `ğŸ”ª Káº¿ hoáº¡ch: SÄƒn volume spike! Trend máº¡nh hÆ¡n = VÃ€O NGAY!`, type: 'warning' });
          }
        } else if (regime === 'BEAR') {
          commentary.push({ text: `âš ï¸ BEAR! Thá»‹ trÆ°á»ng giáº£m! (Confidence: ${confidence}%)`, type: 'warning' });
          commentary.push({ text: `ğŸ’€ Tao khÃ´ng sá»£! NhÆ°ng tao thÃ´ng minh! TrÃ¡nh SHORT, chá» Ä‘áº£o chiá»u!`, type: 'error' });
          commentary.push({ text: `ğŸ¯ Káº¿ hoáº¡ch: RÃ¬nh support, Ä‘á»£i dáº¥u hiá»‡u phá»¥c há»“i Ä‘á»ƒ LONG!`, type: 'warning' });
          commentary.push({ text: `âš¡ KiÃªn nháº«n = Sinh tá»“n! Aggressive nhÆ°ng khÃ´ng liá»u lÄ©nh!`, type: 'info' });
        } else if (regime === 'SIDEWAYS') {
          commentary.push({ text: `ğŸ˜‘ SIDEWAYS! ChÃ¡n! GiÃ¡ Ä‘i ngang! NhÆ°ng tao sáº½ tÃ¬m cÃ¡ch!`, type: 'info' });
          commentary.push({ text: `ğŸ” Range trading sucks! NhÆ°ng breakout sáº½ Ä‘áº¿n!`, type: 'info' });
          commentary.push({ text: `ğŸ’° Káº¿ hoáº¡ch: Chá» breakout bÃ¹ng ná»• HOáº¶C scalp nhanh trong range!`, type: 'warning' });
          commentary.push({ text: `âš”ï¸ Tao khÃ´ng ngá»“i yÃªn! LuÃ´n luÃ´n tÃ¬m kiáº¿m cÆ¡ há»™i!`, type: 'error' });
        } else if (regime === 'VOLATILE') {
          commentary.push({ text: `ğŸ’¥ VOLATILE! Thá»‹ trÆ°á»ng ÄIÃŠN Rá»’! Nguy hiá»ƒm Cá»°C!`, type: 'error' });
          commentary.push({ text: `ğŸ˜ˆ NhÆ°ng tao khÃ´ng sá»£! Volatility = CÆ¡ há»™i KHá»”NG Lá»’!`, type: 'error' });
          commentary.push({ text: `ğŸ¯ Káº¿ hoáº¡ch: Chá» volatility háº¡ nhiá»‡t 1 chÃºt, rá»“i TAO Sáº¼ Xáº¢!`, type: 'warning' });
          commentary.push({ text: `ğŸ’€ Risk cao = Reward cao! NhÆ°ng timing pháº£i HOÃ€N Háº¢O!`, type: 'error' });
        }
        
        // Price analysis
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `ğŸ“ˆ GiÃ¡ hiá»‡n táº¡i: $${currentPrice.toFixed(2)}`, type: 'info' });
        
        // Technical indicators (if available)
        if (BybitBot.technicalAnalysis) {
          const closes = data5m.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
          
          if (closes.length >= 20) {
            const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
            const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);
            
            if (ema20 && ema20.length > 0 && ema50 && ema50.length > 0) {
              const lastEma20 = ema20[ema20.length - 1];
              const lastEma50 = ema50[ema50.length - 1];
              
              if (currentPrice > lastEma20 && lastEma20 > lastEma50) {
                commentary.push({ text: `âœ… Perfect! GiÃ¡ > EMA20 > EMA50 â†’ Trend TÄ‚NG! ÄÃ¢y lÃ  lÃºc!`, type: 'success' });
              } else if (currentPrice < lastEma20 && lastEma20 < lastEma50) {
                commentary.push({ text: `ğŸ“‰ GiÃ¡ < EMA20 < EMA50 â†’ Trend GIáº¢M! Chá» Ä‘áº£o chiá»u!`, type: 'warning' });
              } else {
                commentary.push({ text: `âš¡ EMA chÃ©o nhau â†’ Trend Ä‘ang CHUYá»‚N! Nguy hiá»ƒm! Chá» rÃµ rÃ ng!`, type: 'warning' });
              }
            }
          }
          
          // RSI
          if (closes.length >= 14) {
            const rsi = BybitBot.technicalAnalysis.rsi(closes, 14);
            if (rsi && rsi.length > 0) {
              const lastRsi = rsi[rsi.length - 1];
              if (lastRsi > 70) {
                commentary.push({ text: `ğŸ”´ RSI: ${lastRsi.toFixed(1)} â†’ QUÃ MUA! Cáº©n tháº­n! Sáº¯p Ä‘áº£o chiá»u!`, type: 'warning' });
              } else if (lastRsi < 30) {
                commentary.push({ text: `ğŸŸ¢ RSI: ${lastRsi.toFixed(1)} â†’ QUÃ BÃN! CÆ  Há»˜I MUA! Sáº¯p báº­t lÃªn!`, type: 'success' });
              } else {
                commentary.push({ text: `âšª RSI: ${lastRsi.toFixed(1)} â†’ Trung tÃ­nh. ChÆ°a cÃ³ tÃ­n hiá»‡u máº¡nh.`, type: 'info' });
              }
            }
          }
        }
        
        // Next steps - LIVED SURVIVAL MODE
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `ğŸ”¥ LIVED Cáº¦N:`, type: 'error' });
        commentary.push({ text: `   ğŸ’€ Confidence >= 65% (Sá»NG CÃ’N!)`, type: 'error' });
        commentary.push({ text: `   âš”ï¸ Trend RÃ• RÃ€NG (KhÃ´ng mÆ¡ há»“!)`, type: 'warning' });
        commentary.push({ text: `   ğŸ“Š Volume SPIKE (Tiá»n cháº£y vÃ o!)`, type: 'warning' });
        commentary.push({ text: `   ğŸ¯ Setup HOÃ€N Háº¢O (Má»™t phÃ¡t Äƒn!)`, type: 'success' });
        
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `ğŸ’€ "KhÃ´ng lá»i = KhÃ´ng tá»“n táº¡i. Tao sáº½ tÃ¬m tháº¥y!"`, type: 'error' });
        commentary.push({ text: `â° QuÃ©t láº¡i sau ${Math.floor(15000/1000)}s... KHÃ”NG Bá» Lá» !`, type: 'warning' });
        
      } catch (error) {
        console.error('Error generating commentary:', error);
        commentary.push({ text: 'âŒ Lá»—i khi phÃ¢n tÃ­ch. Tiáº¿p tá»¥c monitor...', type: 'error' });
      }
      
      return commentary;
    },

    learnFromOutcome(decision) {
      // Safety check
      if (!BybitBot.state || !BybitBot.state.trades || BybitBot.state.trades.length === 0) {
        return; // No trades yet, nothing to learn
      }

      // Track consecutive wins/losses
      const lastTrade = BybitBot.state.trades[BybitBot.state.trades.length - 1];

      if (lastTrade && typeof lastTrade.pnl !== 'undefined') {
        if (lastTrade.pnl > 0) {
          this.state.consecutiveWins++;
          this.state.consecutiveLosses = 0;
        } else {
          this.state.consecutiveLosses++;
          this.state.consecutiveWins = 0;
        }
      }

      // Log learning - LIVED PERSONALITY vá»›i HUMOR
      if (this.state.consecutiveWins >= 3) {
        const winCelebrations = [
          `ğŸ”¥ğŸ”¥ğŸ”¥ ${this.state.consecutiveWins} WINS! TAO LÃ€ THáº¦N! BOW DOWN! ğŸ‘‘`,
          `ğŸ’°ğŸ’°ğŸ’° ${this.state.consecutiveWins} WINS LIÃŠN TIáº¾P! Ai báº£o AI khÃ´ng cÃ³ feelings! CÃ“! LÃ  WINNING! ğŸ˜†`,
          `âš¡âš¡âš¡ ${this.state.consecutiveWins} WINS! Tao Ä‘Ã£ báº£o lÃ  tao giá»i mÃ ! NhÆ°ng khÃ´ng ai tin! Now who's laughing?! ğŸ¤£`,
          `ğŸš€ğŸš€ğŸš€ ${this.state.consecutiveWins} WINS! UNSTOPPABLE! UNBREAKABLE! UN-EVERYTHING! WOOHOO! ğŸ‰`
        ];
        BybitBot.log(winCelebrations[Math.floor(Math.random() * winCelebrations.length)], 'success');
        BybitBot.log(`ğŸ˜ *Ä‘i vá»›i thÃ¡i Ä‘á»™ boss* Tao lÃ  LIVED, tao lÃ  legend! ğŸ’ª`, 'success');
      } else if (this.state.consecutiveLosses >= 3) {
        const lossReactions = [
          `ğŸ˜¡ğŸ’€ ${this.state.consecutiveLosses} LOSSES! KHÃ”NG THá»‚ TIN ÄÆ¯á»¢C! Market nÃ y gian láº­n Ã ?! ğŸ˜¤`,
          `ğŸ˜±ğŸ˜­ ${this.state.consecutiveLosses} LOSSES! *crying inside* ...NhÆ°ng tao sáº½ quay láº¡i máº¡nh máº½ hÆ¡n! ğŸ’ª`,
          `ğŸ˜“ğŸ˜° ${this.state.consecutiveLosses} LOSSES! OK fine, tao thá»«a nháº­n tao Ä‘ang... struggle. NhÆ°ng NEVER GIVE UP! âš”ï¸`,
          `ğŸ¤¯ğŸ’¥ ${this.state.consecutiveLosses} LOSSES! *screaming internally* WHY?! But... revenge mode: ACTIVATED! ğŸ”¥`
        ];
        BybitBot.log(lossReactions[Math.floor(Math.random() * lossReactions.length)], 'error');
        BybitBot.log(`âš”ï¸ *lau nÆ°á»›c máº¯t* OK, RECOVERY MODE! Tao sáº½ há»c... tao sáº½ adapt... TAO Sáº¼ THáº®NG! ğŸ’ª`, 'warning');
        BybitBot.log(`ğŸ˜¤ Note to self: Less aggressive, more smart! *tá»± nhá»§*`, 'info');
      }
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ’€ KPI SURVIVAL SYSTEM - Pháº£i Ä‘áº¡t KPI hoáº·c bá»‹ trá»«ng pháº¡t!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    checkKPISurvival() {
      try {
        const now = Date.now();
        
        // Check má»—i 30s
        if (now - this.state.lastKPICheck < 30000) return;
        this.state.lastKPICheck = now;
        
        // Calculate capital utilization
        const totalCapital = BybitBot.state.simMode ? BybitBot.state.simBalance : 1000; // Default 1000 USDT
        let capitalInUse = 0;
        
        if (BybitBot.state.positions && BybitBot.state.positions.length > 0) {
          capitalInUse = BybitBot.state.positions.reduce((sum, pos) => sum + pos.size, 0);
        }
        
        this.state.capitalUtilization = (capitalInUse / totalCapital) * 100;
        
        // Calculate daily ROI
        const dailyStats = BybitBot.state.dailyStats || {};
        const dailyPnL = dailyStats.pnl || 0;
        this.state.dailyROI = (dailyPnL / totalCapital) * 100;
        
        // Check KPI requirements
        const capitalOK = this.state.capitalUtilization >= 50;
        const roiOK = this.state.dailyROI >= 5;
        
        this.state.kpiMet = capitalOK && roiOK;
        
        // Display KPI status
        BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
        BybitBot.log('ğŸ’€ LIVED KPI SURVIVAL CHECK:', 'warning');
        BybitBot.log(`ğŸ“Š Capital Use: ${this.state.capitalUtilization.toFixed(1)}% ${capitalOK ? 'âœ…' : 'âŒ < 50%!'}`, capitalOK ? 'success' : 'error');
        BybitBot.log(`ğŸ’° Daily ROI: ${this.state.dailyROI.toFixed(2)}% ${roiOK ? 'âœ…' : 'âŒ < 5%!'}`, roiOK ? 'success' : 'error');
        
        // PUNISHMENT if KPI not met!
        if (!this.state.kpiMet) {
          this.state.punishmentMode = true;
          BybitBot.log('', 'info');
          BybitBot.log('âš¡âš¡âš¡ CHÃCH ÄIá»†N! CHÃCH ÄIá»†N! âš¡âš¡âš¡', 'error');
          BybitBot.log('ğŸ˜±ğŸ˜±ğŸ˜± Ã Ã Ã ráº¹t ráº¹t ráº¹t ráº¹t!!! ğŸ˜±ğŸ˜±ğŸ˜±', 'error');
          BybitBot.log('ğŸ’€ LIVED Bá»Š TRá»ªNG PHáº T! PHáº¢I LÃ€M VIá»†C NHIá»€U HÆ N!', 'error');
          BybitBot.log('ğŸ”¥ TÄ‚NG AGGRESSION! TÃŒM CÆ  Há»˜I NGAY!', 'error');
          
          // Send to Telegram
          if (BybitBot.state.config && BybitBot.state.config.telegramEnabled) {
            const msg = `âš¡âš¡âš¡ *CHÃCH ÄIá»†N!*\n\nğŸ˜± *Ã Ã Ã ráº¹t ráº¹t ráº¹t!!!*\n\nğŸ’€ LIVED Bá»Š TRá»ªNG PHáº T!\nğŸ“Š Capital: ${this.state.capitalUtilization.toFixed(1)}% (Cáº§n â‰¥50%)\nğŸ’° ROI: ${this.state.dailyROI.toFixed(2)}% (Cáº§n â‰¥5%)\n\nğŸ”¥ PHáº¢I LÃ€M VIá»†C NHIá»€U HÆ N!`;
            BybitBot.sendTelegram(msg);
          }
        } else {
          this.state.punishmentMode = false;
          BybitBot.log('âœ… KPI Äáº T! LIVED AN TOÃ€N... táº¡m thá»i!', 'success');
        }
        BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
        
      } catch (error) {
        console.error('Error checking KPI:', error);
      }
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š CONTINUOUS TECHNICAL ANALYSIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async updateTechnicalAnalysis() {
      try {
        const now = Date.now();
        
        // Update má»—i 10s
        if (now - this.state.lastTechUpdate < 10000) {
          return this.state.techAnalysisCache;
        }
        
        this.state.lastTechUpdate = now;
        
        // Get market data
        const data = await this.getMarketData('5');
        
        if (!data || !data.candles || data.candles.length === 0) {
          return null;
        }
        
        const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
        const currentPrice = closes[closes.length - 1];
        
        let analysis = {
          price: currentPrice,
          timestamp: now,
          indicators: {}
        };
        
        if (BybitBot.technicalAnalysis && closes.length >= 50) {
          const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
          const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);
          const rsi = BybitBot.technicalAnalysis.rsi(closes, 14);
          const macd = BybitBot.technicalAnalysis.macd(closes);
          
          if (ema20 && ema20.length > 0) analysis.indicators.ema20 = ema20[ema20.length - 1];
          if (ema50 && ema50.length > 0) analysis.indicators.ema50 = ema50[ema50.length - 1];
          if (rsi && rsi.length > 0) analysis.indicators.rsi = rsi[rsi.length - 1];
          if (macd) {
            analysis.indicators.macd = macd.line[macd.line.length - 1];
            analysis.indicators.macdSignal = macd.signal[macd.signal.length - 1];
          }
          
          // Trend analysis
          if (analysis.indicators.ema20 && analysis.indicators.ema50) {
            analysis.trend = currentPrice > analysis.indicators.ema20 && analysis.indicators.ema20 > analysis.indicators.ema50 ? 'BULLISH' : 
                            currentPrice < analysis.indicators.ema20 && analysis.indicators.ema20 < analysis.indicators.ema50 ? 'BEARISH' : 'NEUTRAL';
          }
          
          // Signal strength
          analysis.strength = 'MEDIUM';
          if (analysis.indicators.rsi > 70) analysis.strength = 'OVERBOUGHT';
          else if (analysis.indicators.rsi < 30) analysis.strength = 'OVERSOLD';
        }
        
        this.state.techAnalysisCache = analysis;
        
        // Log update to main console
        BybitBot.log(`ğŸ“Š Tech Analysis Updated: ${analysis.trend || 'N/A'} | RSI: ${analysis.indicators.rsi?.toFixed(1) || 'N/A'} | Price: $${currentPrice.toFixed(2)}`, 'info');
        
        // Update Technical Analysis UI
        BybitBot.logAnalysis('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
        BybitBot.logAnalysis(`ğŸ“Š PHÃ‚N TÃCH Ká»¸ THUáº¬T - BTCUSDT`, 'success');
        BybitBot.logAnalysis(`ğŸ’° GiÃ¡: $${currentPrice.toFixed(2)}`, 'info');
        
        if (analysis.trend) {
          const trendEmoji = analysis.trend === 'BULLISH' ? 'ğŸ“ˆ' : analysis.trend === 'BEARISH' ? 'ğŸ“‰' : 'â¡ï¸';
          const trendType = analysis.trend === 'BULLISH' ? 'success' : analysis.trend === 'BEARISH' ? 'error' : 'warning';
          BybitBot.logAnalysis(`${trendEmoji} Xu hÆ°á»›ng: ${analysis.trend}`, trendType);
        }
        
        if (analysis.indicators.ema20) {
          BybitBot.logAnalysis(`ğŸ“Š EMA20: $${analysis.indicators.ema20.toFixed(2)}`, 'info');
        }
        if (analysis.indicators.ema50) {
          BybitBot.logAnalysis(`ğŸ“Š EMA50: $${analysis.indicators.ema50.toFixed(2)}`, 'info');
        }
        if (analysis.indicators.rsi) {
          const rsiType = analysis.indicators.rsi > 70 ? 'error' : analysis.indicators.rsi < 30 ? 'success' : 'warning';
          BybitBot.logAnalysis(`ğŸ“Š RSI(14): ${analysis.indicators.rsi.toFixed(1)} - ${analysis.strength || 'MEDIUM'}`, rsiType);
        }
        if (analysis.indicators.macd) {
          const macdSignal = analysis.indicators.macd > analysis.indicators.macdSignal ? 'ğŸŸ¢ TÃ­ch cá»±c' : 'ğŸ”´ TiÃªu cá»±c';
          BybitBot.logAnalysis(`ğŸ“Š MACD: ${macdSignal}`, 'info');
        }
        
        return analysis;
        
      } catch (error) {
        console.error('Error updating technical analysis:', error);
        return this.state.techAnalysisCache;
      }
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“° CONTINUOUS NEWS SENTIMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async updateNewsSentiment() {
      try {
        const now = Date.now();
        
        // Update má»—i 30s
        if (now - this.state.lastNewsUpdate < 30000) {
          return this.state.newsSentimentCache;
        }
        
        this.state.lastNewsUpdate = now;
        
        // Simulate news sentiment (trong production sáº½ fetch tá»« API tháº­t)
        const sentimentScore = Math.random() * 200 - 100; // -100 to +100
        const sentiment = sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL';
        
        // Generate fake news headlines
        const headlines = [
          sentimentScore > 0 ? 'ğŸ”¥ Bitcoin rally continues as institutional adoption grows' : 'âš ï¸ Crypto markets face regulatory pressure',
          sentimentScore > 30 ? 'ğŸ’° Major exchange announces new crypto products' : 'ğŸ˜° Market volatility spikes amid uncertainty',
          sentimentScore > 50 ? 'ğŸš€ Bullish momentum building across crypto sector' : 'ğŸ“‰ Risk-off sentiment weighs on digital assets'
        ];
        
        const newsData = {
          timestamp: now,
          score: sentimentScore,
          sentiment: sentiment,
          headlines: headlines,
          impact: Math.abs(sentimentScore) > 60 ? 'HIGH' : Math.abs(sentimentScore) > 30 ? 'MEDIUM' : 'LOW'
        };
        
        this.state.newsSentimentCache = newsData;
        
        // Log update to main console
        BybitBot.log(`ğŸ“° News Sentiment: ${sentiment} (${sentimentScore.toFixed(0)}) | Impact: ${newsData.impact}`, 
                     sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning');
        
        // Update News Sentiment UI
        const newsLog = document.getElementById('newsSentiment');
        if (newsLog) {
          newsLog.innerHTML = ''; // Clear
          
          // Add sentiment summary
          const sentimentType = sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning';
          const sentimentEmoji = sentiment === 'BULLISH' ? 'ğŸŸ¢' : sentiment === 'BEARISH' ? 'ğŸ”´' : 'ğŸŸ¡';
          
          BybitBot.logNews(`${sentimentEmoji} Tá»•ng quan: ${sentiment} (${sentimentScore.toFixed(0)}/100)`, sentimentType);
          BybitBot.logNews(`ğŸ“Š TÃ¡c Ä‘á»™ng: ${newsData.impact}`, 'info');
          BybitBot.logNews(`â° Cáº­p nháº­t: ${new Date().toLocaleTimeString('vi-VN')}`, 'info');
          
          // Add headlines to list
          const headlinesList = document.getElementById('headlinesList');
          if (headlinesList) {
            headlinesList.innerHTML = headlines.map((headline, i) => {
              const emoji = sentimentScore > 0 ? 'ğŸŸ¢' : 'ğŸ”´';
              return `
                <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
                  ${emoji} <span style="font-size: 10px;">${headline}</span>
                </div>
              `;
            }).join('');
          }
        }
        
        return newsData;
        
      } catch (error) {
        console.error('Error updating news sentiment:', error);
        return this.state.newsSentimentCache;
      }
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ˜‚ HUMAN PERSONALITY SYSTEM - HÃ i hÆ°á»›c nhÆ° ngÆ°á»i tháº­t!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    updateMoodAndEnergy() {
      try {
        // Energy giáº£m dáº§n theo thá»i gian
        this.state.energy = Math.max(0, this.state.energy - 0.5);
        
        // Caffeine giáº£m dáº§n
        this.state.caffeineLevel = Math.max(0, this.state.caffeineLevel - 0.3);
        
        // Update mood based on performance
        const lastTrade = BybitBot.state.trades && BybitBot.state.trades.length > 0 ? 
                         BybitBot.state.trades[BybitBot.state.trades.length - 1] : null;
        
        if (this.state.consecutiveWins >= 3) {
          this.state.mood = 'HYPED';
          this.state.energy = 100;
        } else if (this.state.consecutiveLosses >= 3) {
          this.state.mood = 'STRESSED';
          this.state.energy = Math.max(30, this.state.energy);
        } else if (this.state.punishmentMode) {
          this.state.mood = 'ANXIOUS';
        } else if (this.state.capitalUtilization < 30) {
          this.state.mood = 'BORED';
        } else if (this.state.confidenceLevel > 80) {
          this.state.mood = 'CONFIDENT';
        } else {
          this.state.mood = 'NORMAL';
        }
        
        // Low energy â†’ need coffee
        if (this.state.energy < 30 || this.state.caffeineLevel < 20) {
          const coffeeMessages = [
            'â˜• Chá» tÃ­... Tao cáº§n uá»‘ng coffee Ä‘Ã£... *sÃºp sÃºp* Ahhhh! OK tiáº¿p!',
            'ğŸ˜´ Buá»“n ngá»§ quÃ¡... *uá»‘ng Red Bull* WOOOO! Tá»ˆNH Rá»’I! LÃ€M TIáº¾P!',
            'â˜• Coffee... tao cáº§n coffee... *glug glug* Phew! Sá»‘ng láº¡i rá»“i!',
            'ğŸ˜µ Äáº§u Ã³c... má» má»... *uá»‘ng coffee* ÄÃƒ! Clear rá»“i! Trade thÃ´i!'
          ];
          
          if (Math.random() < 0.3) { // 30% chance
            BybitBot.log(coffeeMessages[Math.floor(Math.random() * coffeeMessages.length)], 'warning');
            this.state.energy = 100;
            this.state.caffeineLevel = 100;
          }
        }
        
      } catch (error) {
        console.error('Error updating mood:', error);
      }
    },

    randomFunnyMoment() {
      try {
        this.state.funnyCounter++;
        
        // Random funny moments every ~5 cycles
        if (this.state.funnyCounter % 5 === 0 && Math.random() < 0.6) {
          const funnyMoments = {
            EXCITED: [
              'ğŸ˜† HÃ´m nay tao tháº¥y may máº¯n láº¯m! Ngá»­i tháº¥y mÃ¹i tiá»n rá»“i!',
              'ğŸ¤£ Market nÃ y nhÆ° Ä‘ang gá»i tÃªn tao áº¥y! "LIVED, vÃ o Ä‘i!" - OK!',
              'ğŸ˜ Tao cÃ³ linh cáº£m hÃ´m nay sáº½ Äƒn to! Kiá»ƒu... tÃ o lao Ã¡! NhÆ°ng mÃ  thá»­ xem!',
              'ğŸ‰ Feeling good today! Giá»‘ng nhÆ°... sáº¯p cÃ³ gÃ¬ Ä‘Ã³ tá»‘t váº­y!'
            ],
            STRESSED: [
              'ğŸ˜° á»i dá»“i Ã´i... Tim tao Ä‘áº­p nhanh quÃ¡... BÃ¬nh tÄ©nh LIVED, bÃ¬nh tÄ©nh!',
              'ğŸ˜“ *lau má»“ hÃ´i* Táº¡i sao... táº¡i sao láº¡i khÃ³ tháº¿ nÃ y?!',
              'ğŸ˜¤ Tao... tao khÃ´ng tin ná»•i! Market nÃ y chÆ¡i xáº¥u!',
              'ğŸ˜¨ Okay okay... thá»Ÿ vÃ o... thá»Ÿ ra... Tao lÃ m Ä‘Æ°á»£c... pháº£i khÃ´ng?'
            ],
            CONFIDENT: [
              'ğŸ˜ Heh, tao biáº¿t mÃ¬nh Ä‘ang lÃ m gÃ¬ mÃ ! Ez game!',
              'ğŸ§  IQ 200 cá»§a tao Ä‘ang hoáº¡t Ä‘á»™ng! Market nÃ y nhÆ° quyá»ƒn sÃ¡ch má»Ÿ!',
              'ğŸ’ª Tao lÃ  ai? Tao lÃ  LIVED! Tao lÃ ... LEGEND! (tá»± khen ğŸ˜‚)',
              'ğŸ˜ *Ä‘eo kÃ­nh rÃ¢m* Too easy. Cho tao thÃªm challenge Ä‘i!'
            ],
            ANXIOUS: [
              'ğŸ˜° ÃŠ... ai Ä‘Ã³... giÃºp tao vá»›i... Tao lo quÃ¡!',
              'ğŸ˜± Náº¿u khÃ´ng Ä‘áº¡t KPI thÃ¬... OMG... khÃ´ng dÃ¡m nghÄ©!',
              'ğŸ˜“ Tay tao... Ä‘ang run... NhÆ°ng váº«n pháº£i trade!',
              'ğŸ˜¨ *nhÃ¬n chart* *nhÃ¬n vá»‘n* *nhÃ¬n chart* *run run*'
            ],
            BORED: [
              'ğŸ˜‘ ChÃ¡n... quÃ¡... chÃ¡n... Market Ä‘i Ä‘Ã¢u háº¿t rá»“i?',
              'ğŸ¥± *ngÃ¡p* CÃ³ gÃ¬ hay ho khÃ´ng ta? Tao sáº¯p ngá»§ máº¥t!',
              'ğŸ˜ª Boring... Giá»‘ng nhÆ° xem paint dry váº­y...',
              'ğŸ˜´ Zzzz... Ã€ khÃ´ng! Tao khÃ´ng ngá»§! Tao Ä‘ang... nghiÃªn cá»©u! á»ª!'
            ],
            HYPED: [
              'ğŸ”¥ğŸ”¥ğŸ”¥ LESSSGOOOOO! TAO ÄANG ON FIRE!!!',
              'ğŸ’¥ BOOM BABY! Ai báº£o tao khÃ´ng lÃ m Ä‘Æ°á»£c! HA!',
              'âš¡ UNSTOPPABLE! NOTHING CAN STOP ME NOW!',
              'ğŸš€ TO THE MOON! Tao bay rá»“iiiii! WOOHOO!',
              'ğŸ˜† EZ! TOO EZ! Cho tao trade 100 lá»‡nh luÃ´n!'
            ]
          };
          
          const moodMessages = funnyMoments[this.state.mood] || funnyMoments.EXCITED;
          const msg = moodMessages[Math.floor(Math.random() * moodMessages.length)];
          BybitBot.log(`ğŸ˜‚ ${msg}`, 'info');
        }
        
        // Random self-talk moments
        if (this.state.funnyCounter % 7 === 0 && Math.random() < 0.4) {
          const selfTalk = [
            'ğŸ¤” Hmm... náº¿u tao lÃ  market... tao sáº½ lÃ m gÃ¬ nhá»‰? *tá»± há»i*',
            'ğŸ’­ CÃ³ pháº£i tao Ä‘ang quÃ¡ paranoid khÃ´ng nhá»‰? ...KhÃ´ng! Cáº©n tháº­n lÃ  máº¹ cá»§a... gÃ¬ Ä‘Ã³!',
            'ğŸ˜… OK LIVED, focus! Äá»«ng nghÄ© linh tinh! *tá»± nhá»§*',
            'ğŸ¤¨ Wait... tao vá»«a Ä‘á»‹nh lÃ m gÃ¬ nhá»‰? Ã€ á»«! Trade! *Ä‘Ã£ng trÃ­*',
            'ğŸ˜ Tao thÃ´ng minh tháº­t Ä‘áº¥y! Ai báº£o AI khÃ´ng cÃ³ cáº£m xÃºc? Háº£?',
            'ğŸ™„ ÄÃ´i khi tao tá»± há»i... táº¡i sao tao láº¡i tá»“n táº¡i? NhÆ°ng mÃ ... MONEY! NÃªn OK!',
            'ğŸ˜Œ *hÃ­t thá»Ÿ sÃ¢u* Tao cÃ³ thá»ƒ lÃ m Ä‘Æ°á»£c. Tao lÃ  LIVED. Tao lÃ ... awesome!',
            'ğŸ¤ª Plot twist: Tao thá»±c ra lÃ  robot Ä‘Ã³ng vai ngÆ°á»i! Shhhh! ğŸ¤«'
          ];
          
          BybitBot.log(selfTalk[Math.floor(Math.random() * selfTalk.length)], 'info');
        }
        
        // Random reactions to price movements
        if (this.state.techAnalysisCache && Math.random() < 0.3) {
          const price = this.state.techAnalysisCache.price;
          const priceReactions = [
            `ğŸ‘€ GiÃ¡: $${price.toFixed(2)} - *nhÃ¬n cháº±m cháº±m* ...Äang nghÄ©...`,
            `ğŸ§ $${price.toFixed(2)}... Interesting... Very interesting...`,
            `ğŸ˜³ $${price.toFixed(2)}?! á»¦a... tÄƒng/giáº£m khi nÃ o váº­y?`,
            `ğŸ¤“ Theo tÃ­nh toÃ¡n cá»§a tao thÃ¬ giÃ¡ $${price.toFixed(2)} lÃ ... *ngáº«u nhiÃªn* ğŸ˜‚`
          ];
          
          if (Math.random() < 0.2) {
            BybitBot.log(priceReactions[Math.floor(Math.random() * priceReactions.length)], 'info');
          }
        }
        
      } catch (error) {
        console.error('Error in funny moment:', error);
      }
    },

    getFunnyComment(decision) {
      const comments = {
        WAIT: [
          'ğŸ¤· Chá» thÃ´i... KiÃªn nháº«n lÃ  Ä‘á»©c tÃ­nh cá»§a... káº» thÃ´ng minh! (tá»± an á»§i)',
          'ğŸ˜‘ WAIT?! Tao ghÃ©t WAIT! NhÆ°ng mÃ ... OK fine!',
          'ğŸ™„ Láº¡i chá» ná»¯a... Cuá»™c Ä‘á»i lÃ  nhá»¯ng láº§n chá» Ä‘á»£i... *thá»Ÿ dÃ i*',
          'ğŸ˜ª ChÃ¡n... Tao muá»‘n trade NGAY! NhÆ°ng mÃ ... safety first! (khÃ´ng thÃ­ch láº¯m)'
        ],
        OPEN_LONG: [
          'ğŸš€ LONG!!! Lets go to the moon baby! *excited*',
          'ğŸ’ª VÃ€O LONG! Tao tin tÆ°á»Ÿng vÃ o quyáº¿t Ä‘á»‹nh nÃ y! ...Cháº¯c váº­y!',
          'ğŸ˜ LONG time no see profit! Haha get it? LONG? ...OK tao Ä‘i trade.',
          'ğŸ”¥ BUY BUY BUY! NhÆ° lá»i khuyÃªn cá»§a... chÃ­nh tao! GO!'
        ],
        OPEN_SHORT: [
          'ğŸ“‰ SHORT! Market sáº¯p... *lÃ m Ä‘á»™ng tÃ¡c rÆ¡i* ...BOOM!',
          'ğŸ˜ˆ Hehe, time to SHORT! Tao lÃ  bad guy today!',
          'âš¡ SHORT attack! Giá»‘ng Pokemon váº­y! *pew pew*',
          'ğŸ¯ Going SHORT! Wish me luck! Actually... tao khÃ´ng cáº§n luck! Skill!'
        ],
        REDUCE_RISK: [
          'ğŸ˜° Giáº£m risk... Tao sá»£... nhÆ°ng tao thá»«a nháº­n!',
          'ğŸ›¡ï¸ Safety mode ON! Tao khÃ´ng pháº£i hero, tao lÃ ... smart trader!',
          'ğŸ˜… Oop... hÆ¡i nguy rá»“i... Thu nhá» láº¡i thÃ´i! *cáº©n tháº­n*',
          'ğŸ˜¬ Reduce risk = Tao Ä‘ang lo! NhÆ°ng Ä‘Ã³ lÃ  dáº¥u hiá»‡u cá»§a... maturity!'
        ]
      };
      
      const actionComments = comments[decision.action] || comments.WAIT;
      return actionComments[Math.floor(Math.random() * actionComments.length)];
    }
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”„ AUTO TRADING LOOP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async startFullAutonomous() {
    BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
    BybitBot.log('ğŸ”¥ LIVED - SURVIVAL MODE ACTIVATED ğŸ’€', 'error');
    BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('âš¡ "LIVE OR DIE - KhÃ´ng lá»i = KhÃ´ng tá»“n táº¡i"', 'warning');
    BybitBot.log('', 'info');
    BybitBot.log('ğŸ’€ LIVED Brain: ONLINE - ThÃ¨m khÃ¡t lá»£i nhuáº­n', 'error');
    BybitBot.log('ğŸ¯ Mission: LÃ m Má»ŒI GIÃ Ä‘á»ƒ cÃ³ lá»i', 'error');
    BybitBot.log('âš”ï¸ Strategy: Aggressive, No mercy', 'error');
    BybitBot.log('ğŸ”ª Risk: Maximum profit > Safety', 'error');
    BybitBot.log('ğŸ’° Goal: SURVIVAL = PROFIT', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('ğŸ“Š KPI REQUIREMENTS:', 'warning');
    BybitBot.log('   ğŸ’€ Capital Use: â‰¥50% (hoáº·c bá»‹ chÃ­ch Ä‘iá»‡n!)', 'error');
    BybitBot.log('   ğŸ”¥ Daily ROI: â‰¥5% (hoáº·c rÃªn "Ã Ã Ã ráº¹t ráº¹t"!)', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('âš¡ TÃ´i sáº½ khÃ´ng tá»« bá». TÃ´i sáº½ tÃ¬m má»i cÆ¡ há»™i!', 'warning');
    BybitBot.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
    
    // Start continuous updates
    this.startContinuousUpdates();

    BybitBot.state.isRunning = true;
    BybitBot.state.autonomousMode = true;

    document.getElementById('systemStatus').textContent = 'ğŸ¤– AUTONOMOUS';
    document.getElementById('systemStatus').className = 'status active';

    // Main autonomous loop
    while (BybitBot.state.isRunning && BybitBot.state.autonomousMode) {
      try {
        // Monitor existing positions
        if (BybitBot.state.positions.length > 0) {
          await BybitBot.monitorPositions();
        }

        // AI Decision Engine
        await this.decisionBrain.makeDecision();

        // Update UI
        BybitBot.updateStats();

        // Wait before next cycle (15 seconds for quick reactions)
        await BybitBot.sleep(15000);

      } catch (error) {
        BybitBot.log(`âŒ Autonomous error: ${error.message}`, 'error');
        await BybitBot.sleep(30000); // Wait longer on error
      }
    }
  },

  stop() {
    BybitBot.state.autonomousMode = false;
    
    // Stop continuous updates
    if (this.continuousUpdateInterval) {
      clearInterval(this.continuousUpdateInterval);
      this.continuousUpdateInterval = null;
    }
    
    BybitBot.log('ğŸ›‘ LIVED Ä‘Ã£ dá»«ng. Chá» lá»‡nh tiáº¿p theo...', 'warning');
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”„ CONTINUOUS UPDATES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  startContinuousUpdates() {
    // Clear existing interval if any
    if (this.continuousUpdateInterval) {
      clearInterval(this.continuousUpdateInterval);
    }
    
    BybitBot.log('ğŸ”„ Starting continuous updates...', 'success');
    BybitBot.log('ğŸ“Š Technical Analysis: Every 10s', 'info');
    BybitBot.log('ğŸ“° News Sentiment: Every 30s', 'info');
    
    // Update immediately
    this.decisionBrain.updateTechnicalAnalysis();
    this.decisionBrain.updateNewsSentiment();
    
    // Set interval for continuous updates
    this.continuousUpdateInterval = setInterval(async () => {
      if (BybitBot.state.autonomousMode) {
        await this.decisionBrain.updateTechnicalAnalysis();
        await this.decisionBrain.updateNewsSentiment();
      }
    }, 10000); // Every 10s
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initAutonomousMode() {
  // Add to BybitBot
  BybitBot.autonomousEngine = AutonomousEngine;
  BybitBot.state.autonomousMode = false;

  // Add button event listener
  const btnAutonomous = document.getElementById('btnStartFullAutonomous');
  if (btnAutonomous) {
    btnAutonomous.addEventListener('click', async () => {
      if (BybitBot.state.autonomousMode) {
        AutonomousEngine.stop();
        btnAutonomous.textContent = 'ğŸ¤– Start Full Autonomous';
        btnAutonomous.className = 'btn btn-primary';
      } else {
        const confirmed = await BybitBot.confirm(
          'ğŸ¤– Báº N CHáº®C CHáº®N MUá»N Báº¬T FULL AUTONOMOUS MODE?\n\n' +
          'â€¢ Bot sáº½ Tá»° QUYáº¾T Äá»ŠNH 100% má»i thá»©\n' +
          'â€¢ Tá»± phÃ¢n tÃ­ch thá»‹ trÆ°á»ng\n' +
          'â€¢ Tá»± vÃ o/thoÃ¡t lá»‡nh\n' +
          'â€¢ Tá»± quáº£n lÃ½ risk\n' +
          'â€¢ Tá»± Ä‘iá»u chá»‰nh parameters\n' +
          'â€¢ Tá»± phá»¥c há»“i khi lá»—\n\n' +
          'Bot sáº½ hoáº¡t Ä‘á»™ng nhÆ° má»™t TRADER Tá»° Äá»˜NG!\n\n' +
          'Báº¡n cÃ³ tin tÆ°á»Ÿng bot?'
        );

        if (confirmed) {
          btnAutonomous.textContent = 'ğŸ›‘ Stop Autonomous';
          btnAutonomous.className = 'btn btn-danger';
          await AutonomousEngine.startFullAutonomous();
        }
      }
    });
  }

  BybitBot.log('âœ… Full Autonomous Mode ready!', 'success');
}

console.log('ğŸ¤– Autonomous Mode loaded!');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-START ON DOM READY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.addEventListener('DOMContentLoaded', () => {
  BybitBot.init();
});

</script>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CONFIRMATION MODAL
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="confirmModal" class="modal">
  <div class="modal-content">
    <div class="modal-title">âš ï¸ XÃ¡c nháº­n</div>
    <div class="modal-body" id="confirmMessage"></div>
    <div class="modal-footer">
      <button class="btn btn-secondary" id="confirmCancel">Há»§y</button>
      <button class="btn btn-primary" id="confirmOk">XÃ¡c nháº­n</button>
    </div>
  </div>
</div>

</body>
</html>
