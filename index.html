<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Trading Bot</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CryptoJS for API signature generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .log-area {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .regime-trend { background-color: #166534; color: #dcfce7; }
        .regime-range { background-color: #1e40af; color: #dbeafe; }
        .regime-squeeze { background-color: #9a3412; color: #ffedd5; }
        .regime-micro-grid { background-color: #581c87; color: #f3e8ff; }
        .regime-none { background-color: #4b5563; color: #d1d5db; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-7xl mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6">
        
        <header class="text-center">
            <h1 class="text-3xl font-bold text-white">Bybit Trading Bot</h1>
            <p class="text-gray-400 mt-2">Giao dịch tự động và quản lý tài khoản Bybit của bạn.</p>
        </header>

        <!-- Security Warning -->
        <div class="bg-red-900 border-l-4 border-red-500 text-red-100 p-4 rounded-lg" role="alert">
            <p class="font-bold">Cảnh báo bảo mật quan trọng</p>
            <p>API Key và Secret Key của bạn chỉ được lưu trữ cục bộ trong trình duyệt (localStorage). KHÔNG chia sẻ tệp này hoặc sử dụng trên máy tính công cộng. Mặc dù an toàn trên máy tính cá nhân, hãy luôn thận trọng.</p>
        </div>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <!-- Left Column: Settings & Account -->
            <div class="bg-gray-700/50 p-6 rounded-xl space-y-6">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-3">Cài đặt API</h2>
                <div class="space-y-4">
                    <div>
                        <label for="apiKey" class="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                        <input type="password" id="apiKey" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                    </div>
                    <div>
                        <label for="apiSecret" class="block text-sm font-medium text-gray-300 mb-1">API Secret</label>
                        <input type="password" id="apiSecret" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                    </div>
                    <button id="saveApi" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">Lưu API Key</button>
                </div>

                <div class="pt-6 border-t border-gray-600">
                    <h2 class="text-xl font-semibold mb-3">Thông tin tài khoản</h2>
                     <button id="getBalance" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition mb-4">Lấy số dư (Tài khoản Unified)</button>
                    <div id="balanceInfo" class="bg-gray-900 p-4 rounded-lg text-sm">
                        Nhấn nút trên để xem số dư...
                    </div>
                </div>
            </div>

            <!-- Right Column: Trading -->
            <div class="bg-gray-700/50 p-6 rounded-xl space-y-6">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-3">Đặt lệnh giao dịch (Spot)</h2>
                <div class="space-y-4">
                    <div>
                        <label for="symbol" class="block text-sm font-medium text-gray-300 mb-1">Cặp giao dịch (ví dụ: BTCUSDT)</label>
                        <input type="text" id="symbol" value="BTCUSDT" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                    </div>
                    <div>
                        <label for="qty" class="block text-sm font-medium text-gray-300 mb-1">Số lượng</label>
                        <input type="number" id="qty" placeholder="0.01" step="0.001" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <button id="buyBtn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out">Mua (Market)</button>
                        <button id="sellBtn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out">Bán (Market)</button>
                    </div>
                </div>
            </div>

        </div>

        <!-- DCA Bot Section -->
        <div class="bg-gray-700/50 p-6 rounded-xl mt-6">
            <h2 class="text-xl font-semibold border-b border-gray-600 pb-3 mb-4">Bot DCA (Trung bình giá)</h2>
            <div class="bg-blue-900 border-l-4 border-blue-500 text-blue-100 p-4 rounded-lg mb-4" role="alert">
                <p class="font-bold">Lưu ý quan trọng</p>
                <p>Bot DCA sẽ chỉ hoạt động khi tab trình duyệt này đang mở. Nếu bạn đóng tab, bot sẽ dừng lại.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                <div>
                    <label for="dcaSymbol" class="block text-sm font-medium text-gray-300 mb-1">Cặp giao dịch</label>
                    <input type="text" id="dcaSymbol" value="BTCUSDT" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                </div>
                <div>
                    <label for="dcaAmount" class="block text-sm font-medium text-gray-300 mb-1">Số tiền mỗi lần mua (USDT)</label>
                    <input type="number" id="dcaAmount" placeholder="1" step="0.1" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                </div>
                 <div>
                    <label for="dcaFrequency" class="block text-sm font-medium text-gray-300 mb-1">Tần suất</label>
                    <select id="dcaFrequency" class="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                        <option value="3600000">Mỗi giờ</option>
                        <option value="86400000" selected>Mỗi ngày</option>
                        <option value="604800000">Mỗi tuần</option>
                        <option value="60000">Mỗi phút (để thử nghiệm)</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <button id="startDcaBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Bắt đầu Bot DCA</button>
                <button id="stopDcaBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300" disabled>Dừng Bot DCA</button>
            </div>
            <div id="dcaStatus" class="mt-4 bg-gray-900 p-3 rounded-lg text-sm text-center">Bot DCA đang không hoạt động.</div>
        </div>

        <!-- Market Scanner Section -->
        <div class="bg-gray-700/50 p-6 rounded-xl mt-6">
            <h2 class="text-xl font-semibold border-b border-gray-600 pb-3 mb-4">Kế Hoạch Giao Dịch Tự Động (V3.2.3)</h2>
             <div class="bg-blue-900 border-l-4 border-blue-500 text-blue-100 p-4 rounded-lg mb-4" role="alert">
                <p class="font-bold">Cách Hoạt Động</p>
                <p>Nhấn "Bắt đầu Quét". Bot sẽ phân tích toàn bộ thị trường và hiển thị tối đa 3 kế hoạch giao dịch chi tiết nhất dựa trên thuật toán Squeeze Breakout.</p>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <button id="startScannerBtn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Bắt đầu Quét</button>
                <button id="stopScannerBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300" disabled>Dừng Quét</button>
            </div>
            <div id="scannerStatus" class="mt-4 bg-gray-900 p-3 rounded-lg text-sm text-center">Công cụ quét đang không hoạt động.</div>
            
            <!-- Trading Plan Cards Container -->
            <div id="scannerResults" class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Trading Plan Cards will be populated here -->
            </div>
        </div>

        <!-- Log Area -->
        <div class="bg-gray-900/70 p-4 rounded-xl mt-6">
            <h2 class="text-lg font-semibold mb-2">Nhật ký hoạt động</h2>
            <div id="log" class="log-area bg-black h-48 overflow-y-auto p-3 rounded-lg text-xs text-gray-400"></div>
        </div>

    </div>

    <!-- Loading Spinner Modal -->
    <div id="loaderModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24"></div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const apiKeyInput = document.getElementById('apiKey');
            const apiSecretInput = document.getElementById('apiSecret');
            const saveApiBtn = document.getElementById('saveApi');
            const getBalanceBtn = document.getElementById('getBalance');
            const balanceInfoDiv = document.getElementById('balanceInfo');
            const symbolInput = document.getElementById('symbol');
            const qtyInput = document.getElementById('qty');
            const buyBtn = document.getElementById('buyBtn');
            const sellBtn = document.getElementById('sellBtn');
            const logDiv = document.getElementById('log');
            const loaderModal = document.getElementById('loaderModal');
            const dcaSymbolInput = document.getElementById('dcaSymbol');
            const dcaAmountInput = document.getElementById('dcaAmount');
            const dcaFrequencySelect = document.getElementById('dcaFrequency');
            const startDcaBtn = document.getElementById('startDcaBtn');
            const stopDcaBtn = document.getElementById('stopDcaBtn');
            const dcaStatusDiv = document.getElementById('dcaStatus');
            const startScannerBtn = document.getElementById('startScannerBtn');
            const stopScannerBtn = document.getElementById('stopScannerBtn');
            const scannerStatusDiv = document.getElementById('scannerStatus');
            const scannerResultsDiv = document.getElementById('scannerResults');

            const BYBIT_API_URL = 'https://api.bybit.com';
            let dcaIntervalId = null;
            let scannerIntervalId = null;
            let isScanning = false;

            apiKeyInput.value = localStorage.getItem('bybitApiKey') || '';
            apiSecretInput.value = localStorage.getItem('bybitApiSecret') || '';

            const showLoader = () => loaderModal.classList.remove('hidden');
            const hideLoader = () => loaderModal.classList.add('hidden');

            function logMessage(message, isError = false) {
                const timestamp = new Date().toLocaleString();
                const color = isError ? 'text-red-400' : 'text-green-400';
                logDiv.innerHTML += `<p class=${color}>[${timestamp}] ${message}</p>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            async function bybitPublicRequest(endpoint, params = {}) {
                try {
                    const serverTimeRes = await fetch(`${BYBIT_API_URL}/v5/market/time`);
                    const serverTimeData = await serverTimeRes.json();
                    if (serverTimeData.retCode !== 0) throw new Error("Could not sync Bybit server time.");
                    let url = `${BYBIT_API_URL}${endpoint}`;
                    if (Object.keys(params).length > 0) url += `?${new URLSearchParams(params)}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.retCode !== 0) {
                        if (data.retMsg.includes("Not supported symbols") || data.retMsg.includes("Instrument not found")) return null;
                        throw new Error(`Bybit API Error (${endpoint}): ${data.retMsg} (Code: ${data.retCode})`);
                    }
                    return data.result;
                } catch (error) {
                    logMessage(error.message, true);
                    return null;
                }
            }
            
            async function bybitRequest(endpoint, method, params = {}) {
                const apiKey = localStorage.getItem('bybitApiKey'), apiSecret = localStorage.getItem('bybitApiSecret');
                if (!apiKey || !apiSecret) { logMessage('API Key hoặc Secret chưa được lưu.', true); return null; }
                showLoader();
                try {
                    const serverTimeRes = await fetch(`${BYBIT_API_URL}/v5/market/time`);
                    const serverTimeData = await serverTimeRes.json();
                    const timestamp = (serverTimeData.result.timeNano / 1000000).toString();
                    const recvWindow = '20000';
                    let paramStr = method === 'POST' ? JSON.stringify(params) : new URLSearchParams(params).toString();
                    const signStr = timestamp + apiKey + recvWindow + paramStr;
                    const signature = CryptoJS.HmacSHA256(signStr, apiSecret).toString(CryptoJS.enc.Hex);
                    const headers = {'X-BAPI-API-KEY': apiKey, 'X-BAPI-TIMESTAMP': timestamp, 'X-BAPI-RECV-WINDOW': recvWindow, 'X-BAPI-SIGN': signature, 'Content-Type': 'application/json' };
                    let url = `${BYBIT_API_URL}${endpoint}${method === 'GET' && paramStr ? `?${paramStr}` : ''}`;
                    const options = { method, headers, body: method === 'POST' ? paramStr : undefined };
                    const response = await fetch(url, options);
                    const data = await response.json();
                    if (data.retCode !== 0) throw new Error(`Bybit API Error: ${data.retMsg} (Code: ${data.retCode})`);
                    logMessage(`Yêu cầu đến ${endpoint} thành công.`);
                    return data.result;
                } catch (error) {
                    logMessage(error.message, true);
                    return null;
                } finally {
                    hideLoader();
                }
            }
            
            async function fetchWalletBalance() {
                const result = await bybitRequest('/v5/account/wallet-balance', 'GET', { accountType: 'UNIFIED' });
                if (result?.list?.length > 0) {
                    const account = result.list[0];
                    let balanceHTML = `<p><strong>Tổng vốn (USD):</strong> ${parseFloat(account.totalEquity).toFixed(2)}</p><p><strong>Số dư khả dụng (USD):</strong> ${parseFloat(account.totalAvailableBalance).toFixed(2)}</p><hr class="my-2 border-gray-600"><ul class="space-y-1 max-h-40 overflow-y-auto">`;
                    account.coin.forEach(c => { if (parseFloat(c.walletBalance) > 0) balanceHTML += `<li><strong>${c.coin}:</strong> ${parseFloat(c.walletBalance).toFixed(6)}</li>`; });
                    balanceHTML += '</ul>';
                    balanceInfoDiv.innerHTML = balanceHTML;
                } else {
                    balanceInfoDiv.textContent = "Không thể lấy dữ liệu số dư.";
                }
            }

            async function placeOrder(orderParams) {
                if (!orderParams.symbol || !orderParams.qty || parseFloat(orderParams.qty) <= 0) { logMessage('Thông tin lệnh không hợp lệ.', true); return null; }
                const result = await bybitRequest('/v5/order/create', 'POST', orderParams);
                if (result?.orderId) { logMessage(`Đặt lệnh ${orderParams.side} ${orderParams.symbol} thành công! Order ID: ${result.orderId}`); return result; }
                return null;
            }

            saveApiBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim(), secret = apiSecretInput.value.trim();
                if (key && secret) { localStorage.setItem('bybitApiKey', key); localStorage.setItem('bybitApiSecret', secret); logMessage('API Key và Secret đã được lưu thành công!'); } 
                else { logMessage('Vui lòng nhập cả API Key và Secret.', true); }
            });
            getBalanceBtn.addEventListener('click', fetchWalletBalance);
            buyBtn.addEventListener('click', () => placeOrder({ category: 'spot', symbol: symbolInput.value.trim().toUpperCase(), side: 'Buy', orderType: 'Market', qty: qtyInput.value.trim() }));
            sellBtn.addEventListener('click', () => placeOrder({ category: 'spot', symbol: symbolInput.value.trim().toUpperCase(), side: 'Sell', orderType: 'Market', qty: qtyInput.value.trim() }));
            
            function updateDcaStatus(message) { dcaStatusDiv.textContent = message; }
            function stopDcaBot() { if (dcaIntervalId) { clearInterval(dcaIntervalId); dcaIntervalId = null; logMessage("Bot DCA đã dừng."); updateDcaStatus("Bot DCA đã dừng."); startDcaBtn.disabled = false; stopDcaBtn.disabled = true; [dcaSymbolInput, dcaAmountInput, dcaFrequencySelect].forEach(el => el.disabled = false); } }
            function startDcaBot() {
                const symbol = dcaSymbolInput.value.trim().toUpperCase(), amount = dcaAmountInput.value.trim(), frequencyMs = parseInt(dcaFrequencySelect.value, 10);
                if (!symbol || !amount || parseFloat(amount) <= 0) { logMessage("Vui lòng nhập thông tin hợp lệ cho bot DCA.", true); return; }
                logMessage(`Bắt đầu bot DCA: Mua ${amount} USDT cho ${symbol} mỗi ${dcaFrequencySelect.options[dcaFrequencySelect.selectedIndex].text}.`);
                startDcaBtn.disabled = true; stopDcaBtn.disabled = false; [dcaSymbolInput, dcaAmountInput, dcaFrequencySelect].forEach(el => el.disabled = true);
                const executeDcaPurchase = () => {
                    const nextRunTime = new Date(Date.now() + frequencyMs).toLocaleString();
                    logMessage(`[DCA] Thực hiện mua ${amount} USDT cho ${symbol}...`);
                    updateDcaStatus(`Đang hoạt động. Lần mua tiếp theo: ${nextRunTime}`);
                    placeOrder({ category: 'spot', symbol, side: 'Buy', orderType: 'Market', qty: amount, marketUnit: 'quoteCoin' });
                };
                executeDcaPurchase();
                dcaIntervalId = setInterval(executeDcaPurchase, frequencyMs);
            }
            startDcaBtn.addEventListener('click', startDcaBot);
            stopDcaBtn.addEventListener('click', stopDcaBot);
            
            const TA = { ema: (d,p) => { if (!d||d.length<p) return[]; const k=2/(p+1); let e=[d[0]]; for (let i=1;i<d.length;i++) e[i]=d[i]*k+e[i-1]*(1-k); return e }, atr: (k,p) => { if (!k||k.length<p) return[0]; let t=[]; for (let i=1;i<k.length;i++) t.push(Math.max(parseFloat(k[i][2])-parseFloat(k[i][3]),Math.abs(parseFloat(k[i][2])-parseFloat(k[i-1][4])),Math.abs(parseFloat(k[i][3])-parseFloat(k[i-1][4])))); return t.length===0?[0]:TA.ema(t,p) }, stdDev: (d,p) => { if(!d||d.length<p) return[]; let s=[]; for(let i=p-1;i<d.length;i++){ const sl=d.slice(i-p+1,i+1),m=sl.reduce((a,b)=>a+b,0)/p; s.push(Math.sqrt(sl.map(v=>Math.pow(v-m,2)).reduce((a,b)=>a+b,0)/p)) } return s }, adx: (k,p) => { if(!k||k.length<p*2) return[]; let h=k.map(i=>parseFloat(i[2])),l=k.map(i=>parseFloat(i[3])),pDM=[0],mDM=[0]; for (let i=1;i<h.length;i++){ let u=h[i]-h[i-1],d=l[i-1]-l[i];pDM.push(u>d&&u>0?u:0);mDM.push(d>u&&d>0?d:0)} let atr=TA.atr(k,p).slice(-pDM.length); if (atr.length===0) return[]; let spDM=TA.ema(pDM,p),smDM=TA.ema(mDM,p),pDI=[],mDI=[]; for(let i=0;i<spDM.length;i++){pDI.push(atr[i]===0?0:100*(spDM[i]/atr[i]));mDI.push(atr[i]===0?0:100*(smDM[i]/atr[i]))} let dxs=[]; for(let i=0;i<pDI.length;i++){ let den=pDI[i]+mDI[i];dxs.push(den===0?0:100*(Math.abs(pDI[i]-mDI[i])/den))} return TA.ema(dxs,p) }};

            const EDGE_COEF = { range:{tp1:0.65,tp2:0.35,tp1ATR:1.2,tp2ATR:2.2}, squeeze:{tp1:0.55,tp2:0.45,tp1ATR:1.5,tp2ATR:3.0}, trend:{tp1:0.55,tp2:0.45,tp1ATR:1.6,tp2ATR:3.2} };
            const RAOS_TH_BASE = { range: 0.66, trend: 0.68, squeeze: 0.72 };
            function toPP(x){ if(x==null||isNaN(x))return 0;const a=Math.abs(x);if(a===0)return 0;if(a<=0.05)return x*100;if(a>=5&&a<=100)return x;return x}
            function bpsToPP(b){ return(b??0)/100 }
            function clamp(x,l,h){ return Math.max(l,Math.min(h,x)) }
            function computeSpreadBps(b,a){ const bid=parseFloat(b),ask=parseFloat(a);if(!isFinite(bid)||!isFinite(ask)||ask<=0||bid<=0)return 1e9;const mid=(ask+bid)/2;return mid>0?((ask-bid)/mid)*10000:1e9 }
            function decideEntryType(c){ if(c.regime==="Range"&&c.spread_bps<=15)return"limit";return"stop" }
            function sanitizeCandidate(c){ c.atrPct=toPP(c.atrPct);c.slipPct=toPP(c.slipPct??(decideEntryType(c)==="limit"?0.03:0.06));c.feePctRT=toPP(c.feePctRT??(decideEntryType(c)==="limit"?0.2:0.3));c.spreadPP=bpsToPP(c.spread_bps);c.atrPct=clamp(c.atrPct,0,10);c.slipPct=clamp(c.slipPct,0,2);c.spreadPP=clamp(c.spreadPP,0,2);c.entryType=decideEntryType(c);return c }
            function costPctPP(c){ const hS=(c.entryType==="stop"?c.spreadPP/2:0);return c.feePctRT+c.slipPct+hS }
            function expectedGrossEdgePP(c){ const A=EDGE_COEF[c.regime.toLowerCase()]||EDGE_COEF.range,k=A.tp1*A.tp1ATR+A.tp2*A.tp2ATR;return k*c.atrPct }
            function minEdgeRequiredPP(c,l=0){ const m=c.entryType==="limit"?(l===0?1.8:l===1?1.7:1.6):(l===0?2.2:l===1?2:1.8);const f=l===2?0.33:0.35;return Math.max(m*costPctPP(c),f) }
            
            function gateOnce(cands, RAOS_TH_DYN, SPREAD_MAX, level) {
                const stats = {start:cands.length,afterSD:0,afterRAOS:0,afterEDGE:0,drops:{SPREAD:0,DEPTH:0,RAOS:0,EDGE:0,OTHER:0}};
                let candidates = cands.map(c => sanitizeCandidate({...c}));
                let keptSD = [];
                for(const c of candidates) {
                    if (c.spread_bps > SPREAD_MAX) { stats.drops.SPREAD++; continue; }
                    if ((c.depth1pct ?? 401) < 400) { stats.drops.DEPTH++; continue; }
                    keptSD.push(c);
                }
                stats.afterSD = keptSD.length;
                let keptRAOS = keptSD.filter(c => (c.raos ?? 0) >= (RAOS_TH_DYN[c.regime.toLowerCase()] || RAOS_TH_DYN.range));
                stats.drops.RAOS = keptSD.length - keptRAOS.length;
                if (keptRAOS.length < 5 && keptSD.length > 0) {
                    logMessage(`[Gate L${level}] RAOS Fallback: ${keptRAOS.length} pass, lấy Top 7.`);
                    keptRAOS = keptSD.sort((a,b)=>b.raos - a.raos).slice(0, Math.min(7, keptSD.length));
                    stats.drops.RAOS = 0;
                }
                stats.afterRAOS = keptRAOS.length;
                let keptEDGE = [];
                for(const c of keptRAOS) {
                    const gross = expectedGrossEdgePP(c), need = minEdgeRequiredPP(c, level);
                    if (gross < need) {
                        stats.drops.EDGE++;
                        // logMessage(`[EDGE-DROP] ${c.symbol} r=${c.regime} e=${c.entryType} atr=${c.atrPct.toFixed(2)}% gross=${gross.toFixed(2)}% cost=${costPctPP(c).toFixed(2)}% need=${need.toFixed(2)}%`, true);
                        continue;
                    }
                    keptEDGE.push(c);
                }
                stats.afterEDGE = keptEDGE.length;
                keptEDGE.sort((a,b)=> b.raos - a.raos || a.spread_bps - b.spread_bps);
                return {stats, picks: keptEDGE.slice(0,3)};
            }

            function chooseTop3(cs, RAOS_TH_DYN, SPREAD_MAX){ 
                for(let l=0;l<=2;l++){
                    const r = gateOnce(cs, RAOS_TH_DYN, SPREAD_MAX, l);
                    logMessage(`[Gate L${l}] start=${r.stats.start}->SD=${r.stats.afterSD}->RAOS=${r.stats.afterRAOS}->EDGE=${r.stats.afterEDGE}|Drops:S:${r.stats.drops.SPREAD},D:${r.stats.drops.DEPTH},R:${r.stats.drops.RAOS},E:${r.stats.drops.EDGE}`);
                    if(r.picks.length) return {level:l, picks:r.picks};
                }
                const s = cs.map(sanitizeCandidate).filter(c=>c.spread_bps<=15&&(c.depth1pct??0)>=1000).sort((a,b)=>b.raos-a.raos);
                const t=s[0];
                if(!t)return{level:"none",picks:[]};
                t.regime='Micro-Grid'; t.plan={entry:"Micro-grid ±0.6×ATR",SL:"N/A",TP1:"N/A",TP2:"N/A"};
                return{level:"L3-failopen",picks:[t]};
            }

            function updateScannerStatus(message) { scannerStatusDiv.textContent = message; }

            function displayScanResults(results) {
                scannerResultsDiv.innerHTML = '';
                if (!results || results.length === 0) {
                    scannerResultsDiv.innerHTML = '<p class="text-center text-gray-400 col-span-full">Không có kế hoạch giao dịch nào phù hợp. Thị trường có thể đang rất yên tĩnh.</p>';
                    return;
                }
                results.forEach(item => {
                    const regimeClass = { 'Trend':'regime-trend', 'Range':'regime-range', 'Squeeze':'regime-squeeze', 'Micro-Grid':'regime-micro-grid' }[item.regime] || 'regime-none';
                    const specialNotes = {
                        'HAEDALUSDT': 'Cẩn trọng với râu nến dài (FOMO wick).',
                        'PENDLEUSDT': 'Cân nhắc tăng buffer lên 0.10%-0.12% nếu nhiễu.',
                        'ALCHUSDT': 'Bỏ qua nếu VolumeZ < 3 khi phá vỡ.'
                    }[item.symbol] || 'Không có.';
                    
                    const cardHTML = `
                        <div class="bg-gray-900/50 rounded-xl p-4 border border-gray-700 flex flex-col space-y-3">
                            <div class="flex justify-between items-center">
                                <h3 class="text-lg font-bold text-cyan-400">${item.symbol}</h3>
                                <span class="px-2 py-1 text-xs font-semibold rounded-full ${regimeClass}">${item.regime}</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">RAOS</span>
                                <span class="font-semibold text-yellow-400">${item.raos?.toFixed(3) ?? 'N/A'}</span>
                            </div>
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Vốn Phân Bổ</span>
                                <span class="font-bold text-white">${item.allocationUSD}$</span>
                            </div>
                            <div class="border-t border-gray-700 pt-3 space-y-2 text-xs">
                                <p class="font-semibold text-gray-300">Kế hoạch Lệnh:</p>
                                <p><strong class="text-green-400">Entry:</strong> ${item.plan.entry}</p>
                                <p><strong class="text-red-400">Stop Loss:</strong> ${item.plan.SL}</p>
                                <p><strong class="text-blue-400">Take Profit:</strong> ${item.plan.TP1} (TP1) / ${item.plan.TP2} (TP2)</p>
                                <p><strong class="text-purple-400">Quản Trị:</strong> Dời SL về hòa vốn khi chạm TP1.</p>
                            </div>
                            <div class="border-t border-gray-700 pt-3 space-y-2 text-xs">
                                <p class="font-semibold text-gray-300">Lưu ý Riêng:</p>
                                <p class="text-amber-400">${specialNotes}</p>
                            </div>
                            <div class="border-t border-gray-700 pt-3 space-y-2 text-xs">
                                 <p class="font-semibold text-gray-300">Check-list An Toàn:</p>
                                 <ul class="list-disc list-inside text-gray-400">
                                    <li>Xác nhận Squeeze & VolumeZ &ge; 3.</li>
                                    <li>Tránh vào lệnh khi có râu nến dài.</li>
                                    <li>Chi phí hợp lệ (~0.41-0.46%).</li>
                                    <li>ATR% đủ lớn (>0.42%).</li>
                                 </ul>
                            </div>
                        </div>
                    `;
                    scannerResultsDiv.innerHTML += cardHTML;
                });
            }
            
            async function executeScan() {
                if (isScanning) return;
                isScanning = true;
                showLoader();
                logMessage(`[Scanner] Bắt đầu quét với thuật toán V3.2.3...`);
                
                try {
                    updateScannerStatus(`(B0) Lấy danh sách cặp giao dịch`);
                    const instrumentsInfo = await bybitPublicRequest('/v5/market/instruments-info', { category: 'spot' });
                    if (!instrumentsInfo?.list) throw new Error("Không thể lấy danh sách các cặp giao dịch.");
                    const allTradablePairs = instrumentsInfo.list.filter(i => i.status === 'Trading' && i.quoteCoin === 'USDT').map(i => i.symbol);
                    logMessage(`[Scanner] Tìm thấy ${allTradablePairs.length} cặp SPOT USDT.`);

                    updateScannerStatus(`(B1) Lấy dữ liệu toàn thị trường`);
                    const allTickersData = await bybitPublicRequest('/v5/market/tickers', { category: 'spot' });
                    if (!allTickersData?.list) throw new Error("Không thể lấy danh sách tickers.");
                    let universe = allTickersData.list.filter(t => allTradablePairs.includes(t.symbol) && parseFloat(t.turnover24h) > 500000);
                    logMessage(`[Scanner] ${universe.length} cặp thanh khoản tốt được đưa vào phân tích.`);

                    updateScannerStatus(`(B2) Lấy Order Book & tính Spread`);
                    const obPromises = universe.map(t => bybitPublicRequest('/v5/market/orderbook', { category: 'spot', symbol: t.symbol, limit: 1 }));
                    const obResults = await Promise.all(obPromises);
                    let enrichedCandidates = [];
                    for (let i = 0; i < universe.length; i++) {
                        const ticker = universe[i], ob = obResults[i];
                        const ask = ob?.a?.[0]?.[0] ?? ticker.ask1Price, bid = ob?.b?.[0]?.[0] ?? ticker.bid1Price;
                        enrichedCandidates.push({ ...ticker, spread_bps: computeSpreadBps(bid, ask), _bid: bid, _ask: ask });
                    }
                    enrichedCandidates.forEach((c, i) => i < 3 && logMessage(`[Sanity Check] ${c.symbol} bid=${c._bid} ask=${c._ask} -> spread_bps=${c.spread_bps.toFixed(2)}`));
                    
                    const allSpreads = enrichedCandidates.map(c => c.spread_bps).filter(s => isFinite(s)).sort((a,b) => a-b);
                    const p60 = allSpreads[Math.floor(0.60 * allSpreads.length)];
                    const SPREAD_MAX = clamp(p60, 15, 25);
                    logMessage(`[Scanner] Ngưỡng Spread Động (P60, clamped 15-25): ${SPREAD_MAX.toFixed(2)} bps`);

                    updateScannerStatus(`(B3) Lấy Klines`);
                    const klinePromises = enrichedCandidates.map(t => bybitPublicRequest('/v5/market/kline', { category: 'spot', symbol: t.symbol, interval: '15', limit: 200 }));
                    const klineResults = await Promise.all(klinePromises);
                    let candidates = [];
                    for (let i = 0; i < enrichedCandidates.length; i++) {
                        if (klineResults[i]?.list?.length >= 50) {
                            const klines = klineResults[i].list.reverse();
                            const closes = klines.map(k => parseFloat(k[4])), lastPrice = closes[closes.length - 1];
                            const lastAtr = TA.atr(klines, 14).pop() || 0, atrPct = lastPrice > 0 ? (lastAtr / lastPrice) * 100 : 0;
                            candidates.push({ ...enrichedCandidates[i], klines, atrPct, lastAtr });
                        }
                    }
                    if (candidates.length === 0) throw new Error("Không có cặp nào có đủ dữ liệu kline.");
                    
                    const atrPercentiles = candidates.map(p => p.atrPct).sort((a,b)=>a-b);
                    const p40_atr = atrPercentiles[Math.floor(atrPercentiles.length*0.4)], p95_atr = atrPercentiles[Math.floor(atrPercentiles.length*0.95)];
                    const atrMin=Math.max(p40_atr,0.12), atrMax=Math.min(p95_atr,6.0);
                    logMessage(`[Scanner] Ngưỡng ATR động: [${atrMin.toFixed(2)}%, ${atrMax.toFixed(2)}%]`);
                    
                    updateScannerStatus(`(B4) Chấm điểm ${candidates.length} cặp`);
                    let processedCandidates = [];
                    let perRegime = {range:[], trend:[], squeeze:[]};
                    for (const cand of candidates) {
                        if (cand.atrPct < atrMin || cand.atrPct > atrMax) continue;
                        const closes=cand.klines.map(k=>parseFloat(k[4])),adx=TA.adx(cand.klines,14).pop()||0,sma20=closes.slice(-20).reduce((a,b)=>a+b,0)/20;
                        const stdDev=TA.stdDev(closes,20).pop()||0,bbWidth=sma20>0?((sma20+2*stdDev)-(sma20-2*stdDev))/sma20:0;
                        let regime="Range"; if(adx>=22)regime="Trend"; if(bbWidth<0.035&&regime!=='Trend')regime="Squeeze";
                        const roc15m=closes.length>1?(closes[closes.length-1]/closes[closes.length-2]-1)*100:0, roc1h=closes.length>4?(closes[closes.length-1]/closes[closes.length-5]-1)*100:0;
                        const ema20=TA.ema(closes,20).pop()||0,ema50=TA.ema(closes,50).pop()||0,emaSlope=ema20>ema50?1:-1;
                        let s_trend=0.4*roc15m+0.2*roc1h+0.2*emaSlope-0.2*(cand.spread_bps/20);
                        let s_range=cand.lastAtr>0?0.5*(Math.abs(closes[closes.length-1]-sma20)/cand.lastAtr)-0.3*bbWidth-0.2*(cand.spread_bps/20):-1;
                        let s_squeeze=-0.5*bbWidth+0.3*roc15m-0.2*(cand.spread_bps/20);
                        const w={range:0.5,squeeze:0.3,trend:0.2};
                        const raos=w.range*s_range+w.squeeze*s_squeeze+w.trend*s_trend;
                        const finalCand = { ...cand, raos, regime, depth1pct: 500 };
                        processedCandidates.push(finalCand);
                        perRegime[regime.toLowerCase()]?.push(raos);
                    }
                    
                    const q=(arr,p)=>arr.length?arr.slice().sort((a,b)=>a-b)[Math.floor(p*arr.length)]:0;
                    const RAOS_TH_DYN = {
                        range: Math.max(RAOS_TH_BASE.range, q(perRegime.range, 0.80) - 0.01),
                        trend: Math.max(RAOS_TH_BASE.trend, q(perRegime.trend, 0.75) - 0.01),
                        squeeze: Math.max(RAOS_TH_BASE.squeeze, q(perRegime.squeeze, 0.75) - 0.01),
                    };
                    logMessage(`[Diag] RAOS Range (P80-based TH): ${RAOS_TH_DYN.range.toFixed(3)}`);
                    
                    const {level, picks} = chooseTop3(processedCandidates, RAOS_TH_DYN, SPREAD_MAX);
                    
                    const finalPicks = picks.map((c, i) => {
                        const {netEdgePct} = (() => { const g=expectedGrossEdgePP(c),co=costPctPP(c); return {netEdgePct:g-co} })();
                        let plan = c.plan;
                        if (!plan) { plan = c.regime==="Squeeze"?{entry:"Buy-Stop tại Donchian20 High × (1+buffer)",SL:"max(đáy nến phá vỡ, entry - 0.9*ATR)",TP1:"+1.5*ATR",TP2:"+3.0*ATR"}:c.regime==="Range"?{entry:"Limit gần VWAP-0.6*ATR",SL:"-1.0*ATR",TP1:"+1.2*ATR",TP2:"+2.2*ATR"}:{entry:"Buy-stop trên EMA20",SL:"-0.9*ATR",TP1:"+1.6*ATR",TP2:"+3.2*ATR"}}
                        return { ...c, netEdgePct, plan, allocationUSD: [2.8, 2.8, 2.4][i] ?? 2.4 };
                    });

                    displayScanResults(finalPicks);
                    logMessage(`[Scanner] Quét hoàn tất. Hiển thị ${finalPicks.length} kế hoạch giao dịch (Level ${level}).`);
                    updateScannerStatus(`Quét xong. Cập nhật lần cuối: ${new Date().toLocaleTimeString()}`);
                
                } catch (error) {
                    logMessage(`[Scanner] Lỗi: ${error.message}`, true);
                    updateScannerStatus("Đã xảy ra lỗi. Kiểm tra log và thử lại.");
                    displayScanResults([]);
                } finally {
                    isScanning = false;
                    hideLoader();
                }
            }

            function stopScanner() { if (scannerIntervalId) { clearInterval(scannerIntervalId); scannerIntervalId=null; logMessage("Công cụ quét đã dừng."); updateScannerStatus("Công cụ quét đã dừng."); startScannerBtn.disabled=false; stopScannerBtn.disabled=true; } }
            function startScanner() {
                logMessage("Bắt đầu công cụ quét thị trường...");
                startScannerBtn.disabled = true; stopScannerBtn.disabled = false;
                executeScan();
                scannerIntervalId = setInterval(executeScan, 120000); 
            }

            startScannerBtn.addEventListener('click', startScanner);
            stopScannerBtn.addEventListener('click', stopScanner);
            logMessage('Bot đã sẵn sàng. Vui lòng lưu API key để bắt đầu.');
        });
    </script>
</body>
</html>

