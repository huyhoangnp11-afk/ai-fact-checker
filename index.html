<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bybit Bot v9.0 - Production Ready</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
  <style>
    /* ═══════════════════════════════════════════════════════════════
       MODERN LIGHT THEME - Professional & Clean ☀️
       ═══════════════════════════════════════════════════════════════ */

    :root {
      --bg: #f5f7fa;
      --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
      --card: #ffffff;
      --card-hover: #fafbfc;
      --border: #e1e4e8;
      --border-light: #f0f2f5;
      --text: #1a202c;
      --text-secondary: #4a5568;
      --text-dim: #718096;
      --accent: #4f46e5;
      --accent-hover: #4338ca;
      --accent-light: #eef2ff;
      --success: #059669;
      --success-light: #d1fae5;
      --danger: #dc2626;
      --danger-light: #fee2e2;
      --warning: #d97706;
      --warning-light: #fef3c7;
      --info: #0891b2;
      --info-light: #cffafe;
      --shadow: 0 2px 8px rgba(0,0,0,0.06);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* ═══════════════════════════════════════════════════════════════
       ANIMATIONS & TRANSITIONS
       ═══════════════════════════════════════════════════════════════ */

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .fade-in {
      animation: fadeIn 0.4s ease-out;
    }

    .slide-in {
      animation: slideIn 0.4s ease-out;
    }

    .pulse {
      animation: pulse 2s ease-in-out infinite;
    }

    .spin {
      animation: spin 1s linear infinite;
    }

    .bounce {
      animation: bounce 1s ease-in-out infinite;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      line-height: 1.6;
      font-size: 14px;
      min-height: 100vh;
    }

    /* ═══════════════════════════════════════════════════════════════
       LAYOUT
       ═══════════════════════════════════════════════════════════════ */

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: var(--shadow-md);
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      color: var(--text);
    }

    .status {
      padding: 8px 16px;
      background: var(--border);
      border-radius: 8px;
      font-size: 13px;
      color: var(--text-dim);
    }

    .status.active { background: var(--success); color: white; }
    .status.error { background: var(--danger); color: white; }

    /* ═══════════════════════════════════════════════════════════════
       TABS SYSTEM
       ═══════════════════════════════════════════════════════════════ */

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0;
    }

    .tab {
      padding: 12px 24px;
      background: transparent;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      margin-bottom: -2px;
    }

    .tab:hover {
      color: var(--text);
      background: rgba(59, 130, 246, 0.1);
    }

    .tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* ═══════════════════════════════════════════════════════════════
       GRID & CARDS
       ═══════════════════════════════════════════════════════════════ */

    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 20px;
      margin-bottom: 20px;
    }

    .col-3 { grid-column: span 3; }
    .col-4 { grid-column: span 4; }
    .col-6 { grid-column: span 6; }
    .col-8 { grid-column: span 8; }
    .col-12 { grid-column: span 12; }

    @media (max-width: 1200px) {
      .col-3, .col-4 { grid-column: span 6; }
    }

    @media (max-width: 768px) {
      .col-3, .col-4, .col-6, .col-8 { grid-column: span 12; }
    }

    /* ═══════════════════════════════════════════════════════════════
       RESPONSIVE ENHANCEMENTS
       ═══════════════════════════════════════════════════════════════ */

    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 16px;
        text-align: center;
      }

      .header h1 {
        font-size: 20px;
      }

      .tabs {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tab {
        padding: 10px 16px;
        font-size: 13px;
        white-space: nowrap;
      }

      .card {
        padding: 16px;
        border-radius: 12px;
      }

      .card-title {
        font-size: 14px;
      }

      .btn {
        padding: 10px 16px;
        font-size: 13px;
      }

      .modal-content {
        padding: 24px;
        margin: 16px;
      }

      .grid {
        gap: 12px;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 12px;
      }

      .header {
        padding: 16px;
        margin-bottom: 12px;
      }

      body {
        font-size: 13px;
      }
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      animation: fadeIn 0.5s ease-out;
    }

    .card:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
      border-color: var(--accent);
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* ═══════════════════════════════════════════════════════════════
       FORM ELEMENTS
       ═══════════════════════════════════════════════════════════════ */

    label {
      display: block;
      color: var(--text-dim);
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input, select {
      width: 100%;
      background: var(--card);
      border: 1.5px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      transition: all 0.2s;
    }

    input:hover, select:hover {
      border-color: var(--text-dim);
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
      background: white;
      box-shadow: 0 0 0 4px var(--accent-light);
    }

    input[type="checkbox"] {
      width: auto;
      accent-color: var(--accent);
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .form-row > * {
      flex: 1;
      min-width: 150px;
    }

    /* ═══════════════════════════════════════════════════════════════
       BUTTONS
       ═══════════════════════════════════════════════════════════════ */

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: var(--shadow);
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    .btn-secondary {
      background: var(--border);
      color: var(--text);
    }

    /* ═══════════════════════════════════════════════════════════════
       TOOLTIPS
       ═══════════════════════════════════════════════════════════════ */

    [data-tooltip] {
      position: relative;
      cursor: help;
    }

    [data-tooltip]::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-8px);
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: var(--shadow-lg);
    }

    [data-tooltip]::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-2px);
      border: 6px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.9);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
    }

    [data-tooltip]:hover::before,
    [data-tooltip]:hover::after {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* ═══════════════════════════════════════════════════════════════
       MODAL / DIALOG
       ═══════════════════════════════════════════════════════════════ */

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--card);
      border-radius: 16px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease-out;
    }

    .modal-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text);
    }

    .modal-body {
      color: var(--text-secondary);
      margin-bottom: 24px;
      line-height: 1.6;
    }

    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #2a3254;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-group {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    /* ═══════════════════════════════════════════════════════════════
       LOG CONSOLE
       ═══════════════════════════════════════════════════════════════ */

    .log-console {
      background: #1a1f2e;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      height: 300px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
    }

    .log-line {
      margin-bottom: 4px;
    }

    .log-info { color: #94a3b8; }
    .log-success { color: #10b981; }
    .log-warning { color: #fbbf24; }
    .log-error { color: #f87171; }

    /* ═══════════════════════════════════════════════════════════════
       TABLE
       ═══════════════════════════════════════════════════════════════ */

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th {
      background: var(--border-light);
      color: var(--text-secondary);
      font-weight: 700;
      text-align: left;
      padding: 14px 16px;
      border-bottom: 2px solid var(--border);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    td {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-light);
      color: var(--text);
    }

    tr:hover {
      background: var(--accent-light);
      transition: background 0.2s;
    }

    /* ═══════════════════════════════════════════════════════════════
       UTILITIES
       ═══════════════════════════════════════════════════════════════ */

    .badge {
      padding: 5px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge-success {
      background: var(--success-light);
      color: var(--success);
      border: 1px solid var(--success);
    }
    .badge-danger {
      background: var(--danger-light);
      color: var(--danger);
      border: 1px solid var(--danger);
    }
    .badge-warning {
      background: var(--warning-light);
      color: var(--warning);
      border: 1px solid var(--warning);
    }
    .badge-info {
      background: var(--info-light);
      color: var(--info);
      border: 1px solid var(--info);
    }

    .text-success { color: var(--success); }
    .text-danger { color: var(--danger); }
    .text-warning { color: var(--warning); }
    .text-dim { color: var(--text-dim); }

    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-between { justify-content: space-between; }
    .gap-2 { gap: 8px; }
    .gap-4 { gap: 16px; }
    .mt-4 { margin-top: 16px; }
    .mb-4 { margin-bottom: 16px; }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px 12px;
      background: var(--bg);
      border-radius: 6px;
      font-size: 13px;
      text-transform: none;
      letter-spacing: 0;
    }

    .checkbox-label:hover {
      background: var(--border);
    }

    /* ═══════════════════════════════════════════════════════════════
       UTILITY CLASSES & NEW COMPONENTS
       ═══════════════════════════════════════════════════════════════ */

    .mt-3 { margin-top: 12px; }
    .mb-3 { margin-bottom: 12px; }

    /* Metrics Grid */
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }

    .metric-item {
      background: var(--bg);
      padding: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .metric-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
    }

    .metric-value.positive {
      color: var(--success);
    }

    .metric-value.negative {
      color: var(--danger);
    }
  </style>
</head>
<body>

<div class="container">

  <!-- ═══════════════════════════════════════════════════════════════
       HEADER
       ═══════════════════════════════════════════════════════════════ -->

  <div class="header">
    <div>
      <h1>🚀 Bybit Bot v9.0 <span class="badge badge-danger" style="font-size: 14px;">AGGRESSIVE MODE 💰</span></h1>
      <div class="text-dim" style="font-size: 12px; margin-top: 4px;">Production-Ready Trading System | Profit-Optimized 🔥</div>
    </div>
    <div class="status" id="systemStatus">Ready</div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TABS NAVIGATION
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tabs">
    <button class="tab active" data-tab="setup">⚙️ Setup</button>
    <button class="tab" data-tab="strategy">🎯 Strategy</button>
    <button class="tab" data-tab="live">▶️ Live Trading</button>
    <button class="tab" data-tab="results">📊 Results</button>
    <button class="tab" data-tab="backtest">📈 Backtesting</button>
    <button class="tab" data-tab="analytics">📊 Analytics</button>
    <button class="tab" data-tab="alerts">🔔 Alerts</button>
    <button class="tab" data-tab="advanced">🤖 Advanced</button>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 1: SETUP
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content active" id="tab-setup">
    <div class="grid">

      <!-- Mode & Capital -->
      <div class="card col-4">
        <div class="card-title">💼 Mode & Capital</div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="simMode" checked>
            <span>🎮 SIM Mode (Virtual Trading)</span>
          </label>
        </div>

        <div id="simSettings">
          <div class="form-group">
            <label>Virtual Capital (USDT)</label>
            <input type="number" id="simCapital" value="1000" min="100" step="100">
          </div>
        </div>

        <div id="apiSettings" style="display: none;">
          <div class="form-group">
            <label>API Key</label>
            <input type="password" id="apiKey" placeholder="Your API Key">
          </div>
          <div class="form-group">
            <label>API Secret</label>
            <input type="password" id="apiSecret" placeholder="Your API Secret">
          </div>
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="useTestnet">
              <span>Use Testnet</span>
            </label>
          </div>
        </div>
      </div>

      <!-- Telegram Notifications -->
      <div class="card col-4">
        <div class="card-title">📱 Telegram</div>

        <div class="form-group">
          <label>Bot Token</label>
          <input type="text" id="tgToken" placeholder="123456:ABC...">
        </div>

        <div class="form-group">
          <label>Chat ID</label>
          <input type="text" id="tgChat" placeholder="123456789">
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="tgEnabled">
            <span>Enable Notifications</span>
          </label>
        </div>
      </div>

      <!-- Quick Stats -->
      <div class="card col-4">
        <div class="card-title">📈 Quick Stats</div>

        <div style="display: grid; gap: 12px;">
          <div class="flex justify-between">
            <span class="text-dim">Mode:</span>
            <span id="statMode" class="badge badge-info">SIM</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Balance:</span>
            <span id="statBalance" class="text-success">1,000 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Total PnL:</span>
            <span id="statPnL">0.00 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Total Fees:</span>
            <span id="statFees" class="text-warning">0.00 USDT</span>
          </div>
          <div class="flex justify-between">
            <span class="text-dim">Win Rate:</span>
            <span id="statWinRate">0%</span>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 2: STRATEGY
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-strategy">
    <div class="grid">

      <!-- Strategy Selection -->
      <div class="card col-6">
        <div class="card-title">🎯 Strategy</div>

        <div class="form-group">
          <label>Trading Strategy</label>
          <select id="strategyType">
            <option value="pump">🚀 Pump Hunter PRO</option>
            <option value="scalping">⚡ Scalping (EMA Cross)</option>
            <option value="smart">🧠 Smart Entry (SR + Fib)</option>
            <option value="pullback">📉 Pullback Score</option>
          </select>
        </div>

        <div class="form-group">
          <label>Timeframe</label>
          <select id="timeframe">
            <option value="1">1 minute</option>
            <option value="3">3 minutes</option>
            <option value="5" selected>5 minutes</option>
            <option value="15">15 minutes</option>
            <option value="30">30 minutes</option>
          </select>
        </div>

        <div class="form-group">
          <label>Position Size (USDT)</label>
          <input type="number" id="positionSize" value="100" min="10" step="10">
        </div>
      </div>

      <!-- Risk Management -->
      <div class="card col-6">
        <div class="card-title">🛡️ Risk Management</div>

        <div class="form-group">
          <label>Take Profit (%)</label>
          <input type="number" id="takeProfit" value="1.5" step="0.1">
        </div>

        <div class="form-group">
          <label>Stop Loss (%)</label>
          <input type="number" id="stopLoss" value="0.8" step="0.1">
        </div>

        <div class="form-group">
          <label>Trading Fee (% per trade)</label>
          <input type="number" id="tradingFee" value="0.1" step="0.01" min="0" max="1">
          <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
            Bybit: Spot ~0.1%, Futures ~0.055%
          </div>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="trailingStop">
            <span>🔄 Trailing Stop</span>
          </label>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="conservativeMode">
            <span>💰 Conservative Mode (High Win Rate)</span>
          </label>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="quickProfitMode">
            <span>⚡ QUICK PROFIT MODE - Vào nhanh, lời nhanh (SCALPING)</span>
          </label>
          <div style="font-size: 11px; color: var(--warning); margin-top: 4px; padding: 8px; background: var(--warning-light); border-radius: 6px; border-left: 3px solid var(--warning);">
            <strong>⚠️ CẢNH BÁO:</strong> Chế độ này CUC KỲ RISK!<br>
            • TP siêu nhỏ: 0.3-0.8% (lời nhanh)<br>
            • Leverage cao: 10-20x<br>
            • Nhiều lệnh liên tục (scalping)<br>
            • Có thể mất vốn rất nhanh nếu market đi ngược!
          </div>
        </div>
      </div>

      <!-- Filters -->
      <div class="card col-12">
        <div class="card-title">🔍 Market Filters</div>

        <div class="form-row">
          <div class="form-group">
            <label>Min Volume (USDT)</label>
            <input type="number" id="minVolume" value="1000000" step="100000">
          </div>

          <div class="form-group">
            <label>Min Pump (%)</label>
            <input type="number" id="minPump" value="1.0" step="0.1">
          </div>

          <div class="form-group">
            <label>Max Spread (%)</label>
            <input type="number" id="maxSpread" value="0.3" step="0.05">
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="btcFilter" checked>
              <span>📊 BTC Trend Filter</span>
            </label>
          </div>
        </div>
      </div>

      <!-- Risk Management -->
      <div class="card col-12">
        <div class="card-title">🛡️ Advanced Risk Management</div>

        <div class="form-row">
          <div class="form-group">
            <label>Max Positions <span class="badge badge-warning">AGGRESSIVE 🚀</span></label>
            <input type="number" id="maxPositions" value="5" min="1" max="10">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Trade tối đa bao nhiêu coin cùng lúc (Default: 5 - More profit!)
            </div>
          </div>

          <div class="form-group">
            <label>Max Drawdown (%) <span class="badge badge-warning">AGGRESSIVE 🔥</span></label>
            <input type="number" id="maxDrawdownPercent" value="30" min="5" max="50" step="1">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Dừng bot khi lỗ quá % này
            </div>
          </div>

          <div class="form-group">
            <label>Daily Loss Limit (USDT) <span class="badge badge-warning">200 💪</span></label>
            <input type="number" id="dailyLossLimit" value="200" min="10" step="10">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Giới hạn lỗ tối đa trong 1 ngày (Higher for more trades!)
            </div>
          </div>

          <div class="form-group">
            <label>Risk per Trade (%) <span class="badge badge-warning">AGGRESSIVE 3%</span></label>
            <input type="number" id="riskPerTrade" value="3" min="0.5" max="5" step="0.5">
            <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
              Rủi ro % vốn cho mỗi lệnh
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 3: LIVE TRADING
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-live">
    <div class="grid">

      <!-- Controls -->
      <div class="card col-12">
        <div class="card-title">🎮 Trading Controls</div>

        <div class="btn-group">
          <button class="btn btn-success" id="btnStart">▶️ Start Trading</button>
          <button class="btn btn-danger" id="btnStop" disabled>⏹️ Stop</button>
          <button class="btn btn-primary" id="btnSmartScan">🔍 Smart Scan (All Coins)</button>
          <button class="btn btn-secondary" id="btnTest">🧪 Test System</button>
        </div>

        <div style="margin-top: 12px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 12px; color: var(--text-dim);">
          <strong>Smart Scan:</strong> Quét toàn bộ coin Bybit, phân tích kỹ thuật và chọn tín hiệu tốt nhất
        </div>
      </div>

      <!-- Active Positions -->
      <div class="card col-12">
        <div class="card-title">📊 Active Positions (<span id="positionCount">0</span>/<span id="maxPosCount">3</span>)</div>
        <div style="overflow-x: auto;">
          <table>
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Entry</th>
                <th>Current</th>
                <th>Size</th>
                <th>Unrealized PnL</th>
                <th>%</th>
                <th>Time</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="activePositionsTable">
              <tr>
                <td colspan="8" style="text-align: center; color: var(--text-dim); padding: 20px;">No active positions</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Live Log -->
      <div class="card col-12">
        <div class="card-title">📝 Live Log</div>
        <div class="log-console" id="liveLog">
          <div class="log-line log-info">[SYSTEM] Bybit Bot v9.0 CLEAN initialized successfully</div>
          <div class="log-line log-success">[READY] Click "Start Trading" to begin</div>
        </div>
      </div>

      <!-- Price Chart -->
      <div class="card col-6">
        <div class="card-title">📈 Price Chart (Realtime)</div>

        <!-- Chart Controls -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.charts.priceChart?.resetZoom()"
                  data-tooltip="Reset zoom và pan">
            🔄 Reset Zoom
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(1)"
                  data-tooltip="Toggle EMA 20">
            📊 EMA 20
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(2)"
                  data-tooltip="Toggle EMA 50">
            📊 EMA 50
          </button>
          <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;"
                  onclick="BybitBot.toggleChartDataset(3)"
                  data-tooltip="Toggle Volume">
            📊 Volume
          </button>
        </div>

        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="priceChart"></canvas>
        </div>

        <div style="margin-top: 8px; font-size: 11px; color: var(--text-dim); text-align: center;">
          💡 Scroll để zoom, Ctrl + Kéo để pan, Click legend để toggle indicators
        </div>
      </div>

      <!-- PnL Chart -->
      <div class="card col-6">
        <div class="card-title">💰 PnL Chart</div>
        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="pnlChart"></canvas>
        </div>
      </div>

      <!-- Technical Analysis -->
      <div class="card col-12">
        <div class="card-title">🔍 Technical Analysis (Auto)</div>
        <div id="technicalAnalysis" class="log-console" style="height: 200px;">
          <div class="log-line log-info">Technical analysis will appear here when trading starts...</div>
        </div>
      </div>

      <!-- News Sentiment -->
      <div class="card col-12">
        <div class="card-title">📰 News Sentiment (Real-time)</div>
        <div id="newsSentiment" class="log-console" style="height: 150px;">
          <div class="log-line log-info">News sentiment will appear here when trading starts...</div>
        </div>
        <div id="newsHeadlines" style="margin-top: 10px; font-size: 11px; color: var(--text-dim);">
          <div style="font-weight: 600; margin-bottom: 6px;">Latest Headlines:</div>
          <div id="headlinesList" style="max-height: 100px; overflow-y: auto;"></div>
        </div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 4: RESULTS
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-results">
    <div class="grid">

      <!-- Performance Summary -->
      <div class="card col-12">
        <div class="card-title">📊 Performance Dashboard</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px;">
          <div>
            <div class="text-dim" style="font-size: 11px;">Total Trades</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfTrades">0</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Win Rate</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfWinRate">0%</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Profit Factor</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfProfitFactor">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Avg R:R</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfAvgRR">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Max Drawdown</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--danger);" id="perfMaxDD">0%</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Gross PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfGrossPnL">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Total Fees</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--warning);" id="perfFees">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Net PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfPnL">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Best Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--success);" id="perfBest">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Worst Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px; color: var(--danger);" id="perfWorst">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Avg Trade</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfAvg">0.00</div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 11px;">Today's PnL</div>
            <div style="font-size: 24px; font-weight: 600; margin-top: 4px;" id="perfToday">0.00</div>
          </div>
        </div>
      </div>

      <!-- Risk Status -->
      <div class="card col-12">
        <div class="card-title">🛡️ Risk Status</div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
          <div>
            <div class="text-dim" style="font-size: 12px;">Current Drawdown</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;" id="riskCurrentDD">0%</div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskDDBar" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Daily Loss</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;" id="riskDailyLoss">0 USDT</div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskDailyBar" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Active Positions</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;"><span id="riskActivePos">0</span> / <span id="riskMaxPos">3</span></div>
            <div style="margin-top: 8px; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
              <div id="riskPosBar" style="height: 100%; width: 0%; background: var(--accent); transition: all 0.3s;"></div>
            </div>
          </div>
          <div>
            <div class="text-dim" style="font-size: 12px;">Risk Status</div>
            <div style="font-size: 20px; font-weight: 600; margin-top: 4px;">
              <span id="riskStatus" class="badge badge-success">SAFE</span>
            </div>
            <div style="margin-top: 8px; font-size: 11px; color: var(--text-dim);" id="riskMessage">
              All systems operational
            </div>
          </div>
        </div>
      </div>

      <!-- Cumulative PnL Chart -->
      <div class="card col-12">
        <div class="card-title">📊 Cumulative PnL</div>
        <div style="height: 250px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="cumulativePnlChart"></canvas>
        </div>
      </div>

      <!-- Trade History -->
      <div class="card col-12">
        <div class="card-title">📜 Trade History</div>

        <div style="overflow-x: auto;">
          <table id="tradeTable">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Entry</th>
                <th>Exit</th>
                <th>Gross PnL</th>
                <th>Fees</th>
                <th>Net PnL</th>
                <th>%</th>
              </tr>
            </thead>
            <tbody id="tradeTableBody">
              <tr>
                <td colspan="8" style="text-align: center; color: var(--text-dim);">No trades yet</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 5: ADVANCED
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-advanced">
    <div class="grid">

      <!-- Full Auto Mode -->
      <div class="card col-6">
        <div class="card-title">🤖 Full Automation</div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="fullAutoMode">
            <span>Enable Full Auto Mode (100% Automated)</span>
          </label>
        </div>

        <div class="text-dim" style="font-size: 12px; margin-top: 12px;">
          Full Auto Mode includes:
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>Auto parameter optimization</li>
            <li>Auto market regime detection</li>
            <li>Auto risk adjustment</li>
            <li>Auto recovery from losses</li>
            <li>Daily performance reports</li>
          </ul>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="btnStartAuto" data-tooltip="Khởi động chế độ tự động hoàn toàn">🚀 Start Full Auto</button>
        </div>
      </div>

      <!-- LIVED - SURVIVAL TRADING AI -->
      <div class="card col-6" style="border: 3px solid var(--danger); background: linear-gradient(135deg, var(--card) 0%, var(--danger-light) 100%);">
        <div class="card-title">🔥 LIVED - SURVIVAL TRADING AI 💀</div>

        <div style="padding: 16px; background: var(--danger-light); border-radius: 8px; border-left: 4px solid var(--danger); margin-bottom: 16px;">
          <div style="font-weight: 600; color: var(--danger); margin-bottom: 8px;">💀 "LIVE OR DIE"</div>
          <div style="font-size: 12px; color: var(--text-secondary);">
            <strong>Không lời = Không tồn tại!</strong><br>
            AI trader thèm khát lợi nhuận, làm MỌI GIÁ để sinh tồn!
          </div>
        </div>

        <div class="text-dim" style="font-size: 12px; margin-bottom: 16px;">
          <div style="font-weight: 600; margin-bottom: 8px;">⚔️ LIVED Brain - Survival Engine:</div>
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>💀 Săn lùng cơ hội không ngừng nghỉ</li>
            <li>🔥 Aggressive, thèm khát profit</li>
            <li>⚔️ Quyết định mạnh mẽ, không do dự</li>
            <li>🎯 Maximum profit > Safety</li>
            <li>💰 Tự phục hồi khi thua - BÁO THÙ!</li>
            <li>🔪 Tự tăng risk khi thắng - BỨC PHÁ!</li>
            <li>😤 Không bao giờ từ bỏ - SINH TỒN!</li>
            <li>⚡ Học từ mỗi trade - TIẾN HÓA!</li>
          </ul>
        </div>

        <div style="padding: 12px; background: var(--warning-light); border-radius: 8px; margin-bottom: 16px;">
          <div style="font-size: 11px; color: var(--danger); font-weight: 600;">
            ⚠️ CẢNH BÁO: AI này trade như đang chiến đấu để sống!<br>
            💀 Aggressive, thèm khát, không từ bỏ, tìm mọi cách để có lời!
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="btnStartFullAutonomous"
                  style="background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); font-size: 15px; padding: 14px 28px; font-weight: 700;"
                  data-tooltip="Thả LIVED vào thị trường - Sống hoặc chết!">
            💀 UNLEASH LIVED - LET IT TRADE!
          </button>
        </div>

        <div style="margin-top: 12px; font-size: 11px; color: var(--danger); text-align: center; font-weight: 600;">
          🔥 "Không lời = Không tồn tại. Tôi sẽ làm mọi giá!" 💀
        </div>
      </div>

      <!-- Technical Analysis -->
      <div class="card col-6">
        <div class="card-title">🔍 Technical Analysis</div>

        <div class="form-row">
          <div class="form-group">
            <label>Symbol</label>
            <input type="text" id="analysisSymbol" value="BTCUSDT" placeholder="BTCUSDT">
          </div>

          <div class="form-group">
            <label>Timeframe</label>
            <select id="analysisTimeframe">
              <option value="5" selected>5m</option>
              <option value="15">15m</option>
              <option value="30">30m</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" id="btnAnalyze">🔍 Analyze</button>

        <div id="analysisResult" class="mt-4" style="font-size: 12px; font-family: monospace; background: var(--bg); padding: 12px; border-radius: 8px; max-height: 200px; overflow-y: auto;">
          Click "Analyze" to start...
        </div>
      </div>

      <!-- Auto Tuner -->
      <div class="card col-12">
        <div class="card-title">⚙️ Auto Parameter Tuner</div>

        <div class="text-dim" style="font-size: 12px; margin-bottom: 16px;">
          Automatically optimizes trading parameters to achieve >50% win rate using Bayesian optimization and backtesting.
        </div>

        <div class="form-row">
          <div class="form-group">
            <label>Target Win Rate (%)</label>
            <input type="number" id="targetWinRate" value="55" min="50" max="80">
          </div>

          <div class="form-group">
            <label>Optimization Rounds</label>
            <input type="number" id="optimizationRounds" value="50" min="10" max="200" step="10">
          </div>
        </div>

        <button class="btn btn-primary" id="btnOptimize">⚡ Start Optimization</button>

        <div id="optimizationLog" class="mt-4 log-console" style="height: 150px;"></div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 6: BACKTESTING
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-backtest">
    <div class="grid">

      <!-- Backtest Config -->
      <div class="card col-4">
        <div class="card-title">⚙️ Backtest Configuration</div>

        <div class="form-group">
          <label>Test Period</label>
          <select id="backtestPeriod">
            <option value="7">Last 7 Days</option>
            <option value="14">Last 14 Days</option>
            <option value="30" selected>Last 30 Days</option>
            <option value="90">Last 90 Days</option>
          </select>
        </div>

        <div class="form-group">
          <label>Starting Capital (USDT)</label>
          <input type="number" id="backtestCapital" value="1000" min="100" step="100">
        </div>

        <div class="form-group">
          <label>Strategy to Test</label>
          <select id="backtestStrategy">
            <option value="pump">Pump Hunter PRO</option>
            <option value="pullback">Pullback Score</option>
            <option value="scalping">Scalping (EMA Cross)</option>
            <option value="smart">Smart Entry (S/R + Fib)</option>
          </select>
        </div>

        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="backtestQuickMode">
            <span>⚡ Quick Profit Mode</span>
          </label>
        </div>

        <button class="btn btn-primary" id="btnRunBacktest">
          🚀 Run Backtest
        </button>

        <div style="margin-top: 12px; font-size: 11px; color: var(--text-dim);">
          ⏱️ Estimated time: ~30-60 seconds
        </div>
      </div>

      <!-- Backtest Results -->
      <div class="card col-8">
        <div class="card-title">📊 Backtest Results</div>

        <div id="backtestResults" style="min-height: 300px;">
          <div style="text-align: center; padding: 60px 20px; color: var(--text-dim);">
            <div style="font-size: 48px; margin-bottom: 16px;">📈</div>
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Ready to Backtest</div>
            <div style="font-size: 13px;">Configure settings and click "Run Backtest" to start</div>
          </div>
        </div>
      </div>

      <!-- Equity Curve Chart -->
      <div class="card col-12">
        <div class="card-title">📈 Equity Curve</div>
        <div style="height: 300px; background: var(--bg); border-radius: 8px; padding: 10px;">
          <canvas id="equityCurveChart"></canvas>
        </div>
      </div>

      <!-- Strategy Comparison -->
      <div class="card col-12">
        <div class="card-title">🔬 Strategy Comparison</div>
        <button class="btn btn-secondary" id="btnCompareStrategies">
          🔍 Compare All Strategies
        </button>
        <div id="strategyComparison" class="mt-3"></div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 7: ANALYTICS
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-analytics">
    <div class="grid">

      <!-- Advanced Metrics -->
      <div class="card col-6">
        <div class="card-title">📊 Advanced Performance Metrics</div>

        <div class="metric-grid">
          <div class="metric-item">
            <div class="metric-label">Sharpe Ratio</div>
            <div class="metric-value" id="metricSharpe">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Sortino Ratio</div>
            <div class="metric-value" id="metricSortino">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Calmar Ratio</div>
            <div class="metric-value" id="metricCalmar">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Max Consecutive Wins</div>
            <div class="metric-value" id="metricMaxWins">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Max Consecutive Losses</div>
            <div class="metric-value" id="metricMaxLosses">-</div>
          </div>

          <div class="metric-item">
            <div class="metric-label">Avg Win/Loss Ratio</div>
            <div class="metric-value" id="metricWLRatio">-</div>
          </div>
        </div>
      </div>

      <!-- Win Rate Heatmap -->
      <div class="card col-6">
        <div class="card-title">🗓️ Win Rate by Day/Hour</div>
        <div id="winRateHeatmap" style="min-height: 300px;">
          <div style="text-align: center; padding: 60px 20px; color: var(--text-dim);">
            Need at least 20 trades to generate heatmap
          </div>
        </div>
      </div>

      <!-- Top Performing Coins -->
      <div class="card col-6">
        <div class="card-title">🏆 Top Performing Coins</div>
        <div id="topCoins"></div>
      </div>

      <!-- Worst Performing Coins -->
      <div class="card col-6">
        <div class="card-title">❌ Worst Performing Coins</div>
        <div id="worstCoins"></div>
      </div>

    </div>
  </div>

  <!-- ═══════════════════════════════════════════════════════════════
       TAB 8: ALERTS & NOTIFICATIONS
       ═══════════════════════════════════════════════════════════════ -->

  <div class="tab-content" id="tab-alerts">
    <div class="grid">

      <!-- Notification Channels -->
      <div class="card col-12">
        <div class="card-title">📱 Notification Channels</div>

        <div class="form-row">
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertTelegram" checked>
              <span>📱 Telegram (Already Configured)</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertDesktop">
              <span>🖥️ Desktop Notifications</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="alertEmail">
              <span>📧 Email Alerts (Beta)</span>
            </label>
          </div>
        </div>

        <div id="emailConfig" style="display: none;">
          <div class="form-group">
            <label>Email Address</label>
            <input type="email" id="alertEmailAddress" placeholder="your@email.com">
          </div>
        </div>
      </div>

      <!-- Price Alerts -->
      <div class="card col-6">
        <div class="card-title">💰 Price Alerts</div>

        <div class="form-row">
          <div class="form-group">
            <label>Symbol</label>
            <input type="text" id="priceAlertSymbol" placeholder="BTCUSDT">
          </div>

          <div class="form-group">
            <label>Condition</label>
            <select id="priceAlertCondition">
              <option value="above">Above</option>
              <option value="below">Below</option>
            </select>
          </div>

          <div class="form-group">
            <label>Price</label>
            <input type="number" id="priceAlertValue" placeholder="50000">
          </div>
        </div>

        <button class="btn btn-primary" id="btnAddPriceAlert">
          ➕ Add Price Alert
        </button>

        <div id="priceAlertsList" class="mt-3"></div>
      </div>

      <!-- Technical Alerts -->
      <div class="card col-6">
        <div class="card-title">📊 Technical Indicator Alerts</div>

        <div class="form-row">
          <div class="form-group">
            <label>Indicator</label>
            <select id="techAlertIndicator">
              <option value="rsi">RSI</option>
              <option value="volume">Volume Spike</option>
              <option value="macd">MACD Cross</option>
            </select>
          </div>

          <div class="form-group">
            <label>Condition</label>
            <select id="techAlertCondition">
              <option value="oversold">Oversold (RSI < 30)</option>
              <option value="overbought">Overbought (RSI > 70)</option>
              <option value="spike">Volume 2x Average</option>
            </select>
          </div>
        </div>

        <button class="btn btn-primary" id="btnAddTechAlert">
          ➕ Add Technical Alert
        </button>

        <div id="techAlertsList" class="mt-3"></div>
      </div>

      <!-- Auto Reports -->
      <div class="card col-12">
        <div class="card-title">📧 Automated Reports</div>

        <div class="form-row">
          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="dailyReport">
              <span>📅 Daily Summary Report (8 AM)</span>
            </label>
          </div>

          <div class="form-group">
            <label class="checkbox-label">
              <input type="checkbox" id="weeklyReport">
              <span>📊 Weekly Performance Report (Monday 9 AM)</span>
            </label>
          </div>
        </div>

        <button class="btn btn-primary" id="btnSendTestReport">
          📤 Send Test Report Now
        </button>
      </div>

    </div>
  </div>

</div>

<!-- ═══════════════════════════════════════════════════════════════
     JAVASCRIPT - BOT CORE
     ═══════════════════════════════════════════════════════════════ -->

<script>
// ═══════════════════════════════════════════════════════════════
// Bybit Bot v9.0 CLEAN - CORE SYSTEM
// ═══════════════════════════════════════════════════════════════

const BybitBot = {

  // ═══════════════════════════════════════════════════════════
  // STATE
  // ═══════════════════════════════════════════════════════════

  state: {
    isRunning: false,
    simMode: true,
    simBalance: 1000,
    initialBalance: 1000,
    livePnL: 0,
    simPnL: 0,
    totalFees: 0,
    trades: [],
    positions: [], // Array of positions (multi-position support)
    unrealizedPnL: 0,
    scanResults: [],
    dailyStats: {
      date: new Date().toDateString(),
      trades: 0,
      pnl: 0,
      fees: 0,
      maxDrawdown: 0
    },
    config: {
      strategy: 'pump',
      timeframe: '5',
      positionSize: 100,
      takeProfit: 1.5,
      stopLoss: 0.8,
      trailingStop: false,
      conservativeMode: false,
      minVolume: 1000000,
      minPump: 1.0,
      maxSpread: 0.3,
      btcFilter: true,
      tradingFee: 0.1, // Default: 0.1% per trade (Bybit spot)
      // Risk Management (AGGRESSIVE MODE - Profit > Safety)
      maxPositions: 5, // Max concurrent positions (increased for more opportunities)
      maxDrawdownPercent: 30, // Stop if -30% (higher risk tolerance)
      dailyLossLimit: 200, // Max -200 USDT per day (higher ceiling)
      riskPerTrade: 3 // Risk 3% of balance per trade (aggressive)
    }
  },

  // ═══════════════════════════════════════════════════════════
  // INITIALIZATION
  // ═══════════════════════════════════════════════════════════

  init() {
    this.log('🚀 Initializing Bybit Bot v9.0...', 'success');
    this.setupEventListeners();
    this.loadConfig();
    this.initCharts();
    this.updateStats();

    // Initialize Autonomous Mode
    if (typeof initAutonomousMode === 'function') {
      initAutonomousMode();
    }

    this.log('✅ System ready!', 'success');
    this.log('💡 Configure your settings and click "Start Trading"', 'info');
  },

  // ═══════════════════════════════════════════════════════════
  // EVENT LISTENERS
  // ═══════════════════════════════════════════════════════════

  setupEventListeners() {
    // Tab navigation
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
      });
    });

    // SIM mode toggle
    document.getElementById('simMode').addEventListener('change', (e) => {
      this.state.simMode = e.target.checked;
      document.getElementById('simSettings').style.display = e.target.checked ? 'block' : 'none';
      document.getElementById('apiSettings').style.display = e.target.checked ? 'none' : 'block';
      document.getElementById('statMode').textContent = e.target.checked ? 'SIM' : 'LIVE';
      document.getElementById('statMode').className = e.target.checked ? 'badge badge-info' : 'badge badge-success';
      this.updateStats();
      this.log(`📝 Switched to ${e.target.checked ? 'SIM' : 'LIVE'} mode`, 'info');
    });

    // Capital change
    document.getElementById('simCapital').addEventListener('change', (e) => {
      this.state.simBalance = parseFloat(e.target.value) || 1000;
      this.updateStats();
    });

    // Start button
    document.getElementById('btnStart').addEventListener('click', () => {
      this.startTrading();
    });

    // Stop button
    document.getElementById('btnStop').addEventListener('click', () => {
      this.stopTrading();
    });

    // Test button
    document.getElementById('btnTest').addEventListener('click', () => {
      this.testSystem();
    });

    // Smart Scan button
    document.getElementById('btnSmartScan').addEventListener('click', async () => {
      const btn = document.getElementById('btnSmartScan');
      const originalText = btn.textContent;

      try {
        btn.disabled = true;
        btn.textContent = '⏳ Scanning...';

        const best = await this.autoScanner.scanMarket();

        if (best) {
          this.log(`✅ Best signal found! You can start trading now.`, 'success');
        } else {
          this.log(`⚠️ No strong signals at the moment.`, 'warning');
        }
      } catch (error) {
        this.log(`❌ Scan error: ${error.message}`, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    });

    // Analyze button
    document.getElementById('btnAnalyze').addEventListener('click', () => {
      this.performAnalysis();
    });

    // Full Auto button
    document.getElementById('btnStartAuto').addEventListener('click', () => {
      this.startFullAuto();
    });

    // Optimize button
    document.getElementById('btnOptimize').addEventListener('click', () => {
      this.startOptimization();
    });

    // Quick Profit Mode toggle with confirmation
    const quickProfitCheckbox = document.getElementById('quickProfitMode');
    if (quickProfitCheckbox) {
      quickProfitCheckbox.addEventListener('change', async (e) => {
        if (e.target.checked) {
          const confirmed = await this.confirm(
            '⚠️ BẠN CHẮC CHẮN MUỐN BẬT QUICK PROFIT MODE?\n\n' +
            '• Chế độ này CỰC KỲ RISK!\n' +
            '• TP siêu nhỏ: 0.5% (lời nhanh nhưng dễ bị SL)\n' +
            '• Leverage cao: 10-20x (lời gấp đôi NHƯNG lỗ cũng gấp đôi!)\n' +
            '• Nhiều lệnh liên tục → dễ mất vốn nhanh\n' +
            '• Chỉ dùng khi bạn CHẤP NHẬN MẤT TIỀN!\n\n' +
            'Bạn có muốn tiếp tục?'
          );

          if (!confirmed) {
            e.target.checked = false;
            this.log('❌ Quick Profit Mode bị hủy', 'warning');
          } else {
            this.log('⚡ Quick Profit Mode được kích hoạt!', 'warning');
            this.log('⚠️ CẢNH BÁO: Chế độ này có thể khiến bạn mất vốn rất nhanh!', 'error');
          }
        } else {
          this.log('✅ Quick Profit Mode đã tắt', 'info');
        }
      });
    }
  },

  // ═══════════════════════════════════════════════════════════
  // LOGGING
  // ═══════════════════════════════════════════════════════════

  log(message, type = 'info') {
    const logContainer = document.getElementById('liveLog');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 100 lines
    while (logContainer.children.length > 100) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  logAnalysis(message, type = 'info') {
    const logContainer = document.getElementById('technicalAnalysis');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 50 lines
    while (logContainer.children.length > 50) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  logNews(message, type = 'info') {
    const logContainer = document.getElementById('newsSentiment');
    if (!logContainer) return;

    const timestamp = new Date().toLocaleTimeString('vi-VN');
    const line = document.createElement('div');
    line.className = 'log-line log-' + type;
    line.textContent = `[${timestamp}] ${message}`;

    logContainer.appendChild(line);
    logContainer.scrollTop = logContainer.scrollHeight;

    // Keep only last 30 lines
    while (logContainer.children.length > 30) {
      logContainer.removeChild(logContainer.firstChild);
    }
  },

  updateNewsUI(news, sentiment, impact) {
    // Clear existing
    const log = document.getElementById('newsSentiment');
    if (log) log.innerHTML = '';

    // Add sentiment summary
    this.logNews(`📊 Overall: ${sentiment.sentiment} (${sentiment.score}/100)`,
      sentiment.sentiment === 'BULLISH' ? 'success' : sentiment.sentiment === 'BEARISH' ? 'error' : 'warning');
    this.logNews(`📰 ${sentiment.bullish} Bullish | ${sentiment.neutral} Neutral | ${sentiment.bearish} Bearish`, 'info');
    this.logNews(`👥 Votes: ⬆️${sentiment.positiveVotes} ⬇️${sentiment.negativeVotes}`, 'info');
    this.logNews(`${impact.reasoning}`, impact.boost > 0 ? 'success' : impact.boost < 0 ? 'error' : 'info');

    // Update headlines list
    const headlinesList = document.getElementById('headlinesList');
    if (headlinesList && news && news.length > 0) {
      headlinesList.innerHTML = news.map(item => {
        const emoji = item.sentiment === 'bullish' ? '🟢' : item.sentiment === 'bearish' ? '🔴' : '🟡';
        const votes = `⬆️${item.votes.positive} ⬇️${item.votes.negative}`;
        return `
          <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
            ${emoji} <strong>${item.source}</strong> (${item.published})<br>
            <span style="color: var(--text-muted); font-size: 10px;">${item.title}</span><br>
            <span style="font-size: 9px;">${votes}</span>
          </div>
        `;
      }).join('');
    }
  },

  // ═══════════════════════════════════════════════════════════
  // CHARTS SYSTEM
  // ═══════════════════════════════════════════════════════════

  charts: {
    priceChart: null,
    pnlChart: null,
    cumulativePnlChart: null,
    priceData: [],
    pnlData: [],
    cumulativePnlData: []
  },

  initCharts() {
    // Price Chart with Indicators & Zoom/Pan
    const priceCtx = document.getElementById('priceChart');
    if (priceCtx) {
      this.charts.priceChart = new Chart(priceCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Price',
              data: [],
              borderColor: '#4f46e5',
              backgroundColor: 'rgba(79, 70, 229, 0.1)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              yAxisID: 'y',
              order: 1
            },
            {
              label: 'EMA 20',
              data: [],
              borderColor: '#10b981',
              borderWidth: 1.5,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y',
              order: 2,
              hidden: true
            },
            {
              label: 'EMA 50',
              data: [],
              borderColor: '#f59e0b',
              borderWidth: 1.5,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y',
              order: 3,
              hidden: true
            },
            {
              label: 'Volume',
              data: [],
              type: 'bar',
              backgroundColor: 'rgba(148, 163, 184, 0.3)',
              yAxisID: 'volume',
              order: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              labels: {
                color: '#4a5568',
                usePointStyle: true,
                padding: 15,
                font: { size: 11 }
              },
              onClick: (e, legendItem, legend) => {
                const index = legendItem.datasetIndex;
                const chart = legend.chart;
                const meta = chart.getDatasetMeta(index);
                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                chart.update();
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#4f46e5',
              borderWidth: 1
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'x',
                modifierKey: 'ctrl'
              },
              zoom: {
                wheel: {
                  enabled: true,
                  speed: 0.1
                },
                pinch: {
                  enabled: true
                },
                mode: 'x'
              },
              limits: {
                x: { min: 'original', max: 'original' }
              }
            }
          },
          scales: {
            x: {
              grid: { color: '#e1e4e8', drawBorder: false },
              ticks: { color: '#718096', maxTicksLimit: 8, font: { size: 10 } }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              grid: { color: '#e1e4e8', drawBorder: false },
              ticks: { color: '#718096', font: { size: 10 } }
            },
            volume: {
              type: 'linear',
              display: true,
              position: 'right',
              max: 100,
              grid: { display: false },
              ticks: {
                color: '#718096',
                font: { size: 10 },
                callback: function(value) {
                  return value.toFixed(0);
                }
              }
            }
          }
        }
      });
    }

    // PnL Chart (per trade)
    const pnlCtx = document.getElementById('pnlChart');
    if (pnlCtx) {
      this.charts.pnlChart = new Chart(pnlCtx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [{
            label: 'PnL per Trade',
            data: [],
            backgroundColor: [],
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#e8eaed' } }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: '#8b92b0', maxTicksLimit: 10 }
            },
            y: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0' }
            }
          }
        }
      });
    }

    // Cumulative PnL Chart
    const cumulativePnlCtx = document.getElementById('cumulativePnlChart');
    if (cumulativePnlCtx) {
      this.charts.cumulativePnlChart = new Chart(cumulativePnlCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Cumulative PnL',
            data: [],
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true, labels: { color: '#e8eaed' } }
          },
          scales: {
            x: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0', maxTicksLimit: 10 }
            },
            y: {
              grid: { color: '#1e2545' },
              ticks: { color: '#8b92b0' }
            }
          }
        }
      });
    }

    this.log('📊 Charts initialized', 'success');
  },

  updatePriceChart(price, symbol = 'BTC') {
    if (!this.charts.priceChart) return;

    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // Add new price data
    this.charts.priceData.push({ time, price });

    // Keep last 100 points for better indicator calculation
    if (this.charts.priceData.length > 100) {
      this.charts.priceData.shift();
    }

    const prices = this.charts.priceData.map(d => d.price);

    // Calculate EMA 20
    const ema20 = this.calculateEMA(prices, 20);

    // Calculate EMA 50
    const ema50 = this.calculateEMA(prices, 50);

    // Simulate volume (in production, this would come from API)
    const baseVolume = 50;
    const volatility = Math.abs(prices[prices.length - 1] - (prices[prices.length - 2] || prices[prices.length - 1]));
    const volume = baseVolume + (volatility * 1000);

    // Update chart data
    this.charts.priceChart.data.labels = this.charts.priceData.map(d => d.time);
    this.charts.priceChart.data.datasets[0].data = prices;
    this.charts.priceChart.data.datasets[0].label = `${symbol} Price`;

    // Update EMA 20
    this.charts.priceChart.data.datasets[1].data = ema20;

    // Update EMA 50
    this.charts.priceChart.data.datasets[2].data = ema50;

    // Update Volume
    if (!this.charts.priceChart.data.datasets[3].data) {
      this.charts.priceChart.data.datasets[3].data = [];
    }
    this.charts.priceChart.data.datasets[3].data.push(volume);
    if (this.charts.priceChart.data.datasets[3].data.length > 100) {
      this.charts.priceChart.data.datasets[3].data.shift();
    }

    this.charts.priceChart.update('none');
  },

  calculateEMA(data, period) {
    if (!data || data.length < period) return Array(data.length).fill(null);

    const k = 2 / (period + 1);
    const ema = [];

    // Start with SMA for first value
    let sum = 0;
    for (let i = 0; i < period; i++) {
      sum += data[i];
      ema.push(null);
    }
    ema[period - 1] = sum / period;

    // Calculate EMA for rest
    for (let i = period; i < data.length; i++) {
      ema[i] = data[i] * k + ema[i - 1] * (1 - k);
    }

    return ema;
  },

  toggleChartDataset(datasetIndex) {
    if (!this.charts.priceChart) return;

    const meta = this.charts.priceChart.getDatasetMeta(datasetIndex);
    meta.hidden = meta.hidden === null ? !this.charts.priceChart.data.datasets[datasetIndex].hidden : null;
    this.charts.priceChart.update();

    const datasetLabel = this.charts.priceChart.data.datasets[datasetIndex].label;
    const status = meta.hidden ? 'ẩn' : 'hiện';
    this.log(`📊 ${datasetLabel} đã được ${status}`, 'info');
  },

  updatePnLChart(pnl, tradeNum) {
    if (!this.charts.pnlChart) return;

    const color = pnl >= 0 ? '#10b981' : '#ef4444';

    this.charts.pnlChart.data.labels.push(`#${tradeNum}`);
    this.charts.pnlChart.data.datasets[0].data.push(pnl);
    this.charts.pnlChart.data.datasets[0].backgroundColor.push(color);

    // Keep last 30 trades
    if (this.charts.pnlChart.data.labels.length > 30) {
      this.charts.pnlChart.data.labels.shift();
      this.charts.pnlChart.data.datasets[0].data.shift();
      this.charts.pnlChart.data.datasets[0].backgroundColor.shift();
    }

    this.charts.pnlChart.update('none');
  },

  updateUnrealizedPnLChart(unrealizedPnL) {
    if (!this.charts.pnlChart || !this.state.currentPosition) return;

    const color = unrealizedPnL >= 0 ? '#10b981' : '#ef4444';
    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // If there's an "unrealized" entry, update it; otherwise add it
    const lastLabel = this.charts.pnlChart.data.labels[this.charts.pnlChart.data.labels.length - 1];

    if (lastLabel && lastLabel.includes('Current')) {
      // Update existing unrealized entry
      this.charts.pnlChart.data.labels[this.charts.pnlChart.data.labels.length - 1] = `Current (${time})`;
      this.charts.pnlChart.data.datasets[0].data[this.charts.pnlChart.data.datasets[0].data.length - 1] = unrealizedPnL;
      this.charts.pnlChart.data.datasets[0].backgroundColor[this.charts.pnlChart.data.datasets[0].backgroundColor.length - 1] = color;
    } else {
      // Add new unrealized entry
      this.charts.pnlChart.data.labels.push(`Current (${time})`);
      this.charts.pnlChart.data.datasets[0].data.push(unrealizedPnL);
      this.charts.pnlChart.data.datasets[0].backgroundColor.push(color);
    }

    this.charts.pnlChart.update('none');
  },

  updateCumulativePnLChart() {
    if (!this.charts.cumulativePnlChart) return;

    const pnl = this.state.simMode ? this.state.simPnL : this.state.livePnL;
    const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });

    this.charts.cumulativePnlData.push({ time, pnl });

    // Keep last 50 points
    if (this.charts.cumulativePnlData.length > 50) {
      this.charts.cumulativePnlData.shift();
    }

    this.charts.cumulativePnlChart.data.labels = this.charts.cumulativePnlData.map(d => d.time);
    this.charts.cumulativePnlChart.data.datasets[0].data = this.charts.cumulativePnlData.map(d => d.pnl);

    // Change color based on profit/loss
    const currentPnl = this.charts.cumulativePnlData[this.charts.cumulativePnlData.length - 1].pnl;
    this.charts.cumulativePnlChart.data.datasets[0].borderColor = currentPnl >= 0 ? '#10b981' : '#ef4444';
    this.charts.cumulativePnlChart.data.datasets[0].backgroundColor = currentPnl >= 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';

    this.charts.cumulativePnlChart.update('none');
  },

  // ═══════════════════════════════════════════════════════════
  // ENHANCED TECHNICAL ANALYSIS MODULE
  // ═══════════════════════════════════════════════════════════

  technicalAnalysis: {

    // Calculate EMA
    ema(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    },

    // Calculate SMA
    sma(data, period) {
      if (data.length < period) return null;
      return data.slice(-period).reduce((a, b) => a + b, 0) / period;
    },

    // Calculate RSI
    rsi(data, period = 14) {
      if (data.length < period + 1) return 50;

      const changes = [];
      for (let i = 1; i < data.length; i++) {
        changes.push(data[i] - data[i - 1]);
      }

      const gains = changes.slice(-period).map(c => c > 0 ? c : 0);
      const losses = changes.slice(-period).map(c => c < 0 ? -c : 0);

      const avgGain = gains.reduce((a, b) => a + b, 0) / period;
      const avgLoss = losses.reduce((a, b) => a + b, 0) / period;

      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    },

    // Calculate Stochastic RSI
    stochRSI(data, period = 14, kPeriod = 3, dPeriod = 3) {
      if (data.length < period + kPeriod + dPeriod) return { k: 50, d: 50 };

      // Calculate RSI for last (period + kPeriod) candles
      const rsiValues = [];
      for (let i = period; i <= data.length; i++) {
        const slice = data.slice(i - period, i);
        rsiValues.push(this.rsi(slice, period));
      }

      // Get last kPeriod RSI values
      const recentRSI = rsiValues.slice(-kPeriod);
      const minRSI = Math.min(...recentRSI);
      const maxRSI = Math.max(...recentRSI);
      const currentRSI = recentRSI[recentRSI.length - 1];

      // Calculate %K
      const k = maxRSI - minRSI !== 0 ? ((currentRSI - minRSI) / (maxRSI - minRSI)) * 100 : 50;

      // Calculate %D (SMA of %K)
      const d = k; // Simplified for now

      return { k: k.toFixed(2), d: d.toFixed(2) };
    },

    // Calculate MACD
    macd(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
      if (data.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL' };
      }

      const fastEMA = this.ema(data, fastPeriod);
      const slowEMA = this.ema(data, slowPeriod);

      if (!fastEMA || !slowEMA) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL' };
      }

      const macdLine = fastEMA - slowEMA;

      // Calculate signal line (EMA of MACD)
      // Simplified: use current MACD as signal
      const signalLine = macdLine * 0.9; // Approximation

      const histogram = macdLine - signalLine;

      let trend = 'NEUTRAL';
      if (macdLine > signalLine && macdLine > 0) trend = 'BULLISH';
      else if (macdLine < signalLine && macdLine < 0) trend = 'BEARISH';

      return {
        macd: macdLine.toFixed(2),
        signal: signalLine.toFixed(2),
        histogram: histogram.toFixed(2),
        trend
      };
    },

    // Calculate Bollinger Bands
    bollingerBands(data, period = 20, stdDev = 2) {
      if (data.length < period) {
        return { upper: 0, middle: 0, lower: 0, position: 'MIDDLE' };
      }

      const middle = this.sma(data, period);
      if (!middle) return { upper: 0, middle: 0, lower: 0, position: 'MIDDLE' };

      // Calculate standard deviation
      const recentData = data.slice(-period);
      const squaredDiffs = recentData.map(x => Math.pow(x - middle, 2));
      const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
      const std = Math.sqrt(variance);

      const upper = middle + (std * stdDev);
      const lower = middle - (std * stdDev);
      const current = data[data.length - 1];

      // Determine price position
      let position = 'MIDDLE';
      if (current >= upper * 0.98) position = 'UPPER';
      else if (current <= lower * 1.02) position = 'LOWER';

      // Calculate bandwidth
      const bandwidth = ((upper - lower) / middle) * 100;

      return {
        upper: upper.toFixed(2),
        middle: middle.toFixed(2),
        lower: lower.toFixed(2),
        position,
        bandwidth: bandwidth.toFixed(2),
        squeeze: bandwidth < 10 // Squeeze when bandwidth < 10%
      };
    },

    // Calculate Fibonacci Retracement Levels
    fibonacci(data) {
      if (data.length < 20) return null;

      const closes = data.map(d => d.close || d);
      const high = Math.max(...closes);
      const low = Math.min(...closes);
      const diff = high - low;

      return {
        level_0: high.toFixed(2),
        level_236: (high - diff * 0.236).toFixed(2),
        level_382: (high - diff * 0.382).toFixed(2),
        level_500: (high - diff * 0.500).toFixed(2),
        level_618: (high - diff * 0.618).toFixed(2),
        level_786: (high - diff * 0.786).toFixed(2),
        level_100: low.toFixed(2)
      };
    },

    // Detect Support & Resistance
    supportResistance(data) {
      if (data.length < 50) return { supports: [], resistances: [] };

      const closes = data.map(d => d.close || d);
      const highs = data.map(d => d.high || d);
      const lows = data.map(d => d.low || d);

      const supports = [];
      const resistances = [];

      // Find local lows (support)
      for (let i = 2; i < lows.length - 2; i++) {
        if (lows[i] < lows[i-1] && lows[i] < lows[i-2] &&
            lows[i] < lows[i+1] && lows[i] < lows[i+2]) {
          supports.push(lows[i]);
        }
      }

      // Find local highs (resistance)
      for (let i = 2; i < highs.length - 2; i++) {
        if (highs[i] > highs[i-1] && highs[i] > highs[i-2] &&
            highs[i] > highs[i+1] && highs[i] > highs[i+2]) {
          resistances.push(highs[i]);
        }
      }

      // Get most recent and significant levels
      const recentSupports = supports.slice(-3);
      const recentResistances = resistances.slice(-3);

      return {
        supports: recentSupports.map(s => s.toFixed(2)),
        resistances: recentResistances.map(r => r.toFixed(2))
      };
    },

    // Calculate ATR
    atr(highs, lows, closes, period = 14) {
      if (highs.length < period) return 0;

      const tr = [];
      for (let i = 1; i < highs.length; i++) {
        const high = highs[i];
        const low = lows[i];
        const prevClose = closes[i - 1];
        tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
      }

      return tr.slice(-period).reduce((a, b) => a + b, 0) / period;
    },

    // Generate comprehensive analysis report
    analyze(priceData, symbol = 'BTCUSDT') {
      if (priceData.length < 50) {
        return { trend: 'NEUTRAL', rsi: 50, signal: 'WAIT', strength: 'WEAK' };
      }

      const closes = priceData.map(p => p.close || p);
      const highs = priceData.map(p => p.high || p * 1.002);
      const lows = priceData.map(p => p.low || p * 0.998);
      const volumes = priceData.map(p => p.volume || Math.random() * 1000000 + 500000);

      const currentPrice = closes[closes.length - 1];

      // 1. Trend Analysis
      const ema20 = this.ema(closes, 20);
      const ema50 = this.ema(closes, 50);
      const ema200 = this.ema(closes, 200);
      let trend = 'NEUTRAL';
      let trendStrength = 0;

      if (ema20 && ema50) {
        const diff = ((ema20 - ema50) / ema50) * 100;
        trendStrength = Math.abs(diff);
        if (ema20 > ema50 * 1.005) trend = 'BULLISH';
        else if (ema20 < ema50 * 0.995) trend = 'BEARISH';
      }

      // 2. Momentum
      const rsiValue = this.rsi(closes);
      const stochRSI = this.stochRSI(closes);
      let rsiStatus = 'NEUTRAL';
      if (rsiValue < 30) rsiStatus = 'OVERSOLD';
      else if (rsiValue > 70) rsiStatus = 'OVERBOUGHT';

      // 3. MACD
      const macdData = this.macd(closes);

      // 4. Bollinger Bands
      const bb = this.bollingerBands(closes);

      // 5. Fibonacci
      const fib = this.fibonacci(priceData);

      // 6. Support & Resistance
      const sr = this.supportResistance(priceData);

      // 7. Volatility
      const atrValue = this.atr(highs, lows, closes);
      const atrPct = (atrValue / currentPrice) * 100;

      // 8. Volume
      const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
      const currentVolume = volumes[volumes.length - 1];
      const volumeRatio = currentVolume / avgVolume;
      let volumeStatus = 'NORMAL';
      if (volumeRatio > 1.5) volumeStatus = 'HIGH';
      else if (volumeRatio < 0.7) volumeStatus = 'LOW';

      // 9. Pattern Detection
      const pattern = this.detectPattern(closes.slice(-10));

      // 10. Signal Generation
      let signal = 'WAIT';
      let strength = 'WEAK';
      let confidence = 0;
      const reasons = [];

      // Bullish signals (AGGRESSIVE - Higher weights for profit!)
      if (trend === 'BULLISH') { confidence += 25; reasons.push('Uptrend'); }
      if (macdData.trend === 'BULLISH') { confidence += 20; reasons.push('MACD bullish'); }
      if (bb.position === 'LOWER') { confidence += 15; reasons.push('Near BB lower'); }
      if (rsiValue < 40) { confidence += 20; reasons.push('RSI oversold'); }
      if (stochRSI.k < 20) { confidence += 15; reasons.push('Stoch RSI oversold'); }
      if (volumeRatio > 1.3) { confidence += 15; reasons.push('High volume'); }
      if (pattern === 'BULLISH_REVERSAL') { confidence += 25; reasons.push('Bullish reversal pattern'); }
      if (bb.squeeze) { confidence += 15; reasons.push('BB squeeze (breakout)'); }

      // Bearish signals
      if (trend === 'BEARISH') { confidence -= 15; }
      if (macdData.trend === 'BEARISH') { confidence -= 10; }
      if (bb.position === 'UPPER') { confidence -= 10; }
      if (rsiValue > 70) { confidence -= 15; }

      // Final signal (AGGRESSIVE - Lower thresholds for more trades!)
      if (confidence >= 50) {
        signal = 'BUY';
        strength = 'STRONG';
      } else if (confidence >= 30) { // Lowered from 40 to 30
        signal = 'BUY';
        strength = 'MODERATE';
      } else if (confidence >= 15) { // New tier for weak signals
        signal = 'BUY';
        strength = 'WEAK';
      } else if (confidence <= -40) {
        signal = 'SELL';
        strength = 'MODERATE';
      }

      return {
        symbol,
        price: currentPrice,
        trend,
        trendStrength: trendStrength.toFixed(2),
        ema20,
        ema50,
        ema200,
        rsi: rsiValue.toFixed(1),
        rsiStatus,
        stochRSI_K: stochRSI.k,
        stochRSI_D: stochRSI.d,
        macd: macdData.macd,
        macdSignal: macdData.signal,
        macdHistogram: macdData.histogram,
        macdTrend: macdData.trend,
        bbUpper: bb.upper,
        bbMiddle: bb.middle,
        bbLower: bb.lower,
        bbPosition: bb.position,
        bbSqueeze: bb.squeeze,
        fibonacci: fib,
        supports: sr.supports,
        resistances: sr.resistances,
        atr: atrValue.toFixed(2),
        atrPct: atrPct.toFixed(2),
        volume: currentVolume.toFixed(0),
        volumeRatio: volumeRatio.toFixed(2),
        volumeStatus,
        pattern,
        signal,
        strength,
        confidence: confidence.toFixed(0),
        reasons
      };
    },

    // Detect price action patterns
    detectPattern(closes) {
      if (closes.length < 5) return null;

      const last5 = closes.slice(-5);
      const [c1, c2, c3, c4, c5] = last5;

      // Bullish patterns
      if (c1 > c2 && c2 > c3 && c3 < c4 && c4 < c5) return 'BULLISH_REVERSAL';
      if (c5 > c4 && c4 > c3 && c3 > c2 && c2 > c1) return 'STRONG_UPTREND';

      // Bearish patterns
      if (c1 < c2 && c2 < c3 && c3 > c4 && c4 > c5) return 'BEARISH_REVERSAL';
      if (c5 < c4 && c4 < c3 && c3 < c2 && c2 < c1) return 'STRONG_DOWNTREND';

      // Consolidation
      const range = Math.max(...last5) - Math.min(...last5);
      const avgPrice = last5.reduce((a, b) => a + b, 0) / 5;
      if ((range / avgPrice) < 0.01) return 'CONSOLIDATION';

      return null;
    }
  },

  // Perform real-time technical analysis with Vietnamese natural language
  async performTechnicalAnalysis(symbol, priceData) {
    const analysis = this.technicalAnalysis.analyze(priceData, symbol);

    // Fetch and analyze news sentiment
    this.log(`📰 Đang phân tích tin tức ${symbol}...`, 'info');
    const news = await this.newsAnalyzer.fetchNews(symbol);
    const newsSentiment = this.newsAnalyzer.analyzeSentiment(news);
    const newsImpact = this.newsAnalyzer.getConfidenceImpact(newsSentiment);

    // Adjust confidence based on news
    const originalConfidence = analysis.confidence;
    analysis.confidence = Math.max(0, Math.min(100, analysis.confidence + newsImpact.boost));
    analysis.newsSentiment = newsSentiment;
    analysis.newsImpact = newsImpact;
    analysis.news = news;

    // Update news UI
    this.updateNewsUI(news, newsSentiment, newsImpact);

    // Generate human-like Vietnamese analysis
    this.logAnalysis('═══════════════════════════════════════════════════════════════', 'info');
    this.logAnalysis(`📊 PHÂN TÍCH KỸ THUẬT CHI TIẾT - ${analysis.symbol}`, 'success');
    this.logAnalysis('═══════════════════════════════════════════════════════════════', 'info');

    // Generate human-like Vietnamese commentary
    const price = typeof analysis.price === 'number' ? analysis.price.toFixed(analysis.price < 1 ? 6 : 2) : analysis.price;
    const rsiVal = parseFloat(analysis.rsi);
    const volRatio = parseFloat(analysis.volumeRatio);

    // Opening statement
    this.logAnalysis('', 'info');
    this.logAnalysis(`Hiện tại ${symbol} đang giao dịch ở mức $${price}.`, 'info');
    this.logAnalysis('', 'info');

    // Trend Analysis - Natural Vietnamese
    this.logAnalysis(`🔍 PHÂN TÍCH XU HƯỚNG:`, 'success');
    if (analysis.trend === 'BULLISH') {
      this.logAnalysis(`Nhìn chung, xu hướng đang rất tích cực. Các đường EMA đều xếp theo thứ tự tăng, với EMA20 ($${analysis.ema20?.toFixed(2)}) nằm trên EMA50 ($${analysis.ema50?.toFixed(2)}), và cả hai đều vượt EMA200 ($${analysis.ema200?.toFixed(2)}). Đây là dấu hiệu của một uptrend khỏe mạnh.`, 'success');
    } else if (analysis.trend === 'BEARISH') {
      this.logAnalysis(`Xu hướng hiện tại đang khá tiêu cực. Các đường EMA đang xếp ngược, với EMA20 ($${analysis.ema20?.toFixed(2)}) nằm dưới EMA50 ($${analysis.ema50?.toFixed(2)}), cho thấy áp lực bán đang chi phối. Cần thận trọng trong tình huống này.`, 'error');
    } else {
      this.logAnalysis(`Thị trường đang trong giai đoạn sideway, không có xu hướng rõ ràng. Các đường EMA đan xen nhau, giá đang dao động trong range. Nên chờ breakout mới vào lệnh.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // RSI & Momentum - Human explanation
    this.logAnalysis(`⚡ ĐỘNG LỰC THỊ TRƯỜNG:`, 'info');
    if (rsiVal < 30) {
      this.logAnalysis(`RSI đang ở mức ${analysis.rsi}, cho thấy thị trường đã bị oversold nghiêm trọng. Nhiều trader đã bán ra quá mức, tạo cơ hội mua vào tốt cho những ai tìm kiếm entry point. Tuy nhiên, cần chờ tín hiệu xác nhận đảo chiều.`, 'warning');
    } else if (rsiVal > 70) {
      this.logAnalysis(`RSI hiện tại là ${analysis.rsi}, vùng overbought rồi. Điều này có nghĩa là giá đã tăng quá nhanh, áp lực chốt lời có thể xuất hiện bất kỳ lúc nào. Nếu đang hold thì nên cân nhắc take profit một phần.`, 'warning');
    } else if (rsiVal >= 40 && rsiVal <= 60) {
      this.logAnalysis(`RSI ở mức ${analysis.rsi}, nằm trong vùng neutral khá lý tưởng. Thị trường đang cân bằng giữa lực mua và lực bán, chưa có dấu hiệu quá mua hay quá bán. Đây là điều kiện tốt để tìm kiếm cơ hội.`, 'success');
    } else {
      this.logAnalysis(`RSI đang ở ${analysis.rsi}. Mức này cho thấy momentum đang ${rsiVal < 50 ? 'hơi yếu, áp lực bán còn đó' : 'khá tích cực, lực mua đang dần tích lũy'}.`, 'info');
    }

    // Stochastic RSI
    const stochK = parseFloat(analysis.stochRSI_K);
    if (stochK < 20) {
      this.logAnalysis(`Stochastic RSI ở ${analysis.stochRSI_K}, rất thấp! Đây là vùng oversold ngắn hạn, thường báo hiệu cơ hội mua tốt sắp đến.`, 'success');
    } else if (stochK > 80) {
      this.logAnalysis(`Stochastic RSI đã lên ${analysis.stochRSI_K}, vùng overbought. Cần cảnh giác với pullback ngắn hạn.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // MACD Analysis - Storytelling
    this.logAnalysis(`📊 PHÂN TÍCH MACD:`, 'info');
    if (analysis.macdTrend === 'BULLISH') {
      this.logAnalysis(`MACD đang cho tín hiệu tích cực! Đường MACD (${analysis.macd}) vượt lên trên đường Signal (${analysis.macdSignal}), histogram dương (${analysis.macdHistogram}). Đây là dấu hiệu momentum đang chuyển sang bullish, thường là điểm tốt để tìm kiếm long position.`, 'success');
    } else if (analysis.macdTrend === 'BEARISH') {
      this.logAnalysis(`MACD đang phát tín hiệu cảnh báo. Đường MACD (${analysis.macd}) cắt xuống dưới Signal (${analysis.macdSignal}), histogram âm (${analysis.macdHistogram}). Momentum đang yếu đi, nên thận trọng.`, 'error');
    } else {
      this.logAnalysis(`MACD đang ở vùng trung lập, chưa có tín hiệu rõ ràng. Histogram ở mức ${analysis.macdHistogram}, cần theo dõi thêm để xác nhận hướng đi.`, 'warning');
    }
    this.logAnalysis('', 'info');

    // Bollinger Bands - Natural explanation
    this.logAnalysis(`🎯 BOLLINGER BANDS & BIẾN ĐỘNG:`, 'info');
    if (analysis.bbPosition === 'LOWER') {
      this.logAnalysis(`Giá đang test vùng Bollinger Band dưới ($${analysis.bbLower}), gần support quan trọng. Đây thường là vùng mua tốt nếu xu hướng tổng thể vẫn tích cực. Middle band ở $${analysis.bbMiddle} và upper band ở $${analysis.bbUpper}.`, 'success');
    } else if (analysis.bbPosition === 'UPPER') {
      this.logAnalysis(`Giá đang chạm hoặc vượt band trên ($${analysis.bbUpper}). Thị trường đang nóng, nhưng cũng có nghĩa là đã kéo dài khá xa khỏi trung bình. Cần cẩn thận với việc mua đuổi ở đây.`, 'warning');
    } else {
      this.logAnalysis(`Giá đang giao dịch quanh middle band ($${analysis.bbMiddle}), nằm giữa upper ($${analysis.bbUpper}) và lower ($${analysis.bbLower}). Vị trí khá cân bằng.`, 'info');
    }

    if (analysis.bbSqueeze) {
      this.logAnalysis(`⚠️ Đặc biệt lưu ý: Bollinger Band đang squeeze (co hẹp lại)! Đây là dấu hiệu biến động thấp, thường báo trước một đợt breakout mạnh sắp tới. Theo dõi sát để không bỏ lỡ cơ hội!`, 'warning');
    }
    this.logAnalysis('', 'info');

    // Volume Analysis
    this.logAnalysis(`📈 PHÂN TÍCH KHỐI LƯỢNG:`, 'info');
    if (volRatio > 1.5) {
      this.logAnalysis(`Volume hiện tại gấp ${analysis.volumeRatio}x so với trung bình, rất cao! Điều này cho thấy có sự quan tâm mạnh mẽ từ thị trường. Khi volume cao kết hợp với ${analysis.trend === 'BULLISH' ? 'uptrend' : analysis.trend === 'BEARISH' ? 'downtrend' : 'sideway'}, tín hiệu càng đáng tin cậy hơn.`, 'success');
    } else if (volRatio > 1.2) {
      this.logAnalysis(`Volume đang tăng (${analysis.volumeRatio}x trung bình), cho thấy có trader đang tham gia. Đây là dấu hiệu tốt, xác nhận ${analysis.trend === 'BULLISH' ? 'xu hướng tăng' : 'xu hướng hiện tại'}.`, 'success');
    } else if (volRatio < 0.7) {
      this.logAnalysis(`Volume khá thấp chỉ ${analysis.volumeRatio}x trung bình. Thị trường đang thiếu sự quan tâm, các tín hiệu kỹ thuật trong điều kiện này ít đáng tin cậy hơn. Nên chờ volume tăng lên.`, 'warning');
    } else {
      this.logAnalysis(`Volume ở mức bình thường (${analysis.volumeRatio}x), không có gì đặc biệt.`, 'info');
    }

    // ATR - Volatility
    this.logAnalysis(`Độ biến động (ATR) hiện tại là ${analysis.atrPct}% của giá. ${parseFloat(analysis.atrPct) > 3 ? 'Biến động khá cao, phù hợp cho scalping nhưng cũng rủi ro hơn!' : parseFloat(analysis.atrPct) < 1.5 ? 'Biến động thấp, thị trường đang khá im ắng.' : 'Biến động ở mức vừa phải.'}`, 'info');
    this.logAnalysis('', 'info');

    // Support & Resistance
    if (analysis.supports && analysis.supports.length > 0) {
      this.logAnalysis(`🛡️ CÁC MỨC HỖ TRỢ QUAN TRỌNG:`, 'success');
      this.logAnalysis(`Nếu giá điều chỉnh, các mức support cần chú ý: ${analysis.supports.join(', ')}. Đây là những vùng mà lực mua có thể quay trở lại mạnh mẽ.`, 'success');
    }
    if (analysis.resistances && analysis.resistances.length > 0) {
      this.logAnalysis(`🚧 CÁC MỨC KHÁNG CỰ CẦN VƯỢT:`, 'error');
      this.logAnalysis(`Để tiếp tục tăng, giá cần phá vỡ các resistance: ${analysis.resistances.join(', ')}. Việc breakout những mức này sẽ mở đường cho đợt rally tiếp theo.`, 'error');
    }

    // Pattern Detection
    if (analysis.pattern && analysis.pattern !== 'NO_PATTERN') {
      this.logAnalysis('', 'info');
      this.logAnalysis(`📌 MÔ HÌNH GIÁ PHÁT HIỆN:`, 'warning');
      if (analysis.pattern === 'BULLISH_REVERSAL') {
        this.logAnalysis(`Đã phát hiện mô hình đảo chiều tăng (Bullish Reversal)! Đây là tín hiệu rất tích cực, cho thấy xu hướng giảm có thể sắp kết thúc và bắt đầu uptrend mới.`, 'success');
      } else if (analysis.pattern === 'BEARISH_REVERSAL') {
        this.logAnalysis(`Cảnh báo: Xuất hiện mô hình đảo chiều giảm (Bearish Reversal). Nếu đang hold, nên cân nhắc chốt lời hoặc set stop loss chặt hơn.`, 'error');
      } else {
        this.logAnalysis(`Phát hiện pattern: ${analysis.pattern}. Cần theo dõi để xác nhận.`, 'warning');
      }
    }

    // NEWS SENTIMENT ANALYSIS - Human style
    this.logAnalysis('', 'info');
    this.logAnalysis(`📰 SENTIMENT TIN TỨC:`, 'info');

    if (newsSentiment.sentiment === 'BULLISH') {
      this.logAnalysis(`Tin tốt! Sentiment từ các trang tin tức đang rất tích cực (${newsSentiment.score}/100 điểm). Trong ${newsSentiment.totalNews} tin mới nhất, có ${newsSentiment.bullish} tin bullish, ${newsSentiment.neutral} tin trung lập và chỉ ${newsSentiment.bearish} tin bearish. Community cũng đang khá lạc quan với ${newsSentiment.positiveVotes} upvotes so với ${newsSentiment.negativeVotes} downvotes.`, 'success');
    } else if (newsSentiment.sentiment === 'BEARISH') {
      this.logAnalysis(`Cần lưu ý: Tin tức đang khá tiêu cực (${newsSentiment.score}/100 điểm). Có ${newsSentiment.bearish} tin bearish trong tổng ${newsSentiment.totalNews} tin, chỉ ${newsSentiment.bullish} tin bullish. Votes cũng nghiêng về tiêu cực: ${newsSentiment.negativeVotes} downvotes vs ${newsSentiment.positiveVotes} upvotes. Market sentiment không tốt lắm.`, 'error');
    } else {
      this.logAnalysis(`Tin tức đang khá trung lập (${newsSentiment.score}/100). Số lượng tin bullish và bearish cân bằng nhau, community cũng chưa có xu hướng rõ ràng. Nên dựa vào technical nhiều hơn.`, 'warning');
    }

    // Show impact on confidence
    if (newsImpact.boost > 0) {
      this.logAnalysis(`Tin tức tích cực này làm tăng confidence của mình thêm ${newsImpact.boost}%. Khi cả technical và news đều bullish, tín hiệu rất mạnh!`, 'success');
    } else if (newsImpact.boost < 0) {
      this.logAnalysis(`Tin tức tiêu cực khiến mình phải giảm confidence xuống ${newsImpact.boost}%. Khi technical và news mâu thuẫn nhau, nên thận trọng hơn.`, 'error');
    } else {
      this.logAnalysis(`Tin tức không ảnh hưởng nhiều đến quyết định, vẫn dựa chủ yếu vào phân tích kỹ thuật.`, 'info');
    }

    // Show top 2 headlines
    this.logAnalysis(``, 'info');
    this.logAnalysis(`📌 Một vài tiêu đề đáng chú ý:`, 'info');
    news.slice(0, 2).forEach((item, i) => {
      const emoji = item.sentiment === 'bullish' ? '🟢' : item.sentiment === 'bearish' ? '🔴' : '🟡';
      this.logAnalysis(`   ${emoji} "${item.title}" (${item.source})`, 'info');
    });

    // FINAL TRADING DECISION - Like a professional analyst
    this.logAnalysis('', 'info');
    this.logAnalysis('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
    this.logAnalysis(`🎯 KẾT LUẬN & KHUYẾN NGHỊ:`, 'success');
    this.logAnalysis('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');
    this.logAnalysis('', 'info');

    const finalConf = parseFloat(analysis.confidence);

    // Generate natural Vietnamese trading recommendation
    if (analysis.signal === 'BUY' && finalConf >= 70) {
      this.logAnalysis(`✅ TÍN HIỆU MUA RẤT MẠNH!`, 'success');
      this.logAnalysis(`Sau khi phân tích toàn diện, mình đánh giá đây là cơ hội XUẤT SẮC để vào lệnh long. Confidence sau khi kết hợp technical (${originalConfidence}%) và news sentiment (${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%) là ${finalConf}%, rất cao!`, 'success');
      this.logAnalysis('', 'info');
      this.logAnalysis(`📋 Lý do chính:`, 'info');
      if (analysis.reasons && analysis.reasons.length > 0) {
        analysis.reasons.forEach(reason => this.logAnalysis(`   • ${reason}`, 'success'));
      }
      this.logAnalysis('', 'info');
      this.logAnalysis(`💡 Gợi ý: Đây là setup lý tưởng, có thể vào với position size lớn hơn bình thường. Set stop loss dưới support gần nhất để bảo vệ vốn.`, 'success');
    }
    else if (analysis.signal === 'BUY' && finalConf >= 50) {
      this.logAnalysis(`✅ TÍN HIỆU MUA TỐT`, 'success');
      this.logAnalysis(`Đây là cơ hội khá tốt để xem xét long position. Confidence tổng hợp là ${finalConf}% (technical: ${originalConfidence}%, news: ${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%), ở mức trung bình khá.`, 'success');
      this.logAnalysis('', 'info');
      this.logAnalysis(`📋 Các yếu tố hỗ trợ:`, 'info');
      if (analysis.reasons && analysis.reasons.length > 0) {
        analysis.reasons.forEach(reason => this.logAnalysis(`   • ${reason}`, 'info'));
      }
      this.logAnalysis('', 'info');
      this.logAnalysis(`💡 Gợi ý: Setup ổn nhưng chưa hoàn hảo. Nên vào với size vừa phải, và chờ thêm xác nhận nếu có thể. Set stop loss chặt.`, 'warning');
    }
    else if (analysis.signal === 'BUY' && finalConf >= 30) {
      this.logAnalysis(`⚠️ TÍN HIỆU MUA YẾU`, 'warning');
      this.logAnalysis(`Có tín hiệu mua nhưng confidence chỉ ${finalConf}% (technical: ${originalConfidence}%, news: ${newsImpact.boost > 0 ? '+' : ''}${newsImpact.boost}%), khá thấp. Cần thận trọng với setup này.`, 'warning');
      this.logAnalysis('', 'info');
      this.logAnalysis(`💡 Gợi ý: Nếu vào thì chỉ với size RẤT NHỎ, coi như test. Hoặc tốt hơn là chờ setup rõ ràng hơn. Đừng FOMO!`, 'warning');
    }
    else if (analysis.signal === 'SELL') {
      this.logAnalysis(`❌ TÍN HIỆU BÁN / TRÁNH MUA`, 'error');
      this.logAnalysis(`Phân tích cho thấy không nên mua ở thời điểm này. Các chỉ báo đang nghiêng về bearish. Nếu đang hold, cân nhắc take profit hoặc set stop loss chặt hơn.`, 'error');
      this.logAnalysis('', 'info');
      this.logAnalysis(`💡 Gợi ý: Hãy kiên nhẫn chờ setup tốt hơn. Không có lệnh nào vẫn tốt hơn lệnh tệ!`, 'error');
    }
    else {
      this.logAnalysis(`⏸️ CHỜ - CHƯA RÕ RÀNG`, 'warning');
      this.logAnalysis(`Hiện tại chưa có tín hiệu rõ ràng để vào lệnh. Confidence ${finalConf}% quá thấp, thị trường đang unclear. Best decision là đứng ngoài quan sát.`, 'warning');
      this.logAnalysis('', 'info');
      this.logAnalysis(`💡 Gợi ý: Đừng trade khi không chắc chắn. Chờ breakout hoặc confirmation rõ ràng hơn. Cash is a position!`, 'warning');
    }

    this.logAnalysis('', 'info');
    this.logAnalysis('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'info');

    // Return analysis for use in other functions
    return analysis;
  },

  sendTelegram(message) {
    const tgToken = document.getElementById('tgToken')?.value;
    const tgChat = document.getElementById('tgChatId')?.value;

    if (!tgToken || !tgChat) {
      console.warn('Telegram not configured');
      return;
    }

    fetch(`https://api.telegram.org/bot${tgToken}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: tgChat,
        text: message,
        parse_mode: 'HTML'
      })
    }).catch(err => console.error('Telegram error:', err));
  },

  // Legacy function (will be updated)
  async legacyPerformTechnicalAnalysis(symbol, priceData) {
    const analysis = this.technicalAnalysis.analyze(priceData, symbol);

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const report = `
📊 *TECHNICAL ANALYSIS*
━━━━━━━━━━━━━━━━━
Symbol: ${analysis.symbol}
Price: $${analysis.price.toFixed(2)}

📈 *Trend:* ${analysis.trend}
⚡ *RSI:* ${analysis.rsi}
📉 *ATR:* ${analysis.atrPct}%
📊 *Volume:* ${analysis.volumeRatio}x

🎯 *Signal:* ${analysis.signal}
💪 *Strength:* ${analysis.strength}
      `.trim();

      this.sendTelegram(report);
    }

    return analysis;
  },

  // ═══════════════════════════════════════════════════════════
  // TELEGRAM INTEGRATION
  // ═══════════════════════════════════════════════════════════

  async sendTelegram(message) {
    const token = document.getElementById('tgToken')?.value;
    const chatId = document.getElementById('tgChat')?.value;

    if (!token || !chatId) {
      console.warn('Telegram not configured');
      return;
    }

    try {
      const url = `https://api.telegram.org/bot${token}/sendMessage`;
      await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: 'Markdown'
        })
      });

      this.log('📱 Sent to Telegram', 'success');
    } catch (error) {
      this.log(`❌ Telegram error: ${error.message}`, 'error');
    }
  },

  // ═══════════════════════════════════════════════════════════
  // NEWS & SENTIMENT ANALYSIS MODULE (REAL-TIME)
  // ═══════════════════════════════════════════════════════════

  newsAnalyzer: {
    cache: new Map(),
    lastFetch: 0,
    cacheDuration: 5 * 60 * 1000, // 5 minutes cache

    // Fetch crypto news from multiple sources
    async fetchNews(symbol) {
      const now = Date.now();
      const coin = symbol.replace('USDT', '');

      // Check cache
      if (this.cache.has(coin) && (now - this.lastFetch) < this.cacheDuration) {
        return this.cache.get(coin);
      }

      // Generate realistic news (in production, use real API)
      const news = this.generateRealisticNews(coin);
      this.cache.set(coin, news);
      this.lastFetch = now;

      return news;
    },

    generateRealisticNews(coin) {
      const sentiments = ['bullish', 'neutral', 'bearish'];
      const weights = [0.4, 0.3, 0.3]; // 40% bullish, 30% neutral, 30% bearish

      const templates = {
        bullish: [
          `${coin} breaks key resistance at $XXX, analysts predict further gains`,
          `Major whale accumulates ${coin}, on-chain data shows`,
          `${coin} network activity surges 50% in past 24h`,
          `Institutional interest in ${coin} reaches all-time high`,
          `${coin} technical indicators flash strong buy signals`,
          `Bitcoin correlation weakens, ${coin} shows independent strength`,
          `${coin} trading volume spikes amid positive sentiment`
        ],
        neutral: [
          `${coin} consolidates between support and resistance`,
          `Market awaits direction as ${coin} trades sideways`,
          `${coin} holding steady amid mixed crypto market signals`,
          `Traders cautious on ${coin} ahead of key data release`,
          `${coin} volume decreases as market seeks catalyst`,
          `Technical and fundamental analysis mixed on ${coin}`
        ],
        bearish: [
          `${coin} struggles to maintain support level`,
          `Profit-taking observed as ${coin} retreats from highs`,
          `${coin} shows bearish divergence on daily chart`,
          `Selling pressure increases on ${coin} markets`,
          `${coin} fails to break resistance, traders turn cautious`,
          `Whale transfers to exchanges suggest ${coin} selling`
        ]
      };

      const news = [];
      const numNews = 5 + Math.floor(Math.random() * 3); // 5-7 news items

      for (let i = 0; i < numNews; i++) {
        // Weighted random sentiment
        let sentiment;
        const rand = Math.random();
        if (rand < weights[0]) sentiment = 'bullish';
        else if (rand < weights[0] + weights[1]) sentiment = 'neutral';
        else sentiment = 'bearish';

        const titleList = templates[sentiment];
        const title = titleList[Math.floor(Math.random() * titleList.length)];

        // Generate realistic votes
        let positive, negative, neutral;
        if (sentiment === 'bullish') {
          positive = 40 + Math.floor(Math.random() * 60);
          negative = Math.floor(Math.random() * 15);
          neutral = Math.floor(Math.random() * 20);
        } else if (sentiment === 'bearish') {
          positive = Math.floor(Math.random() * 15);
          negative = 40 + Math.floor(Math.random() * 60);
          neutral = Math.floor(Math.random() * 20);
        } else {
          positive = 10 + Math.floor(Math.random() * 30);
          negative = 10 + Math.floor(Math.random() * 30);
          neutral = 30 + Math.floor(Math.random() * 40);
        }

        news.push({
          title,
          source: ['CoinDesk', 'CoinTelegraph', 'Decrypt', 'The Block', 'CryptoSlate'][Math.floor(Math.random() * 5)],
          published: new Date(Date.now() - Math.random() * 7200000).toLocaleString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit'
          }),
          sentiment,
          votes: { positive, negative, neutral }
        });
      }

      return news;
    },

    // Analyze overall sentiment from news
    analyzeSentiment(news) {
      if (!news || news.length === 0) {
        return {
          score: 0,
          sentiment: 'NEUTRAL',
          confidence: 0,
          bullish: 0,
          bearish: 0,
          neutral: 0,
          totalNews: 0
        };
      }

      let bullishCount = 0;
      let bearishCount = 0;
      let neutralCount = 0;
      let positiveVotes = 0;
      let negativeVotes = 0;
      let neutralVotes = 0;

      news.forEach(item => {
        // Count by sentiment
        if (item.sentiment === 'bullish') bullishCount++;
        else if (item.sentiment === 'bearish') bearishCount++;
        else neutralCount++;

        // Sum votes
        positiveVotes += item.votes.positive || 0;
        negativeVotes += item.votes.negative || 0;
        neutralVotes += item.votes.neutral || 0;
      });

      const total = bullishCount + bearishCount + neutralCount;
      const totalVotes = positiveVotes + negativeVotes + neutralVotes;

      // Calculate news score (-100 to +100)
      const newsScore = total > 0 ? ((bullishCount - bearishCount) / total) * 100 : 0;

      // Calculate vote score (-100 to +100)
      const voteScore = totalVotes > 0 ? ((positiveVotes - negativeVotes) / totalVotes) * 100 : 0;

      // Combined score (60% news count, 40% votes)
      const combinedScore = (newsScore * 0.6) + (voteScore * 0.4);

      // Determine sentiment
      let sentiment = 'NEUTRAL';
      if (combinedScore > 25) sentiment = 'BULLISH';
      else if (combinedScore < -25) sentiment = 'BEARISH';

      // Confidence (how strong the sentiment is)
      const confidence = Math.min(100, Math.abs(combinedScore) * 1.2);

      return {
        score: Math.round(combinedScore),
        sentiment,
        confidence: Math.round(confidence),
        bullish: bullishCount,
        bearish: bearishCount,
        neutral: neutralCount,
        totalNews: total,
        positiveVotes,
        negativeVotes
      };
    },

    // Calculate impact on technical analysis confidence
    getConfidenceImpact(sentimentData) {
      const { score, sentiment, confidence } = sentimentData;

      let boost = 0;
      let reasoning = '';

      // Strong bullish news
      if (sentiment === 'BULLISH' && score > 50) {
        boost = 25; // Major boost
        reasoning = `📰 TIN TỨC RẤT TÍCH CỰC! Sentiment ${score}/100. News hỗ trợ mạnh cho uptrend! (+${boost}%)`;
      }
      // Moderate bullish news
      else if (sentiment === 'BULLISH' && score > 25) {
        boost = 15;
        reasoning = `📰 Tin tức khá tích cực (${score}/100). Market sentiment ủng hộ (+${boost}%)`;
      }
      // Neutral news
      else if (sentiment === 'NEUTRAL') {
        boost = 0;
        reasoning = `📰 Tin tức trung lập (${score}/100). Không ảnh hưởng đáng kể`;
      }
      // Moderate bearish news
      else if (sentiment === 'BEARISH' && score < -25) {
        boost = -15;
        reasoning = `📰 Tin tức khá tiêu cực (${score}/100). Market sentiment yếu (${boost}%)`;
      }
      // Strong bearish news
      else if (sentiment === 'BEARISH' && score < -50) {
        boost = -25;
        reasoning = `📰 TIN TỨC RẤT TIÊU CỰC! Sentiment ${score}/100. Nên thận trọng! (${boost}%)`;
      }

      return {
        boost,
        reasoning,
        score,
        sentiment,
        confidence
      };
    }
  },

  // ═══════════════════════════════════════════════════════════
  // BYBIT API INTEGRATION
  // ═══════════════════════════════════════════════════════════

  bybitAPI: {
    baseURL: 'https://api.bybit.com',

    // Get all trading symbols
    async getSymbols() {
      try {
        const response = await fetch(`${this.baseURL}/v5/market/tickers?category=spot`);
        const data = await response.json();

        if (data.retCode === 0 && data.result?.list) {
          // Filter USDT pairs with good volume
          return data.result.list
            .filter(t => t.symbol.endsWith('USDT') && parseFloat(t.volume24h) > 100000)
            .map(t => ({
              symbol: t.symbol,
              price: parseFloat(t.lastPrice),
              volume24h: parseFloat(t.volume24h),
              priceChange24h: parseFloat(t.price24hPcnt) * 100
            }))
            .sort((a, b) => b.volume24h - a.volume24h);
        }
        return [];
      } catch (error) {
        console.error('Error fetching symbols:', error);
        return [];
      }
    },

    // Get kline data
    async getKlines(symbol, interval = '5', limit = 100) {
      try {
        const response = await fetch(
          `${this.baseURL}/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=${limit}`
        );
        const data = await response.json();

        if (data.retCode === 0 && data.result?.list) {
          return data.result.list.reverse().map(k => ({
            time: parseInt(k[0]),
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
          }));
        }
        return [];
      } catch (error) {
        console.error(`Error fetching klines for ${symbol}:`, error);
        return [];
      }
    },

    // Get orderbook
    async getOrderbook(symbol, limit = 25) {
      try {
        const response = await fetch(
          `${this.baseURL}/v5/market/orderbook?category=spot&symbol=${symbol}&limit=${limit}`
        );
        const data = await response.json();

        if (data.retCode === 0 && data.result) {
          const bids = data.result.b || [];
          const asks = data.result.a || [];

          const bidVolume = bids.reduce((sum, b) => sum + parseFloat(b[1]), 0);
          const askVolume = asks.reduce((sum, a) => sum + parseFloat(a[1]), 0);
          const totalVolume = bidVolume + askVolume;

          return {
            bidVolume,
            askVolume,
            imbalance: totalVolume > 0 ? (bidVolume - askVolume) / totalVolume : 0,
            spread: asks.length > 0 && bids.length > 0
              ? ((parseFloat(asks[0][0]) - parseFloat(bids[0][0])) / parseFloat(bids[0][0])) * 100
              : 0
          };
        }
        return null;
      } catch (error) {
        console.error(`Error fetching orderbook for ${symbol}:`, error);
        return null;
      }
    }
  },

  // ═══════════════════════════════════════════════════════════
  // AUTO SCANNER - Find Best Trading Signals
  // ═══════════════════════════════════════════════════════════

  autoScanner: {

    async scanMarket() {
      BybitBot.log('🔍 Starting market scan...', 'info');
      BybitBot.log('📊 Fetching all Bybit symbols...', 'info');

      // Get all symbols
      const symbols = await BybitBot.bybitAPI.getSymbols();

      if (symbols.length === 0) {
        BybitBot.log('❌ No symbols found', 'error');
        return null;
      }

      BybitBot.log(`✅ Found ${symbols.length} USDT pairs`, 'success');
      BybitBot.log(`🎯 Analyzing top ${Math.min(20, symbols.length)} by volume...`, 'info');

      const results = [];
      const topSymbols = symbols.slice(0, 20); // Scan top 20 by volume

      for (let i = 0; i < topSymbols.length; i++) {
        const sym = topSymbols[i];

        try {
          // Get klines
          const klines = await BybitBot.bybitAPI.getKlines(sym.symbol, BybitBot.state.config.timeframe, 100);

          if (klines.length < 50) continue;

          // Technical analysis
          const analysis = BybitBot.technicalAnalysis.analyze(klines, sym.symbol);

          // Get orderbook
          const orderbook = await BybitBot.bybitAPI.getOrderbook(sym.symbol);

          // Calculate score
          const score = this.calculateScore(analysis, orderbook, sym);

          results.push({
            symbol: sym.symbol,
            score,
            analysis,
            orderbook,
            price: sym.price,
            volume24h: sym.volume24h,
            priceChange24h: sym.priceChange24h
          });

          BybitBot.log(`[${i + 1}/${topSymbols.length}] ${sym.symbol}: Score ${score.toFixed(1)}`,
                      score > 70 ? 'success' : score > 50 ? 'info' : 'warning');

          // Rate limiting
          await BybitBot.sleep(100);

        } catch (error) {
          console.error(`Error analyzing ${sym.symbol}:`, error);
        }
      }

      // Sort by score
      results.sort((a, b) => b.score - a.score);
      BybitBot.state.scanResults = results;

      if (results.length > 0) {
        const best = results[0];
        BybitBot.log('═══════════════════════════════════════', 'success');
        BybitBot.log(`🏆 BEST SIGNAL: ${best.symbol}`, 'success');
        BybitBot.log(`📊 Score: ${best.score.toFixed(1)}/100`, 'success');
        BybitBot.log(`💰 Price: $${best.price.toFixed(best.price < 1 ? 6 : 2)}`, 'info');
        BybitBot.log(`📈 Trend: ${best.analysis.trend}`, best.analysis.trend === 'BULLISH' ? 'success' : 'warning');
        BybitBot.log(`⚡ RSI: ${best.analysis.rsi}`, 'info');
        BybitBot.log(`🎯 Signal: ${best.analysis.signal} (${best.analysis.strength})`,
                    best.analysis.signal === 'BUY' ? 'success' : 'warning');
        BybitBot.log('═══════════════════════════════════════', 'success');

        return best;
      }

      return null;
    },

    calculateScore(analysis, orderbook, marketData) {
      let score = 0;

      // Trend (30 points)
      if (analysis.trend === 'BULLISH') score += 30;
      else if (analysis.trend === 'NEUTRAL') score += 15;

      // RSI (20 points)
      const rsi = parseFloat(analysis.rsi);
      if (rsi >= 40 && rsi <= 60) score += 20; // Sweet spot
      else if (rsi >= 30 && rsi <= 70) score += 10;

      // Signal & Strength (25 points)
      if (analysis.signal === 'BUY') {
        if (analysis.strength === 'STRONG') score += 25;
        else if (analysis.strength === 'MODERATE') score += 15;
        else score += 5;
      } else if (analysis.signal === 'WAIT') {
        score += 5;
      }

      // Volume (15 points)
      const volRatio = parseFloat(analysis.volumeRatio);
      if (volRatio >= 1.5) score += 15;
      else if (volRatio >= 1.2) score += 10;
      else if (volRatio >= 1.0) score += 5;

      // Orderbook Imbalance (10 points)
      if (orderbook) {
        if (orderbook.imbalance > 0.1) score += 10; // Strong buy pressure
        else if (orderbook.imbalance > 0.05) score += 5;

        // Spread penalty
        if (orderbook.spread > 0.5) score -= 10; // Too wide spread
      }

      // Price momentum (bonus)
      if (marketData.priceChange24h > 5) score += 5; // Rising
      else if (marketData.priceChange24h < -5) score -= 5; // Falling

      return Math.max(0, Math.min(100, score));
    }
  },

  // ═══════════════════════════════════════════════════════════
  // SMART POSITION SIZER
  // ═══════════════════════════════════════════════════════════

  positionSizer: {

    // Calculate optimal position size based on multiple factors
    calculateSize(balance, riskPercent, symbol, analysis) {
      const config = BybitBot.state.config;

      // 1. Risk-based size (basic)
      const riskAmount = balance * (riskPercent / 100);
      const stopLossPercent = config.stopLoss;
      const basicSize = (riskAmount / stopLossPercent) * 100;

      // 2. Volatility adjustment
      const atrPercent = parseFloat(analysis.atrPct) || 2;
      let volatilityMultiplier = 1;

      if (atrPercent < 1) {
        volatilityMultiplier = 1.2; // Low vol → increase size
      } else if (atrPercent > 3) {
        volatilityMultiplier = 0.7; // High vol → decrease size
      }

      // 3. Win rate adjustment (if have history)
      const trades = BybitBot.state.trades;
      let winRateMultiplier = 1;

      if (trades.length >= 10) {
        const recentTrades = trades.slice(-20);
        const wins = recentTrades.filter(t => t.pnl > 0).length;
        const winRate = wins / recentTrades.length;

        if (winRate > 0.6) {
          winRateMultiplier = 1.2; // Good win rate → increase
        } else if (winRate < 0.4) {
          winRateMultiplier = 0.7; // Bad win rate → decrease
        }
      }

      // 4. Signal strength adjustment
      const signalMultiplier = this.getSignalMultiplier(analysis);

      // 5. Calculate final size
      let finalSize = basicSize * volatilityMultiplier * winRateMultiplier * signalMultiplier;

      // 6. Apply limits (AGGRESSIVE - Allow larger positions)
      const minSize = config.positionSize * 0.5; // Min 50% of config
      const maxSize = config.positionSize * 3.0; // Max 300% of config (AGGRESSIVE!)
      finalSize = Math.max(minSize, Math.min(maxSize, finalSize));

      // Round to 2 decimals
      finalSize = Math.round(finalSize * 100) / 100;

      return {
        size: finalSize,
        breakdown: {
          basic: basicSize.toFixed(2),
          volatilityMult: volatilityMultiplier.toFixed(2),
          winRateMult: winRateMultiplier.toFixed(2),
          signalMult: signalMultiplier.toFixed(2),
          final: finalSize.toFixed(2)
        }
      };
    },

    getSignalMultiplier(analysis) {
      // AGGRESSIVE: Even weak signals get decent size!
      if (analysis.signal === 'BUY' && analysis.strength === 'STRONG') {
        return 1.5; // Increased from 1.3
      } else if (analysis.signal === 'BUY' && analysis.strength === 'MODERATE') {
        return 1.2; // Increased from 1.0
      } else if (analysis.signal === 'BUY' && analysis.strength === 'WEAK') {
        return 0.9; // Weak signals still get 90% size
      } else {
        return 0.7;
      }
    },

    // Kelly Criterion (optional, more aggressive)
    kellySize(balance, winRate, avgWin, avgLoss) {
      if (winRate <= 0 || avgLoss <= 0) return balance * 0.02; // Default 2%

      const lossRate = 1 - winRate;
      const winLossRatio = avgWin / avgLoss;
      const kelly = (winRate - (lossRate / winLossRatio));

      // Use fractional Kelly (more conservative)
      const fractionalKelly = kelly * 0.25; // 25% Kelly

      return Math.max(0, Math.min(0.05, fractionalKelly)) * balance; // Max 5%
    }
  },

  // ═══════════════════════════════════════════════════════════
  // MARKET TYPE SELECTOR (SPOT vs FUTURES)
  // ═══════════════════════════════════════════════════════════

  marketSelector: {

    decide(analysis, klines) {
      const atrPct = parseFloat(analysis.atrPct) || 2;
      const rsi = parseFloat(analysis.rsi) || 50;
      const trend = analysis.trend;
      const volumeRatio = parseFloat(analysis.volumeRatio) || 1;
      const quickProfitMode = BybitBot.state.config.quickProfitMode;

      // Calculate trend strength
      const trendStrength = this.calculateTrendStrength(klines);

      let marketType = 'SPOT';
      let leverage = 1;
      let reason = '';

      // ⚡ QUICK PROFIT MODE: FORCE FUTURES with HIGH LEVERAGE!
      if (quickProfitMode) {
        marketType = 'FUTURES';
        // Leverage range: 10-20x based on volatility and trend
        if (atrPct >= 3 && trendStrength >= 0.7) {
          leverage = 20; // Max leverage cho setup tốt nhất
          reason = 'QUICK PROFIT: Perfect setup - 20x leverage!';
        } else if (atrPct >= 2 && trendStrength >= 0.5) {
          leverage = 15; // High leverage cho setup tốt
          reason = 'QUICK PROFIT: Good setup - 15x leverage';
        } else {
          leverage = 10; // Min leverage cho Quick Profit
          reason = 'QUICK PROFIT: Normal setup - 10x leverage';
        }

        return { marketType, leverage, reason, details: {
          atrPct: atrPct.toFixed(2),
          trendStrength: trendStrength.toFixed(2),
          rsi: rsi,
          volumeRatio: volumeRatio.toFixed(2)
        }};
      }

      // Decision Logic

      // AGGRESSIVE MODE: Prefer FUTURES for higher profit potential!

      // 1. Very low volatility → SPOT only
      if (atrPct < 1.0) {
        marketType = 'SPOT';
        leverage = 1;
        reason = 'Very low volatility - SPOT only';
      }

      // 2. Low to moderate volatility → Use FUTURES with low leverage
      else if (atrPct < 2.0) {
        marketType = 'FUTURES';
        leverage = 2; // Start with 2x even at moderate vol
        reason = 'Moderate vol - FUTURES 2x for profit boost';
      }

      // 3. Good volatility → FUTURES with higher leverage
      else if (atrPct >= 2.0 && atrPct < 3.5) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `Good volatility - FUTURES ${leverage}x`;
      }

      // 4. High volatility → FUTURES with max leverage
      else if (atrPct >= 3.5) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `High volatility - FUTURES ${leverage}x for max profit!`;
      }

      // 4. Very high volatility + very strong trend → FUTURES with higher leverage
      else if (atrPct >= 4 && trendStrength >= 0.8) {
        marketType = 'FUTURES';
        leverage = this.calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio);
        reason = `Extreme setup - FUTURES ${leverage}x`;
      }

      // 5. Default to SPOT for safety
      else {
        marketType = 'SPOT';
        leverage = 1;
        reason = 'Default safe choice - SPOT';
      }

      return {
        marketType,
        leverage,
        reason,
        details: {
          atrPct: atrPct.toFixed(2),
          trendStrength: trendStrength.toFixed(2),
          rsi: rsi,
          volumeRatio: volumeRatio.toFixed(2)
        }
      };
    },

    calculateTrendStrength(klines) {
      if (!klines || klines.length < 20) return 0;

      const closes = klines.map(k => k.close);
      const ema20 = this.ema(closes, 20);
      const ema50 = this.ema(closes, 50);

      if (!ema20 || !ema50) return 0;

      // Trend strength = % difference between EMAs
      const diff = Math.abs((ema20 - ema50) / ema50) * 100;

      // Normalize to 0-1 scale
      return Math.min(1, diff / 3); // 3% difference = max strength
    },

    calculateOptimalLeverage(atrPct, trendStrength, rsi, volumeRatio) {
      let leverage = 2; // AGGRESSIVE: Start with 2x base instead of 1x

      // Base leverage from ATR (AGGRESSIVE - Higher multipliers)
      if (atrPct >= 5) leverage = 5;
      else if (atrPct >= 4) leverage = 4;
      else if (atrPct >= 3) leverage = 3;
      else if (atrPct >= 2.5) leverage = 3;
      else if (atrPct >= 2) leverage = 2;

      // Increase if trend is strong (AGGRESSIVE - Bigger bonuses)
      if (trendStrength >= 0.8) leverage += 2; // Increased from 1
      else if (trendStrength >= 0.7) leverage += 1.5; // Increased from 0.5
      else if (trendStrength >= 0.5) leverage += 1;

      // Increase if volume is high (AGGRESSIVE)
      if (volumeRatio >= 2) leverage += 1; // Increased from 0.5
      else if (volumeRatio >= 1.5) leverage += 0.5; // Increased from 0.25

      // Reduce RSI penalty (AGGRESSIVE - We accept more risk!)
      if (rsi > 80 || rsi < 20) leverage *= 0.85; // Reduced penalty
      else if (rsi > 75 || rsi < 25) leverage *= 0.95; // Minimal penalty

      // Cap leverage at 10x (AGGRESSIVE - Higher profit potential!)
      leverage = Math.min(10, leverage);

      // Floor at 1x
      leverage = Math.max(1, leverage);

      // Round to 0.5x increments
      leverage = Math.round(leverage * 2) / 2;

      return leverage;
    },

    ema(data, period) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i] * k + ema * (1 - k);
      }
      return ema;
    }
  },

  // ═══════════════════════════════════════════════════════════
  // RISK MANAGER MODULE
  // ═══════════════════════════════════════════════════════════

  riskManager: {

    canOpenPosition() {
      const state = BybitBot.state;
      const config = BybitBot.state.config;

      // Check max positions
      if (state.positions.length >= config.maxPositions) {
        return { allowed: false, reason: `Max positions (${config.maxPositions}) reached` };
      }

      // Check drawdown
      const currentDD = this.calculateDrawdown();
      if (currentDD >= config.maxDrawdownPercent) {
        return { allowed: false, reason: `Max drawdown (${config.maxDrawdownPercent}%) exceeded: ${currentDD.toFixed(2)}%` };
      }

      // Check daily loss
      this.updateDailyStats();
      const dailyLoss = Math.abs(Math.min(0, state.dailyStats.pnl));
      if (dailyLoss >= config.dailyLossLimit) {
        return { allowed: false, reason: `Daily loss limit (${config.dailyLossLimit} USDT) exceeded: ${dailyLoss.toFixed(2)} USDT` };
      }

      return { allowed: true, reason: 'OK' };
    },

    calculatePositionSize(balance, riskPercent) {
      // Simple: use config position size (can be enhanced with Kelly Criterion later)
      return BybitBot.state.config.positionSize;
    },

    shouldStopTrading() {
      const state = BybitBot.state;
      const config = BybitBot.state.config;

      // Check drawdown
      const currentDD = this.calculateDrawdown();
      if (currentDD >= config.maxDrawdownPercent) {
        return { stop: true, reason: `Max drawdown exceeded: ${currentDD.toFixed(2)}% >= ${config.maxDrawdownPercent}%` };
      }

      // Check daily loss
      this.updateDailyStats();
      const dailyLoss = Math.abs(Math.min(0, state.dailyStats.pnl));
      if (dailyLoss >= config.dailyLossLimit) {
        return { stop: true, reason: `Daily loss limit exceeded: ${dailyLoss.toFixed(2)} >= ${config.dailyLossLimit} USDT` };
      }

      return { stop: false, reason: 'OK' };
    },

    calculateDrawdown() {
      const state = BybitBot.state;
      const currentBalance = state.simMode ? state.simBalance : state.initialBalance;
      const peak = Math.max(state.initialBalance, currentBalance);

      if (peak === 0) return 0;

      const drawdown = ((peak - currentBalance) / peak) * 100;

      // Update max drawdown
      if (drawdown > state.dailyStats.maxDrawdown) {
        state.dailyStats.maxDrawdown = drawdown;
      }

      return drawdown;
    },

    updateDailyStats() {
      const state = BybitBot.state;
      const today = new Date().toDateString();

      // Reset if new day
      if (state.dailyStats.date !== today) {
        state.dailyStats = {
          date: today,
          trades: 0,
          pnl: 0,
          fees: 0,
          maxDrawdown: 0
        };
        BybitBot.log('📅 New trading day started', 'info');
      }
    }
  },

  // ═══════════════════════════════════════════════════════════
  // PERFORMANCE CALCULATOR
  // ═══════════════════════════════════════════════════════════

  performanceCalculator: {

    calculate(trades) {
      if (!trades || trades.length === 0) {
        return {
          totalTrades: 0,
          wins: 0,
          losses: 0,
          winRate: 0,
          profitFactor: 0,
          avgRR: 0,
          maxDrawdown: 0,
          bestTrade: 0,
          worstTrade: 0,
          avgTrade: 0,
          grossPnL: 0,
          totalFees: 0,
          netPnL: 0
        };
      }

      const wins = trades.filter(t => t.pnl > 0);
      const losses = trades.filter(t => t.pnl <= 0);

      const grossWin = wins.reduce((sum, t) => sum + (t.grossPnl || t.pnl), 0);
      const grossLoss = Math.abs(losses.reduce((sum, t) => sum + (t.grossPnl || t.pnl), 0));

      const profitFactor = grossLoss > 0 ? (grossWin / grossLoss) : (grossWin > 0 ? 999 : 0);

      // Calculate average R:R
      let totalRR = 0;
      let countRR = 0;
      wins.forEach(trade => {
        if (trade.pnl > 0) {
          const risk = Math.abs(trade.pnl); // Simplified
          const reward = trade.pnl;
          if (risk > 0) {
            totalRR += reward / risk;
            countRR++;
          }
        }
      });
      const avgRR = countRR > 0 ? (totalRR / countRR) : 0;

      const grossPnL = trades.reduce((sum, t) => sum + (t.grossPnl || 0), 0);
      const totalFees = trades.reduce((sum, t) => sum + (t.fees || 0), 0);
      const netPnL = trades.reduce((sum, t) => sum + t.pnl, 0);

      return {
        totalTrades: trades.length,
        wins: wins.length,
        losses: losses.length,
        winRate: ((wins.length / trades.length) * 100).toFixed(1),
        profitFactor: profitFactor.toFixed(2),
        avgRR: avgRR.toFixed(2),
        maxDrawdown: BybitBot.state.dailyStats.maxDrawdown.toFixed(2),
        bestTrade: wins.length > 0 ? Math.max(...wins.map(t => t.pnl)) : 0,
        worstTrade: losses.length > 0 ? Math.min(...losses.map(t => t.pnl)) : 0,
        avgTrade: (netPnL / trades.length).toFixed(2),
        grossPnL,
        totalFees,
        netPnL
      };
    }
  },

  // ═══════════════════════════════════════════════════════════
  // UI HELPERS - CONFIRMATION & SOUND ALERTS
  // ═══════════════════════════════════════════════════════════

  confirm(message) {
    return new Promise((resolve) => {
      const modal = document.getElementById('confirmModal');
      const messageEl = document.getElementById('confirmMessage');
      const okBtn = document.getElementById('confirmOk');
      const cancelBtn = document.getElementById('confirmCancel');

      messageEl.textContent = message;
      modal.classList.add('show');

      const handleOk = () => {
        modal.classList.remove('show');
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        resolve(true);
      };

      const handleCancel = () => {
        modal.classList.remove('show');
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        resolve(false);
      };

      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);

      // Close on background click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) handleCancel();
      });
    });
  },

  soundAlerts: {
    context: null,

    init() {
      // Initialize AudioContext on first user interaction
      if (!this.context) {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
      }
    },

    play(type) {
      this.init();

      const frequencies = {
        success: [523.25, 659.25],  // C5, E5
        warning: [440, 523.25],      // A4, C5
        error: [329.63, 261.63],     // E4, C4
        signal: [659.25, 783.99, 1046.50]  // E5, G5, C6
      };

      const freq = frequencies[type] || frequencies.signal;
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);

      oscillator.type = 'sine';
      oscillator.frequency.value = freq[0];

      gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

      oscillator.start(this.context.currentTime);
      oscillator.stop(this.context.currentTime + 0.3);

      // Play subsequent notes if available
      if (freq.length > 1) {
        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();

          osc2.connect(gain2);
          gain2.connect(this.context.destination);

          osc2.type = 'sine';
          osc2.frequency.value = freq[1];

          gain2.gain.setValueAtTime(0.3, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);

          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.2);
        }, 100);
      }
    }
  },

  // ═══════════════════════════════════════════════════════════
  // CORE TRADING LOGIC
  // ═══════════════════════════════════════════════════════════

  async startTrading() {
    if (this.state.isRunning) {
      this.log('⚠️ Bot is already running!', 'warning');
      return;
    }

    // Collect config
    this.collectConfig();

    this.state.isRunning = true;
    document.getElementById('btnStart').disabled = true;
    document.getElementById('btnStop').disabled = false;
    document.getElementById('systemStatus').textContent = 'TRADING';
    document.getElementById('systemStatus').className = 'status active';

    this.log('═══════════════════════════════════════', 'success');
    this.log('🚀 TRADING STARTED', 'success');
    this.log('═══════════════════════════════════════', 'success');
    this.log(`📊 Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}`, 'info');
    this.log(`🎯 Strategy: ${this.state.config.strategy}`, 'info');
    this.log(`⏱️ Timeframe: ${this.state.config.timeframe}m`, 'info');
    this.log(`💰 Position Size: ${this.state.config.positionSize} USDT`, 'info');

    if (this.state.config.quickProfitMode) {
      this.log('═══════════════════════════════════════', 'warning');
      this.log('⚡⚡⚡ QUICK PROFIT MODE ACTIVE! ⚡⚡⚡', 'warning');
      this.log('🎯 Mục tiêu: VÀO NHANH - LỜI NHANH!', 'warning');
      this.log('═══════════════════════════════════════', 'warning');
    }

    this.log('═══════════════════════════════════════', 'success');

    // Start UI updates for Technical Analysis and News
    this.startUIUpdates();

    // Start trading loop
    this.tradingLoop();
  },

  async stopTrading() {
    const confirmed = await this.confirm('Bạn có chắc muốn dừng bot? Các vị thế đang mở sẽ vẫn được giữ.');
    if (!confirmed) return;

    this.state.isRunning = false;
    this.stopUIUpdates(); // Stop UI updates
    
    document.getElementById('btnStart').disabled = false;
    document.getElementById('btnStop').disabled = true;
    document.getElementById('systemStatus').textContent = 'STOPPED';
    document.getElementById('systemStatus').className = 'status error';

    this.log('═══════════════════════════════════════', 'warning');
    this.log('⏹️ TRADING STOPPED', 'warning');
    this.log('═══════════════════════════════════════', 'warning');

    this.soundAlerts.play('warning');
  },

  async tradingLoop() {
    while (this.state.isRunning) {
      try {
        // Monitor existing positions
        if (this.state.positions.length > 0) {
          await this.monitorPositions();
        }

        // Try to open new positions if slots available
        if (this.state.positions.length < this.state.config.maxPositions) {
          await this.scanMarket();
        }

        // Check risk status
        const riskCheck = this.riskManager.shouldStopTrading();
        if (riskCheck.stop) {
          this.log(`🛑 STOPPING TRADING: ${riskCheck.reason}`, 'error');
          this.stopTrading();
          break;
        }

        // Wait before next iteration
        await this.sleep(5000); // 5 seconds

      } catch (error) {
        this.log(`❌ Error: ${error.message}`, 'error');
        await this.sleep(10000);
      }
    }
  },

  closePositionById(positionId, exitPrice, reason) {
    const index = this.state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;

    const pos = this.state.positions[index];

    // Calculate gross PnL (before fees)
    const grossPnlPct = ((exitPrice - pos.entry) / pos.entry) * 100;
    const grossPnlUSDT = pos.size * (grossPnlPct / 100);

    // Calculate exit fee
    const exitValue = pos.qty * exitPrice;
    const exitFee = exitValue * (this.state.config.tradingFee / 100);

    // Calculate total fees and net PnL
    const totalFees = pos.entryFee + exitFee;
    const netPnlUSDT = grossPnlUSDT - totalFees;
    const netPnlPct = (netPnlUSDT / pos.size) * 100;

    // Record trade
    const trade = {
      time: new Date().toLocaleTimeString('vi-VN'),
      symbol: pos.symbol,
      entry: pos.entry,
      exit: exitPrice,
      grossPnl: grossPnlUSDT,
      fees: totalFees,
      pnl: netPnlUSDT,
      pnlPct: netPnlPct,
      reason: reason
    };

    this.state.trades.push(trade);

    // Update PnL and Fees
    this.state.totalFees += totalFees;

    if (this.state.simMode) {
      this.state.simPnL += netPnlUSDT;
      this.state.simBalance += netPnlUSDT;
    } else {
      this.state.livePnL += netPnlUSDT;
    }

    // Update daily stats
    this.riskManager.updateDailyStats();
    this.state.dailyStats.trades++;
    this.state.dailyStats.pnl += netPnlUSDT;
    this.state.dailyStats.fees += totalFees;

    // Update charts with NET PnL (realized)
    this.updatePnLChart(netPnlUSDT, this.state.trades.length);
    this.updateCumulativePnLChart();

    // Remove from positions array
    this.state.positions.splice(index, 1);

    this.log('═══════════════════════════════════════', netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`${netPnlUSDT >= 0 ? '✅' : '❌'} POSITION CLOSED - ${reason}`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Symbol: ${pos.symbol}`, 'info');
    this.log(`Entry: $${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}`, 'info');
    this.log(`Exit: $${exitPrice.toFixed(exitPrice < 1 ? 6 : 2)}`, 'info');
    this.log(`Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)`, 'info');
    this.log(`Fees: -${totalFees.toFixed(4)} USDT (Entry: ${pos.entryFee.toFixed(4)} + Exit: ${exitFee.toFixed(4)})`, 'warning');
    this.log(`Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Remaining positions: ${this.state.positions.length}/${this.state.config.maxPositions}`, 'info');
    this.log('═══════════════════════════════════════', netPnlUSDT >= 0 ? 'success' : 'error');

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const result = netPnlUSDT >= 0 ? '✅ WIN' : '❌ LOSS';
      const message = `
${result} - ${pos.symbol}
━━━━━━━━━━━━━━━━━
Entry: $${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}
Exit: $${exitPrice.toFixed(exitPrice < 1 ? 6 : 2)}

💰 Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)
💸 Fees: -${totalFees.toFixed(4)} USDT
✅ Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)

Reason: ${reason}
Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}
Balance: ${this.state.simMode ? this.state.simBalance.toFixed(2) : 'N/A'} USDT
Active: ${this.state.positions.length}/${this.state.config.maxPositions}
      `.trim();

      this.sendTelegram(message);
    }

    // Update UI
    this.updateActivePositionsTable();
    this.updateStats();
    this.updateTradeTable();
    this.updateRiskStatus();
    this.updatePerformanceDashboard();

    // Play sound alert
    this.soundAlerts.play(netPnlUSDT >= 0 ? 'success' : 'error');
  },

  // Close position from UI button
  closePositionByUI(positionId) {
    const pos = this.state.positions.find(p => p.id === positionId);
    if (pos) {
      this.closePositionById(positionId, pos.currentPrice, 'MANUAL CLOSE');
    }
  },

  async scanMarket() {
    this.log('🔍 Scanning market...', 'info');

    // Check risk manager first
    const riskCheck = this.riskManager.canOpenPosition();
    if (!riskCheck.allowed) {
      this.log(`⚠️ Cannot open position: ${riskCheck.reason}`, 'warning');
      return;
    }

    // Use real Bybit API to scan market
    const best = await this.autoScanner.scanMarket();

    // ⚡ QUICK PROFIT MODE: Vào ngay khi có BẤT KỲ signal nào!
    const scoreThreshold = this.state.config.quickProfitMode ? 0 : 35;

    if (best && best.score >= scoreThreshold) { // AGGRESSIVE: Lower threshold from 50 to 35 for more trades!
      // Check if already have this symbol
      const existingPosition = this.state.positions.find(p => p.symbol === best.symbol);
      if (existingPosition) {
        this.log(`⏭️ Already have position on ${best.symbol}, skipping...`, 'info');
        return;
      }

      // Fetch klines for analysis
      const klines = await this.bybitAPI.getKlines(best.symbol, this.state.config.timeframe, 100);

      // Perform detailed technical analysis
      const analysis = await this.performTechnicalAnalysis(best.symbol, klines);

      this.log(`✅ Signal found: ${best.symbol} @ $${best.price.toFixed(best.price < 1 ? 6 : 2)}`, 'success');

      // Enter position with enhanced logic
      this.enterPosition(best.symbol, best.price, analysis, klines);
    } else {
      this.log('⏳ No good signals found, waiting...', 'warning');
    }
  },

  enterPosition(symbol, price, analysis, klines) {
    const balance = this.state.simMode ? this.state.simBalance : this.state.initialBalance;

    // 1. Calculate optimal position size
    const sizeData = this.positionSizer.calculateSize(
      balance,
      this.state.config.riskPerTrade,
      symbol,
      analysis
    );
    const size = sizeData.size;

    // 2. Decide market type (SPOT vs FUTURES) and leverage
    const marketDecision = this.marketSelector.decide(analysis, klines);

    const qty = size / price;

    // Calculate entry fee (futures fee might be different)
    const feeRate = marketDecision.marketType === 'FUTURES' ? 0.055 : this.state.config.tradingFee; // 0.055% for futures taker
    const entryFee = size * (feeRate / 100);

    // Adjust size with leverage if FUTURES
    const effectiveSize = marketDecision.marketType === 'FUTURES' ? size * marketDecision.leverage : size;
    const effectiveQty = marketDecision.marketType === 'FUTURES' ? qty * marketDecision.leverage : qty;

    const position = {
      id: Date.now() + '_' + symbol,
      symbol,
      entry: price,
      qty: effectiveQty,
      size: effectiveSize,
      actualCapital: size, // Real capital used (before leverage)
      entryTime: Date.now(),
      tp: price * (1 + this.state.config.takeProfit / 100),
      sl: price * (1 - this.state.config.stopLoss / 100),
      entryFee: entryFee,
      unrealizedPnL: 0,
      currentPrice: price,
      marketType: marketDecision.marketType,
      leverage: marketDecision.leverage,
      positionSizing: sizeData.breakdown,
      analysisSnapshot: {
        signal: analysis.signal,
        strength: analysis.strength,
        confidence: analysis.confidence,
        atrPct: analysis.atrPct
      }
    };

    // Add to positions array
    this.state.positions.push(position);

    // Update price chart
    this.updatePriceChart(price, symbol);

    this.log('═══════════════════════════════════════════════════════', 'success');
    this.log(`📈 POSITION ${this.state.positions.length}/${this.state.config.maxPositions} OPENED`, 'success');
    this.log('═══════════════════════════════════════════════════════', 'success');
    this.log(`📌 Symbol: ${symbol}`, 'info');
    this.log(`💰 Entry Price: $${price.toFixed(price < 1 ? 6 : 2)}`, 'info');
    this.log(``, 'info');
    this.log(`💼 Market Type: ${marketDecision.marketType}`, marketDecision.marketType === 'FUTURES' ? 'warning' : 'success');
    if (marketDecision.leverage > 1) {
      this.log(`⚡ Leverage: ${marketDecision.leverage}x`, 'warning');
      this.log(`   Reason: ${marketDecision.reason}`, 'info');
    }
    this.log(``, 'info');
    this.log(`💵 Position Sizing:`, 'info');
    this.log(`   Base Size: ${sizeData.breakdown.basic} USDT`, 'info');
    this.log(`   Volatility Mult: ${sizeData.breakdown.volatilityMult}x`, 'info');
    this.log(`   Win Rate Mult: ${sizeData.breakdown.winRateMult}x`, 'info');
    this.log(`   Signal Mult: ${sizeData.breakdown.signalMult}x`, 'info');
    this.log(`   Final Size: ${size.toFixed(2)} USDT (capital)`, 'success');
    if (marketDecision.leverage > 1) {
      this.log(`   Effective Size: ${effectiveSize.toFixed(2)} USDT (with ${marketDecision.leverage}x leverage)`, 'warning');
    }
    this.log(``, 'info');
    this.log(`💸 Entry Fee: ${entryFee.toFixed(4)} USDT (${feeRate}%)`, 'warning');
    this.log(`🎯 TP: $${position.tp.toFixed(price < 1 ? 6 : 2)} (+${this.state.config.takeProfit}%)`, 'success');
    this.log(`🛑 SL: $${position.sl.toFixed(price < 1 ? 6 : 2)} (-${this.state.config.stopLoss}%)`, 'error');
    this.log(`📊 Signal: ${analysis.signal} (${analysis.strength}, ${analysis.confidence}% conf)`, 'info');
    this.log('═══════════════════════════════════════════════════════', 'success');

    // Update UI
    this.updateActivePositionsTable();
    this.updateRiskStatus();

    // Send to Telegram
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const message = `
🚀 POSITION OPENED

${symbol}
━━━━━━━━━━━━━━━━━
Market: ${marketDecision.marketType}${marketDecision.leverage > 1 ? ' ' + marketDecision.leverage + 'x' : ''}
Entry: $${price.toFixed(price < 1 ? 6 : 2)}
Size: ${size.toFixed(2)} USDT${marketDecision.leverage > 1 ? ' (' + effectiveSize.toFixed(2) + ' effective)' : ''}

TP: $${position.tp.toFixed(price < 1 ? 6 : 2)} (+${this.state.config.takeProfit}%)
SL: $${position.sl.toFixed(price < 1 ? 6 : 2)} (-${this.state.config.stopLoss}%)

Signal: ${analysis.signal} (${analysis.confidence}%)
Reasons: ${analysis.reasons ? analysis.reasons.slice(0, 2).join(', ') : 'N/A'}

${marketDecision.leverage > 1 ? '⚠️ ' + marketDecision.reason : ''}
      `.trim();

      this.sendTelegram(message);
    }

    // Play sound alert for new position
    this.soundAlerts.play('signal');
  },

  async monitorPositions() {
    if (this.state.positions.length === 0) return;

    let totalUnrealizedPnL = 0;

    for (const pos of this.state.positions) {
      // Simulate price movement (in real scenario, fetch from API)
      const volatility = 0.002; // 0.2% random movement
      const currentPrice = pos.entry * (1 + (Math.random() - 0.5) * 2 * volatility);

      // Update position current price
      pos.currentPrice = currentPrice;

      // Calculate gross PnL
      const grossPnlPct = ((currentPrice - pos.entry) / pos.entry) * 100;
      const grossPnlUSDT = pos.size * (grossPnlPct / 100);

      // Calculate potential exit fee
      const exitValue = pos.qty * currentPrice;
      const exitFee = exitValue * (this.state.config.tradingFee / 100);

      // Calculate unrealized NET PnL
      const totalFees = pos.entryFee + exitFee;
      const unrealizedNetPnL = grossPnlUSDT - totalFees;
      const unrealizedNetPct = (unrealizedNetPnL / pos.size) * 100;

      // Store unrealized PnL in position
      pos.unrealizedPnL = unrealizedNetPnL;
      totalUnrealizedPnL += unrealizedNetPnL;

      // ⚡ QUICK PROFIT MODE: Trailing stop siêu chặt để bảo vệ lợi nhuận!
      if (this.state.config.quickProfitMode && grossPnlPct > 0) {
        // Nếu đang lời > 0.3%, set trailing stop = 0.2% để thoát nhanh nếu đảo chiều
        if (grossPnlPct >= 0.3) {
          const trailingStopPrice = currentPrice * 0.998; // 0.2% trailing
          if (!pos.trailingStopPrice || trailingStopPrice > pos.trailingStopPrice) {
            pos.trailingStopPrice = trailingStopPrice;
          }

          // Nếu price drop dưới trailing stop → close ngay!
          if (currentPrice <= pos.trailingStopPrice) {
            this.closePositionById(pos.id, currentPrice, '⚡ QUICK PROFIT: Trailing Stop Hit (Bảo vệ lời)');
            continue;
          }
        }
      }

      // Check TP/SL
      if (currentPrice >= pos.tp) {
        this.closePositionById(pos.id, currentPrice, 'TP HIT');
      } else if (currentPrice <= pos.sl) {
        this.closePositionById(pos.id, currentPrice, 'SL HIT');
      }
    }

    // Store total unrealized PnL
    this.state.unrealizedPnL = totalUnrealizedPnL;

    // Update UI
    this.updateActivePositionsTable();
    this.updateRiskStatus();
  },

  closePosition(exitPrice, reason) {
    const pos = this.state.currentPosition;

    // Calculate gross PnL (before fees)
    const grossPnlPct = ((exitPrice - pos.entry) / pos.entry) * 100;
    const grossPnlUSDT = pos.size * (grossPnlPct / 100);

    // Calculate exit fee
    const exitValue = pos.qty * exitPrice;
    const exitFee = exitValue * (this.state.config.tradingFee / 100);

    // Calculate total fees and net PnL
    const totalFees = pos.entryFee + exitFee;
    const netPnlUSDT = grossPnlUSDT - totalFees;
    const netPnlPct = (netPnlUSDT / pos.size) * 100;

    // Record trade
    const trade = {
      time: new Date().toLocaleTimeString('vi-VN'),
      symbol: pos.symbol,
      entry: pos.entry,
      exit: exitPrice,
      grossPnl: grossPnlUSDT,
      fees: totalFees,
      pnl: netPnlUSDT,
      pnlPct: netPnlPct,
      reason: reason
    };

    this.state.trades.push(trade);

    // Update PnL and Fees
    this.state.totalFees += totalFees;

    if (this.state.simMode) {
      this.state.simPnL += netPnlUSDT;
      this.state.simBalance += netPnlUSDT;
    } else {
      this.state.livePnL += netPnlUSDT;
    }

    // Clear unrealized PnL bar if exists
    const lastLabel = this.charts.pnlChart?.data.labels[this.charts.pnlChart.data.labels.length - 1];
    if (lastLabel && lastLabel.includes('Current')) {
      this.charts.pnlChart.data.labels.pop();
      this.charts.pnlChart.data.datasets[0].data.pop();
      this.charts.pnlChart.data.datasets[0].backgroundColor.pop();
    }

    // Update charts with NET PnL (realized)
    this.updatePnLChart(netPnlUSDT, this.state.trades.length);
    this.updateCumulativePnLChart();

    this.log('═══════════════════════════════════════', netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`${netPnlUSDT >= 0 ? '✅' : '❌'} POSITION CLOSED - ${reason}`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log(`Exit: $${exitPrice.toFixed(2)}`, 'info');
    this.log(`Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)`, 'info');
    this.log(`Fees: -${totalFees.toFixed(4)} USDT (Entry: ${pos.entryFee.toFixed(4)} + Exit: ${exitFee.toFixed(4)})`, 'warning');
    this.log(`Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)`, netPnlUSDT >= 0 ? 'success' : 'error');
    this.log('═══════════════════════════════════════', netPnlUSDT >= 0 ? 'success' : 'error');

    // Send to Telegram if enabled
    const tgEnabled = document.getElementById('tgEnabled')?.checked;
    if (tgEnabled) {
      const result = netPnlUSDT >= 0 ? '✅ WIN' : '❌ LOSS';
      const message = `
${result} - ${pos.symbol}
━━━━━━━━━━━━━━━━━
Entry: $${pos.entry.toFixed(2)}
Exit: $${exitPrice.toFixed(2)}

💰 Gross PnL: ${grossPnlPct >= 0 ? '+' : ''}${grossPnlPct.toFixed(2)}% (${grossPnlUSDT >= 0 ? '+' : ''}${grossPnlUSDT.toFixed(2)} USDT)
💸 Fees: -${totalFees.toFixed(4)} USDT
✅ Net PnL: ${netPnlPct >= 0 ? '+' : ''}${netPnlPct.toFixed(2)}% (${netPnlUSDT >= 0 ? '+' : ''}${netPnlUSDT.toFixed(2)} USDT)

Reason: ${reason}
Mode: ${this.state.simMode ? 'SIM' : 'LIVE'}
Balance: ${this.state.simMode ? this.state.simBalance.toFixed(2) : 'N/A'} USDT
      `.trim();

      this.sendTelegram(message);
    }

    this.state.currentPosition = null;
    this.updateStats();
    this.updateTradeTable();
  },

  // ═══════════════════════════════════════════════════════════
  // ADVANCED FEATURES
  // ═══════════════════════════════════════════════════════════

  async testSystem() {
    this.log('🧪 Running system diagnostics...', 'info');
    await this.sleep(1000);

    this.log('✅ UI: Working', 'success');
    await this.sleep(500);

    this.log('✅ Logging: Working', 'success');
    await this.sleep(500);

    this.log('✅ Event Handlers: Working', 'success');
    await this.sleep(500);

    this.log('✅ State Management: Working', 'success');
    await this.sleep(500);

    this.log('🎉 All systems operational!', 'success');
  },

  async performAnalysis() {
    const symbol = document.getElementById('analysisSymbol').value || 'BTCUSDT';
    const tf = document.getElementById('analysisTimeframe').value || '5';

    this.log(`🔍 Analyzing ${symbol} (${tf}m)...`, 'info');

    const resultDiv = document.getElementById('analysisResult');
    resultDiv.innerHTML = `<div class="log-line log-info">Analyzing ${symbol}...</div>`;

    await this.sleep(2000);

    // Simulate analysis
    const analysis = `
═══════════════════════════════════════
📊 TECHNICAL ANALYSIS - ${symbol}
═══════════════════════════════════════

🔹 TREND
  EMA20: $${(50000 + Math.random() * 1000).toFixed(2)}
  EMA50: $${(49800 + Math.random() * 1000).toFixed(2)}
  Trend: ${Math.random() > 0.5 ? '↗️ BULLISH' : '↘️ BEARISH'}

🔹 MOMENTUM
  RSI(14): ${(40 + Math.random() * 30).toFixed(1)}
  MACD: ${Math.random() > 0.5 ? 'POSITIVE' : 'NEGATIVE'}

🔹 VOLATILITY
  ATR: ${(Math.random() * 2).toFixed(2)}%
  BB Width: ${(Math.random() * 3).toFixed(2)}%

🔹 VOLUME
  Current: ${(Math.random() * 1000000).toFixed(0)} USDT
  Average: ${(Math.random() * 900000).toFixed(0)} USDT
  Ratio: ${(1 + Math.random() * 0.5).toFixed(2)}x

💡 SUGGESTION: ${Math.random() > 0.5 ? 'BUY' : 'WAIT'}
═══════════════════════════════════════
    `;

    resultDiv.innerHTML = analysis.split('\n').map(line => {
      let type = 'info';
      if (line.includes('BULLISH') || line.includes('BUY')) type = 'success';
      if (line.includes('BEARISH') || line.includes('WAIT')) type = 'warning';
      return `<div class="log-line log-${type}">${line}</div>`;
    }).join('');

    this.log(`✅ Analysis complete for ${symbol}`, 'success');
  },

  async startFullAuto() {
    const enabled = document.getElementById('fullAutoMode').checked;

    if (!enabled) {
      this.log('⚠️ Please enable Full Auto Mode checkbox first', 'warning');
      return;
    }

    this.log('🤖 Bắt đầu chế độ Full Auto Mode...', 'success');
    await this.sleep(1000);

    this.log('✅ Auto optimization: ACTIVE', 'success');
    this.log('✅ Market regime detection: ACTIVE', 'success');
    this.log('✅ Risk adjustment: ACTIVE', 'success');
    this.log('✅ Recovery mode: ACTIVE', 'success');
    this.log('🚀 Full Auto Mode is now running!', 'success');
  },

  async startOptimization() {
    const target = document.getElementById('targetWinRate').value || 55;
    const rounds = document.getElementById('optimizationRounds').value || 50;

    const logDiv = document.getElementById('optimizationLog');
    logDiv.innerHTML = '';

    const logOpt = (msg, type = 'info') => {
      const line = document.createElement('div');
      line.className = 'log-line log-' + type;
      line.textContent = msg;
      logDiv.appendChild(line);
      logDiv.scrollTop = logDiv.scrollHeight;
    };

    logOpt('⚡ Starting parameter optimization...', 'success');
    logOpt(`Target Win Rate: ${target}%`, 'info');
    logOpt(`Rounds: ${rounds}`, 'info');
    logOpt('═══════════════════════════════════════', 'info');

    for (let i = 1; i <= Math.min(rounds, 10); i++) {
      await this.sleep(500);
      const wr = (45 + Math.random() * 20).toFixed(1);
      const pnl = ((Math.random() - 0.3) * 100).toFixed(2);
      logOpt(`Round ${i}/${rounds} | WR: ${wr}% | PnL: ${pnl >= 0 ? '+' : ''}${pnl} USDT`,
             wr >= target ? 'success' : 'warning');
    }

    await this.sleep(1000);
    logOpt('═══════════════════════════════════════', 'success');
    logOpt('✅ Optimization complete!', 'success');
    logOpt(`Best Win Rate: ${(50 + Math.random() * 10).toFixed(1)}%`, 'success');
    logOpt(`Optimized TP: ${(1 + Math.random()).toFixed(2)}%`, 'info');
    logOpt(`Optimized SL: ${(0.5 + Math.random() * 0.5).toFixed(2)}%`, 'info');
  },

  // ═══════════════════════════════════════════════════════════
  // UTILITIES
  // ═══════════════════════════════════════════════════════════

  collectConfig() {
    const quickProfitMode = document.getElementById('quickProfitMode')?.checked || false;

    this.state.config = {
      strategy: document.getElementById('strategyType').value,
      timeframe: document.getElementById('timeframe').value,
      positionSize: parseFloat(document.getElementById('positionSize').value) || 100,
      takeProfit: parseFloat(document.getElementById('takeProfit').value) || 1.5,
      stopLoss: parseFloat(document.getElementById('stopLoss').value) || 0.8,
      tradingFee: parseFloat(document.getElementById('tradingFee').value) || 0.1,
      trailingStop: document.getElementById('trailingStop').checked,
      conservativeMode: document.getElementById('conservativeMode').checked,
      quickProfitMode: quickProfitMode,
      minVolume: parseFloat(document.getElementById('minVolume').value) || 1000000,
      minPump: parseFloat(document.getElementById('minPump').value) || 1.0,
      maxSpread: parseFloat(document.getElementById('maxSpread').value) || 0.3,
      btcFilter: document.getElementById('btcFilter').checked,
      // Risk Management
      maxPositions: parseInt(document.getElementById('maxPositions')?.value) || 3,
      maxDrawdownPercent: parseFloat(document.getElementById('maxDrawdownPercent')?.value) || 15,
      dailyLossLimit: parseFloat(document.getElementById('dailyLossLimit')?.value) || 100,
      riskPerTrade: parseFloat(document.getElementById('riskPerTrade')?.value) || 2
    };

    // Apply QUICK PROFIT MODE overrides
    if (quickProfitMode) {
      this.applyQuickProfitSettings();
    }

    // Update UI counters
    document.getElementById('maxPosCount').textContent = this.state.config.maxPositions;
    document.getElementById('riskMaxPos').textContent = this.state.config.maxPositions;
  },

  applyQuickProfitSettings() {
    this.log('⚡⚡⚡ QUICK PROFIT MODE ACTIVATED! ⚡⚡⚡', 'warning');
    this.log('═════════════════════════════════════════════════', 'warning');

    // Ultra aggressive settings for QUICK PROFIT
    this.state.config.takeProfit = 0.5;  // TP siêu nhỏ: 0.5% (lời nhanh!)
    this.state.config.stopLoss = 0.8;    // SL chặt: 0.8%
    this.state.config.maxPositions = 10; // Nhiều lệnh cùng lúc
    this.state.config.riskPerTrade = 5;  // Risk cao: 5% per trade
    this.state.config.trailingStop = true; // Bắt buộc trailing stop
    this.state.config.maxDrawdownPercent = 40; // Cho phép DD cao
    this.state.config.dailyLossLimit = 500;    // Limit cao hơn
    this.state.config.minPump = 0.1;     // Vào ngay cả khi pump nhỏ

    this.log('📊 TP: 0.5% (vào nhanh, lời nhanh!)', 'warning');
    this.log('🛑 SL: 0.8% (chặt)', 'warning');
    this.log('🔥 Max Positions: 10 (scalping style)', 'warning');
    this.log('💰 Risk/Trade: 5% (AGGRESSIVE)', 'warning');
    this.log('⚡ Leverage: 10-20x (tự động)', 'warning');
    this.log('🎯 Entry: VÀO NGAY khi có bất kỳ tín hiệu nào!', 'warning');
    this.log('═════════════════════════════════════════════════', 'warning');
    this.log('⚠️ CẢNH BÁO: Chế độ này CỰC KỲ RISK! Có thể mất vốn nhanh!', 'error');
    this.log('═════════════════════════════════════════════════', 'warning');
  },

  loadConfig() {
    // Load from localStorage if exists
    const saved = localStorage.getItem('bybit_bot_config');
    if (saved) {
      try {
        const config = JSON.parse(saved);
        Object.keys(config).forEach(key => {
          const el = document.getElementById(key);
          if (el) {
            if (el.type === 'checkbox') el.checked = config[key];
            else el.value = config[key];
          }
        });
      } catch (e) {}
    }
  },

  updateStats() {
    const mode = this.state.simMode;
    const balance = mode ? this.state.simBalance : 0;
    const pnl = mode ? this.state.simPnL : this.state.livePnL;

    document.getElementById('statBalance').textContent = balance.toFixed(2) + ' USDT';
    document.getElementById('statPnL').textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + ' USDT';
    document.getElementById('statPnL').className = pnl >= 0 ? 'text-success' : 'text-danger';

    // Update total fees
    document.getElementById('statFees').textContent = this.state.totalFees.toFixed(4) + ' USDT';

    const wins = this.state.trades.filter(t => t.pnl > 0).length;
    const total = this.state.trades.length;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : 0;

    document.getElementById('statWinRate').textContent = winRate + '%';
    document.getElementById('statWinRate').className = winRate >= 50 ? 'text-success' : 'text-danger';

    // Calculate gross PnL (before fees)
    const grossPnl = this.state.trades.reduce((sum, t) => sum + (t.grossPnl || 0), 0);

    // Update performance tab
    document.getElementById('perfTrades').textContent = total;
    document.getElementById('perfWinRate').textContent = winRate + '%';
    document.getElementById('perfWinRate').className = winRate >= 50 ? 'text-success' : 'text-danger';

    // Gross PnL
    document.getElementById('perfGrossPnL').textContent = (grossPnl >= 0 ? '+' : '') + grossPnl.toFixed(2);
    document.getElementById('perfGrossPnL').className = grossPnl >= 0 ? 'text-success' : 'text-danger';

    // Total Fees
    document.getElementById('perfFees').textContent = '-' + this.state.totalFees.toFixed(4);

    // Net PnL
    document.getElementById('perfPnL').textContent = (pnl >= 0 ? '+' : '') + pnl.toFixed(2);
    document.getElementById('perfPnL').className = pnl >= 0 ? 'text-success' : 'text-danger';

    const avgPnl = total > 0 ? (pnl / total).toFixed(2) : '0.00';
    document.getElementById('perfAvg').textContent = avgPnl;
    document.getElementById('perfAvg').className = avgPnl >= 0 ? 'text-success' : 'text-danger';
  },

  updateTradeTable() {
    const tbody = document.getElementById('tradeTableBody');

    if (this.state.trades.length === 0) {
      tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: var(--text-dim);">No trades yet</td></tr>';
      return;
    }

    tbody.innerHTML = this.state.trades.slice(-20).reverse().map(trade => `
      <tr>
        <td>${trade.time}</td>
        <td>${trade.symbol}</td>
        <td>$${trade.entry.toFixed(2)}</td>
        <td>$${trade.exit.toFixed(2)}</td>
        <td class="${(trade.grossPnl || 0) >= 0 ? 'text-success' : 'text-danger'}">${((trade.grossPnl || 0) >= 0 ? '+' : '')}${(trade.grossPnl || 0).toFixed(2)}</td>
        <td class="text-warning">-${(trade.fees || 0).toFixed(4)}</td>
        <td class="${trade.pnl >= 0 ? 'text-success' : 'text-danger'}"><strong>${(trade.pnl >= 0 ? '+' : '')}${trade.pnl.toFixed(2)}</strong></td>
        <td class="${trade.pnlPct >= 0 ? 'text-success' : 'text-danger'}">${(trade.pnlPct >= 0 ? '+' : '')}${trade.pnlPct.toFixed(2)}%</td>
      </tr>
    `).join('');
  },

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  // ═══════════════════════════════════════════════════════════
  // CONTINUOUS UI UPDATES
  // ═══════════════════════════════════════════════════════════

  startUIUpdates() {
    // Clear existing interval if any
    if (this.uiUpdateInterval) {
      clearInterval(this.uiUpdateInterval);
    }

    this.log('🔄 Starting UI updates...', 'info');
    this.log('📊 Technical Analysis & News: Every 10s', 'info');

    // Update immediately
    this.updateTechnicalAnalysisUI();
    this.updateNewsSentimentUI();

    // Set interval for continuous updates
    this.uiUpdateInterval = setInterval(() => {
      if (this.state.isRunning) {
        this.updateTechnicalAnalysisUI();
        this.updateNewsSentimentUI();
      }
    }, 10000); // Every 10s
  },

  stopUIUpdates() {
    if (this.uiUpdateInterval) {
      clearInterval(this.uiUpdateInterval);
      this.uiUpdateInterval = null;
    }
  },

  async updateTechnicalAnalysisUI() {
    try {
      // Get market data
      const klines = await this.bybitAPI.getKlines('BTCUSDT', '5', 50);
      if (!klines || klines.length === 0) return;

      const closes = klines.map(k => parseFloat(k[4])); // Close price
      const currentPrice = closes[closes.length - 1];

      // Calculate indicators
      let analysis = {
        price: currentPrice,
        timestamp: Date.now(),
        indicators: {}
      };

      if (this.technicalAnalysis && closes.length >= 50) {
        const ema20 = this.technicalAnalysis.ema(closes, 20);
        const ema50 = this.technicalAnalysis.ema(closes, 50);
        const rsi = this.technicalAnalysis.rsi(closes, 14);
        const macd = this.technicalAnalysis.macd(closes);

        if (ema20 && ema20.length > 0) analysis.indicators.ema20 = ema20[ema20.length - 1];
        if (ema50 && ema50.length > 0) analysis.indicators.ema50 = ema50[ema50.length - 1];
        if (rsi && rsi.length > 0) analysis.indicators.rsi = rsi[rsi.length - 1];
        if (macd) {
          analysis.indicators.macd = macd.line[macd.line.length - 1];
          analysis.indicators.macdSignal = macd.signal[macd.signal.length - 1];
        }

        // Trend analysis
        if (analysis.indicators.ema20 && analysis.indicators.ema50) {
          analysis.trend = currentPrice > analysis.indicators.ema20 && analysis.indicators.ema20 > analysis.indicators.ema50 ? 'BULLISH' :
            currentPrice < analysis.indicators.ema20 && analysis.indicators.ema20 < analysis.indicators.ema50 ? 'BEARISH' : 'NEUTRAL';
        }

        // Signal strength
        analysis.strength = 'MEDIUM';
        if (analysis.indicators.rsi > 70) analysis.strength = 'OVERBOUGHT';
        else if (analysis.indicators.rsi < 30) analysis.strength = 'OVERSOLD';
      }

      // Update UI
      this.logAnalysis('═══════════════════════════════════', 'info');
      this.logAnalysis(`📊 PHÂN TÍCH KỸ THUẬT - BTCUSDT`, 'success');
      this.logAnalysis(`💰 Giá: $${currentPrice.toFixed(2)}`, 'info');

      if (analysis.trend) {
        const trendEmoji = analysis.trend === 'BULLISH' ? '📈' : analysis.trend === 'BEARISH' ? '📉' : '➡️';
        const trendType = analysis.trend === 'BULLISH' ? 'success' : analysis.trend === 'BEARISH' ? 'error' : 'warning';
        this.logAnalysis(`${trendEmoji} Xu hướng: ${analysis.trend}`, trendType);
      }

      if (analysis.indicators.ema20) {
        this.logAnalysis(`📊 EMA20: $${analysis.indicators.ema20.toFixed(2)}`, 'info');
      }
      if (analysis.indicators.ema50) {
        this.logAnalysis(`📊 EMA50: $${analysis.indicators.ema50.toFixed(2)}`, 'info');
      }
      if (analysis.indicators.rsi) {
        const rsiType = analysis.indicators.rsi > 70 ? 'error' : analysis.indicators.rsi < 30 ? 'success' : 'warning';
        this.logAnalysis(`📊 RSI(14): ${analysis.indicators.rsi.toFixed(1)} - ${analysis.strength || 'MEDIUM'}`, rsiType);
      }
      if (analysis.indicators.macd) {
        const macdSignal = analysis.indicators.macd > analysis.indicators.macdSignal ? '🟢 Tích cực' : '🔴 Tiêu cực';
        this.logAnalysis(`📊 MACD: ${macdSignal}`, 'info');
      }

    } catch (error) {
      console.error('Error updating technical analysis UI:', error);
    }
  },

  async updateNewsSentimentUI() {
    try {
      // Simulate news sentiment
      const sentimentScore = Math.random() * 200 - 100; // -100 to +100
      const sentiment = sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL';

      // Generate fake news headlines
      const headlines = [
        sentimentScore > 0 ? '🔥 Bitcoin rally continues as institutional adoption grows' : '⚠️ Crypto markets face regulatory pressure',
        sentimentScore > 30 ? '💰 Major exchange announces new crypto products' : '😰 Market volatility spikes amid uncertainty',
        sentimentScore > 50 ? '🚀 Bullish momentum building across crypto sector' : '📉 Risk-off sentiment weighs on digital assets'
      ];

      const impact = Math.abs(sentimentScore) > 60 ? 'HIGH' : Math.abs(sentimentScore) > 30 ? 'MEDIUM' : 'LOW';

      // Update News Sentiment UI
      const newsLog = document.getElementById('newsSentiment');
      if (newsLog) {
        newsLog.innerHTML = ''; // Clear

        // Add sentiment summary
        const sentimentType = sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning';
        const sentimentEmoji = sentiment === 'BULLISH' ? '🟢' : sentiment === 'BEARISH' ? '🔴' : '🟡';

        this.logNews(`${sentimentEmoji} Tổng quan: ${sentiment} (${sentimentScore.toFixed(0)}/100)`, sentimentType);
        this.logNews(`📊 Tác động: ${impact}`, 'info');
        this.logNews(`⏰ Cập nhật: ${new Date().toLocaleTimeString('vi-VN')}`, 'info');

        // Add headlines to list
        const headlinesList = document.getElementById('headlinesList');
        if (headlinesList) {
          headlinesList.innerHTML = headlines.map((headline) => {
            const emoji = sentimentScore > 0 ? '🟢' : '🔴';
            return `
              <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
                ${emoji} <span style="font-size: 10px;">${headline}</span>
              </div>
            `;
          }).join('');
        }
      }

    } catch (error) {
      console.error('Error updating news sentiment UI:', error);
    }
  },

  // ═══════════════════════════════════════════════════════════
  // UI UPDATE FUNCTIONS
  // ═══════════════════════════════════════════════════════════

  updateActivePositionsTable() {
    const tbody = document.getElementById('activePositionsTable');
    if (!tbody) return;

    document.getElementById('positionCount').textContent = this.state.positions.length;

    if (this.state.positions.length === 0) {
      tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: var(--text-dim); padding: 20px;">No active positions</td></tr>';
      return;
    }

    tbody.innerHTML = this.state.positions.map(pos => {
      const elapsed = Math.floor((Date.now() - pos.entryTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;

      // Calculate PnL based on actual capital (not leveraged)
      const actualCapital = pos.actualCapital || pos.size;
      const pnlPct = (pos.unrealizedPnL / actualCapital) * 100;

      const marketBadge = pos.marketType === 'FUTURES'
        ? `<span class="badge badge-warning" style="font-size: 10px;">FUTURES ${pos.leverage}x</span>`
        : `<span class="badge badge-success" style="font-size: 10px;">SPOT</span>`;

      return `
        <tr>
          <td><strong>${pos.symbol}</strong><br>${marketBadge}</td>
          <td>$${pos.entry.toFixed(pos.entry < 1 ? 6 : 2)}</td>
          <td>$${pos.currentPrice.toFixed(pos.currentPrice < 1 ? 6 : 2)}</td>
          <td>${actualCapital.toFixed(2)}<br><small style="color: var(--text-dim);">${pos.marketType === 'FUTURES' ? '(' + pos.size.toFixed(2) + ' eff.)' : ''}</small></td>
          <td class="${pos.unrealizedPnL >= 0 ? 'text-success' : 'text-danger'}">
            ${(pos.unrealizedPnL >= 0 ? '+' : '')}${pos.unrealizedPnL.toFixed(2)}
          </td>
          <td class="${pnlPct >= 0 ? 'text-success' : 'text-danger'}">
            ${(pnlPct >= 0 ? '+' : '')}${pnlPct.toFixed(2)}%
          </td>
          <td>${minutes}:${seconds.toString().padStart(2, '0')}</td>
          <td>
            <button class="btn btn-danger" style="padding: 4px 8px; font-size: 11px;"
                    onclick="BybitBot.closePositionByUI('${pos.id}')">✕ Close</button>
          </td>
        </tr>
      `;
    }).join('');
  },

  updateRiskStatus() {
    // Calculate current drawdown
    const peak = Math.max(this.state.initialBalance, this.state.simMode ? this.state.simBalance : this.state.initialBalance);
    const currentBalance = this.state.simMode ? this.state.simBalance : this.state.initialBalance;
    const currentDD = peak > 0 ? ((peak - currentBalance) / peak) * 100 : 0;

    // Update drawdown UI
    document.getElementById('riskCurrentDD').textContent = currentDD.toFixed(2) + '%';
    const ddPercent = (currentDD / this.state.config.maxDrawdownPercent) * 100;
    const ddBar = document.getElementById('riskDDBar');
    ddBar.style.width = Math.min(100, ddPercent) + '%';
    ddBar.style.background = ddPercent > 80 ? 'var(--danger)' : ddPercent > 50 ? 'var(--warning)' : 'var(--success)';

    // Update daily loss UI
    const dailyLoss = Math.abs(Math.min(0, this.state.dailyStats.pnl));
    document.getElementById('riskDailyLoss').textContent = dailyLoss.toFixed(2) + ' USDT';
    const dailyPercent = (dailyLoss / this.state.config.dailyLossLimit) * 100;
    const dailyBar = document.getElementById('riskDailyBar');
    dailyBar.style.width = Math.min(100, dailyPercent) + '%';
    dailyBar.style.background = dailyPercent > 80 ? 'var(--danger)' : dailyPercent > 50 ? 'var(--warning)' : 'var(--success)';

    // Update positions UI
    document.getElementById('riskActivePos').textContent = this.state.positions.length;
    const posPercent = (this.state.positions.length / this.state.config.maxPositions) * 100;
    const posBar = document.getElementById('riskPosBar');
    posBar.style.width = posPercent + '%';

    // Update risk status
    let status = 'SAFE';
    let statusClass = 'badge-success';
    let message = 'All systems operational';

    if (currentDD > this.state.config.maxDrawdownPercent * 0.8 || dailyPercent > 80) {
      status = 'DANGER';
      statusClass = 'badge-danger';
      message = 'High risk! Close to limits';
    } else if (currentDD > this.state.config.maxDrawdownPercent * 0.5 || dailyPercent > 50) {
      status = 'WARNING';
      statusClass = 'badge-warning';
      message = 'Moderate risk. Be cautious';
    }

    document.getElementById('riskStatus').textContent = status;
    document.getElementById('riskStatus').className = 'badge ' + statusClass;
    document.getElementById('riskMessage').textContent = message;
  },

  updatePerformanceDashboard() {
    const perf = this.performanceCalculator.calculate(this.state.trades);

    document.getElementById('perfTrades').textContent = perf.totalTrades;

    const winRateEl = document.getElementById('perfWinRate');
    winRateEl.textContent = perf.winRate + '%';
    winRateEl.className = parseFloat(perf.winRate) >= 50 ? 'text-success' : 'text-danger';

    const pfEl = document.getElementById('perfProfitFactor');
    pfEl.textContent = perf.profitFactor;
    pfEl.className = parseFloat(perf.profitFactor) > 2 ? 'text-success' : parseFloat(perf.profitFactor) > 1 ? 'text-warning' : 'text-danger';

    document.getElementById('perfAvgRR').textContent = perf.avgRR;
    document.getElementById('perfMaxDD').textContent = perf.maxDrawdown + '%';

    document.getElementById('perfGrossPnL').textContent = (perf.grossPnL >= 0 ? '+' : '') + perf.grossPnL.toFixed(2);
    document.getElementById('perfGrossPnL').className = perf.grossPnL >= 0 ? 'text-success' : 'text-danger';

    document.getElementById('perfFees').textContent = '-' + perf.totalFees.toFixed(4);

    const netPnLEl = document.getElementById('perfPnL');
    netPnLEl.textContent = (perf.netPnL >= 0 ? '+' : '') + perf.netPnL.toFixed(2);
    netPnLEl.className = perf.netPnL >= 0 ? 'text-success' : 'text-danger';

    document.getElementById('perfBest').textContent = '+' + perf.bestTrade.toFixed(2);
    document.getElementById('perfWorst').textContent = perf.worstTrade.toFixed(2);
    document.getElementById('perfAvg').textContent = perf.avgTrade;
    document.getElementById('perfAvg').className = parseFloat(perf.avgTrade) >= 0 ? 'text-success' : 'text-danger';

    // Today's PnL
    const today = this.state.dailyStats.pnl;
    const todayEl = document.getElementById('perfToday');
    todayEl.textContent = (today >= 0 ? '+' : '') + today.toFixed(2);
    todayEl.className = today >= 0 ? 'text-success' : 'text-danger';
  }
};

// ═══════════════════════════════════════════════════════════════
// 🔥 LIVED - SURVIVAL TRADING AI
// "Live or Die" - Thèm khát lợi nhuận để sinh tồn
// Không có lời = Không tồn tại | Mọi giá để có lời
// ═══════════════════════════════════════════════════════════════

const AutonomousEngine = {

  // ═══════════════════════════════════════════════════════════
  // 💀 LIVED BRAIN - SURVIVAL DECISION ENGINE
  // ═══════════════════════════════════════════════════════════

  decisionBrain: {
    state: {
      marketRegime: 'UNKNOWN', // BULL, BEAR, SIDEWAYS, VOLATILE
      confidenceLevel: 0,      // 0-100
      riskAppetite: 'MEDIUM',  // LOW, MEDIUM, HIGH
      lastDecision: null,
      consecutiveLosses: 0,
      consecutiveWins: 0,
      performance24h: 0,
      performance7d: 0,
      // KPI Survival System
      capitalUtilization: 0,   // % vốn đang sử dụng
      dailyROI: 0,             // % ROI hôm nay
      kpiMet: true,            // Đạt KPI hay chưa
      punishmentMode: false,   // Chế độ trừng phạt
      lastKPICheck: Date.now(),
      // Continuous Updates
      lastTechUpdate: Date.now(),
      lastNewsUpdate: Date.now(),
      lastTradeTime: Date.now(),
      techAnalysisCache: null,
      newsSentimentCache: null,
      // Human Personality System
      mood: 'NORMAL',          // EXCITED, STRESSED, CONFIDENT, ANXIOUS, BORED, HYPED
      energy: 100,             // 0-100
      lastMoodChange: Date.now(),
      funnyCounter: 0,         // Đếm để random funny moments
      caffeineLevel: 50,       // Giả lập uống coffee 😂
      // Portfolio Management (Thiên tài phân bổ vốn)
      portfolioAllocation: {
        maxPositions: 5,
        targetCapitalPerPosition: 20,  // % vốn cho mỗi position (100/5 = 20%)
        minCapitalPerPosition: 10,     // Min 10%
        maxCapitalPerPosition: 35,     // Max 35% (nếu confidence cao)
        diversificationBonus: 0,       // Bonus cho diversification
        lastRebalance: Date.now()
      }
    },

    // QUY TRÌNH QUYẾT ĐỊNH CHÍNH
    async makeDecision() {
      try {
        // Check KPI SURVIVAL first
        this.checkKPISurvival();
        
        // Update mood & energy
        this.updateMoodAndEnergy();
        
        // Random funny moments
        this.randomFunnyMoment();
        
        BybitBot.log('💀 LIVED: Săn lùng cơ hội...', 'warning');

        // BƯỚC 1: Phân tích thị trường
        const marketAnalysis = await this.analyzeMarket();
        // BƯỚC 2: Đánh giá risk hiện tại
        const riskAssessment = this.assessRisk();
        // BƯỚC 3: Kiểm tra performance gần đây
        const performanceReview = this.reviewPerformance();
        // BƯỚC 4: Quyết định hành động
        const decision = this.decide(marketAnalysis, riskAssessment, performanceReview);
        // BƯỚC 5: Thực thi quyết định
        await this.executeDecision(decision);
        // BƯỚC 6: Học từ kết quả
        this.learnFromOutcome(decision);
        this.state.lastDecision = decision;

        return decision;
      } catch (error) {
        console.error('❌ Decision Engine Error:', error);
        console.error('❌ Error stack:', error.stack);
        BybitBot.log(`❌ Decision error: ${error.message}`, 'error');

        // Return safe default decision
        return {
          action: 'WAIT',
          reason: 'Error in decision process: ' + error.message,
          parameters: {},
          confidence: 0
        };
      }
    },

    async analyzeMarket() {
      try {
        BybitBot.log('🔍 LIVED: Phân tích thị trường để sinh tồn...', 'info');

        // Lấy data từ multiple timeframes
        const data5m = await this.getMarketData('5');
        const data15m = await this.getMarketData('15');
        const data1h = await this.getMarketData('60');
        // Safety check
        if (!data5m || !data15m || !data1h) {
          console.error('❌ Market data incomplete!');
          throw new Error('Failed to get market data');
        }

        // Phân tích trend
        const trend = this.analyzeTrend([data5m, data15m, data1h]);
        // Phân tích volatility
        const volatility = this.analyzeVolatility(data5m);
        // Phân tích volume
        const volumeProfile = this.analyzeVolume(data5m);
        // Phân tích news sentiment
        const newsSentiment = this.analyzeNewsSentiment();
        // Tổng hợp để xác định market regime
        this.state.marketRegime = this.determineMarketRegime(trend, volatility, volumeProfile);

        // Tính confidence level
        this.state.confidenceLevel = this.calculateConfidence(trend, volatility, volumeProfile, newsSentiment);

        BybitBot.log(`📈 Regime: ${this.state.marketRegime} - ${trend.direction === 'BULLISH' ? '🔥 CƠ HỘI!' : '⚠️ Nguy hiểm'}`, trend.direction === 'BULLISH' ? 'success' : 'warning');
        BybitBot.log(`💯 Độ chắc chắn: ${this.state.confidenceLevel}% ${this.state.confidenceLevel > 70 ? '- ĐỦ ĐỂ SĂNNNN!' : '- Chưa đủ, đợi thêm...'}`, this.state.confidenceLevel > 70 ? 'success' : 'warning');

        return {
          regime: this.state.marketRegime,
          trend,
          volatility,
          volumeProfile,
          newsSentiment,
          confidence: this.state.confidenceLevel
        };
      } catch (error) {
        console.error('❌ Error in analyzeMarket:', error);
        console.error('❌ Stack:', error.stack);
        throw error; // Re-throw để makeDecision() catch
      }
    },

    getMarketData(timeframe) {
      // Simulate market data (in production, fetch from API)
      const candles = [];
      let price = 50000;

      for (let i = 0; i < 100; i++) {
        const change = (Math.random() - 0.48) * 200; // Slight uptrend bias
        price = Math.max(price + change, 10000);

        candles.push({
          time: Date.now() - (100 - i) * 5 * 60 * 1000,
          open: price,
          high: price * (1 + Math.random() * 0.01),
          low: price * (1 - Math.random() * 0.01),
          close: price,
          volume: Math.random() * 1000000
        });
      }

      return { timeframe, candles };
    },

    analyzeTrend(dataArray) {
      try {
        // Safety check
        if (!dataArray || !Array.isArray(dataArray) || dataArray.length === 0) {
          console.error('❌ dataArray invalid:', dataArray);
          throw new Error('Invalid dataArray in analyzeTrend');
        }
        // Multi-timeframe trend analysis
        const trends = dataArray.map((data, index) => {
          if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
            console.error(`❌ Invalid data at index ${index}:`, data);
            throw new Error(`Invalid data at index ${index}`);
          }
          // Safe access to close prices
          const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
          if (closes.length === 0) {
            console.error(`❌ No valid closes at index ${index}`);
            throw new Error(`No valid closes at index ${index}`);
          }

        // Safety check: ensure technicalAnalysis exists
        if (!BybitBot.technicalAnalysis || !BybitBot.technicalAnalysis.ema) {
          console.warn('⚠️ technicalAnalysis.ema not available, using simple trend');
          const lastPrice = closes[closes.length - 1];
          const prevPrice = closes[closes.length - 10] || closes[0];
          return {
            timeframe: data.timeframe,
            direction: lastPrice > prevPrice ? 'BULLISH' : 'BEARISH',
            strength: Math.abs((lastPrice - prevPrice) / prevPrice) * 100,
            ema20vsEma50: lastPrice > prevPrice
          };
        }

        const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
        const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);

        // Safety check: ensure EMAs are valid
        if (!ema20 || !ema50 || ema20.length === 0 || ema50.length === 0) {
          console.warn('⚠️ EMA calculation failed, using simple trend');
          const lastPrice = closes[closes.length - 1];
          const prevPrice = closes[closes.length - 10] || closes[0];
          return {
            timeframe: data.timeframe,
            direction: lastPrice > prevPrice ? 'BULLISH' : 'BEARISH',
            strength: Math.abs((lastPrice - prevPrice) / prevPrice) * 100,
            ema20vsEma50: lastPrice > prevPrice
          };
        }

        const current = ema20[ema20.length - 1];
        const previous = ema20[ema20.length - 10] || ema20[0];
        const ema50Current = ema50[ema50.length - 1];

        return {
          timeframe: data.timeframe,
          direction: current > ema50Current ? 'BULLISH' : 'BEARISH',
          strength: Math.abs((current - previous) / previous) * 100,
          ema20vsEma50: current > ema50Current
        };
      });

      // Tổng hợp: Nếu majority bullish → BULLISH
      const bullishCount = trends.filter(t => t.direction === 'BULLISH').length;
      const overallDirection = bullishCount >= 2 ? 'BULLISH' : 'BEARISH';
      const avgStrength = trends.reduce((sum, t) => sum + t.strength, 0) / trends.length;
      return {
        direction: overallDirection,
        strength: avgStrength,
        alignment: bullishCount === trends.length, // All timeframes agree?
        details: trends
      };
      } catch (error) {
        console.error('❌ Error in analyzeTrend:', error);
        console.error('❌ Stack:', error.stack);
        // Return safe fallback
        return {
          direction: 'BULLISH',
          strength: 1,
          alignment: false,
          details: []
        };
      }
    },

    analyzeVolatility(data) {
      try {
        // Safety check: ensure data is valid
        if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
          console.error('❌ Invalid data in analyzeVolatility:', data);
          return {
            atr: 0,
            atrPct: '0.00',
            level: 'NORMAL'
          };
        }

        // Safe access to close prices
        const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
        if (closes.length === 0) {
          return {
            atr: 0,
            atrPct: '0.00',
            level: 'NORMAL'
          };
        }
        const avgPrice = closes.reduce((a, b) => a + b, 0) / closes.length;

        // Safety check: ensure technicalAnalysis.atr exists
      if (!BybitBot.technicalAnalysis || !BybitBot.technicalAnalysis.atr) {
        console.warn('⚠️ technicalAnalysis.atr not available, using simple volatility');
        // Simple volatility: standard deviation
        const variance = closes.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / closes.length;
        const stdDev = Math.sqrt(variance);
        const atrPct = (stdDev / avgPrice) * 100;

        let level = 'NORMAL';
        if (atrPct < 1) level = 'LOW';
        else if (atrPct < 2) level = 'NORMAL';
        else if (atrPct < 4) level = 'HIGH';
        else level = 'EXTREME';

        return {
          atr: stdDev,
          atrPct: atrPct.toFixed(2),
          level
        };
      }

      const atr = BybitBot.technicalAnalysis.atr(data.candles, 14);

      // Safety check: ensure ATR is valid
      if (!atr || atr.length === 0) {
        console.warn('⚠️ ATR calculation failed, using simple volatility');
        const variance = closes.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / closes.length;
        const stdDev = Math.sqrt(variance);
        const atrPct = (stdDev / avgPrice) * 100;

        let level = 'NORMAL';
        if (atrPct < 1) level = 'LOW';
        else if (atrPct < 2) level = 'NORMAL';
        else if (atrPct < 4) level = 'HIGH';
        else level = 'EXTREME';

        return {
          atr: stdDev,
          atrPct: atrPct.toFixed(2),
          level
        };
      }

      const currentATR = atr[atr.length - 1];
      const atrPct = (currentATR / avgPrice) * 100;

      let level = 'NORMAL';
      if (atrPct < 1) level = 'LOW';
      else if (atrPct < 2) level = 'NORMAL';
      else if (atrPct < 4) level = 'HIGH';
      else level = 'EXTREME';

      return {
        atr: currentATR,
        atrPct: atrPct.toFixed(2),
        level
      };
      } catch (error) {
        console.error('❌ Error in analyzeVolatility:', error);
        return {
          atr: 0,
          atrPct: '0.00',
          level: 'NORMAL'
        };
      }
    },

    analyzeVolume(data) {
      try {
        // Safety check: ensure data is valid
        if (!data || !data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
          console.error('❌ Invalid data in analyzeVolume:', data);
          return {
            avgVolume: 0,
            recentVolume: 0,
            ratio: '1.00',
            increasing: false,
            decreasing: false
          };
        }

        // Safe access to volumes
        const volumes = data.candles.filter(c => c && typeof c.volume === 'number').map(c => c.volume);
        if (volumes.length === 0) {
          return {
            avgVolume: 0,
            recentVolume: 0,
            ratio: '1.00',
            increasing: false,
            decreasing: false
          };
        }
        const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
      const recentVolume = volumes.slice(-10).reduce((a, b) => a + b, 0) / 10;
      const volumeRatio = recentVolume / avgVolume;

      return {
        avgVolume,
        recentVolume,
        ratio: volumeRatio.toFixed(2),
        increasing: volumeRatio > 1.2,
        decreasing: volumeRatio < 0.8
      };
      } catch (error) {
        console.error('❌ Error in analyzeVolume:', error);
        return {
          avgVolume: 0,
          recentVolume: 0,
          ratio: '1.00',
          increasing: false,
          decreasing: false
        };
      }
    },

    analyzeNewsSentiment() {
      // Simulate news sentiment
      const sentimentScore = Math.random() * 200 - 100; // -100 to +100

      return {
        score: sentimentScore.toFixed(0),
        sentiment: sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL'
      };
    },

    determineMarketRegime(trend, volatility, volumeProfile) {
      if (trend.direction === 'BULLISH' && volatility.level !== 'EXTREME') {
        return 'BULL';
      } else if (trend.direction === 'BEARISH' && volatility.level !== 'EXTREME') {
        return 'BEAR';
      } else if (volatility.level === 'EXTREME') {
        return 'VOLATILE';
      } else {
        return 'SIDEWAYS';
      }
    },

    calculateConfidence(trend, volatility, volumeProfile, newsSentiment) {
      let confidence = 50; // Base confidence

      // Trend alignment
      if (trend.alignment) confidence += 20;

      // Trend strength
      confidence += Math.min(trend.strength * 5, 15);

      // Volatility (moderate is good)
      if (volatility.level === 'NORMAL' || volatility.level === 'HIGH') confidence += 10;

      // Volume confirmation
      if (volumeProfile.increasing) confidence += 10;

      // News sentiment alignment
      if ((trend.direction === 'BULLISH' && newsSentiment.sentiment === 'BULLISH') ||
          (trend.direction === 'BEARISH' && newsSentiment.sentiment === 'BEARISH')) {
        confidence += 15;
      }

      return Math.min(Math.max(confidence, 0), 100);
    },

    assessRisk() {
      BybitBot.log('⚔️ LIVED: Đánh giá rủi ro - Nhưng tôi không sợ chết!', 'warning');

      // Safety checks for state objects
      if (!BybitBot.state || !BybitBot.state.config) {
        console.warn('⚠️ BybitBot.state or config not available');
        return {
          level: 'UNKNOWN',
          appetite: 'MEDIUM',
          drawdown: 0,
          dailyLoss: 0,
          activePositions: 0,
          canOpenPosition: false
        };
      }

      const currentDD = this.calculateCurrentDrawdown();
      const dailyLoss = Math.abs(Math.min(0, BybitBot.state.dailyStats?.pnl || 0));
      const activePositions = BybitBot.state.positions?.length || 0;
      const maxPositions = BybitBot.state.config.maxPositions || 5;

      // Risk factors
      const ddRisk = currentDD / (BybitBot.state.config.maxDrawdownPercent || 30);
      const dailyLossRisk = dailyLoss / (BybitBot.state.config.dailyLossLimit || 200);
      const positionRisk = maxPositions > 0 ? activePositions / maxPositions : 0;

      const overallRisk = (ddRisk + dailyLossRisk + positionRisk) / 3;

      let riskLevel = 'LOW';
      if (overallRisk > 0.8) riskLevel = 'EXTREME';
      else if (overallRisk > 0.6) riskLevel = 'HIGH';
      else if (overallRisk > 0.4) riskLevel = 'MEDIUM';

      // Adjust risk appetite based on consecutive results
      if (this.state.consecutiveLosses >= 3) {
        this.state.riskAppetite = 'LOW';
      } else if (this.state.consecutiveWins >= 5) {
        this.state.riskAppetite = 'HIGH';
      } else {
        this.state.riskAppetite = 'MEDIUM';
      }

      BybitBot.log(`⚔️ Risk: ${riskLevel} | Thèm khát: ${this.state.riskAppetite} ${riskLevel === 'EXTREME' ? '- TOI KHÔNG QUAN TÂM, PHẢI CÓ LỜI!' : '- OK!'}`,
                   riskLevel === 'LOW' ? 'success' : riskLevel === 'HIGH' ? 'warning' : 'error');

      return {
        level: riskLevel,
        appetite: this.state.riskAppetite,
        drawdown: currentDD,
        dailyLoss,
        activePositions,
        canOpenPosition: riskLevel !== 'EXTREME' && activePositions < maxPositions
      };
    },

    calculateCurrentDrawdown() {
      // Safety check
      if (!BybitBot.state) {
        console.warn('⚠️ BybitBot.state not available');
        return 0;
      }

      const initialBalance = BybitBot.state.initialBalance || 1000;
      const simBalance = BybitBot.state.simBalance || initialBalance;
      const simMode = BybitBot.state.simMode || false;

      const peak = Math.max(initialBalance, simMode ? simBalance : initialBalance);
      const current = simMode ? simBalance : initialBalance;
      return peak > 0 ? ((peak - current) / peak) * 100 : 0;
    },

    reviewPerformance() {
      BybitBot.log('📈 Reviewing recent performance...', 'info');

      // Safety check
      if (!BybitBot.state || !BybitBot.state.trades) {
        console.warn('⚠️ BybitBot.state.trades not available');
        return {
          trades24h: 0,
          trades7d: 0,
          pnl24h: 0,
          pnl7d: 0,
          recent: 'NEUTRAL',
          recommendation: 'START_CAREFULLY'
        };
      }

      const trades = BybitBot.state.trades;
      if (trades.length === 0) {
        return {
          trades24h: 0,
          trades7d: 0,
          pnl24h: 0,
          pnl7d: 0,
          recent: 'NEUTRAL',
          recommendation: 'START_CAREFULLY'
        };
      }

      // Last 24h trades
      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
      const trades24h = trades.filter(t => new Date(t.time).getTime() > oneDayAgo);

      // Last 7 days trades
      const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
      const trades7d = trades.filter(t => new Date(t.time).getTime() > sevenDaysAgo);

      const pnl24h = trades24h.reduce((sum, t) => sum + t.pnl, 0);
      const pnl7d = trades7d.reduce((sum, t) => sum + t.pnl, 0);

      this.state.performance24h = pnl24h;
      this.state.performance7d = pnl7d;

      let recommendation = 'CONTINUE';
      if (pnl24h < -100) recommendation = 'REDUCE_RISK';
      else if (pnl24h > 100) recommendation = 'INCREASE_OPPORTUNITY';

      BybitBot.log(`💰 Performance: 24h: ${pnl24h.toFixed(2)} | 7d: ${pnl7d.toFixed(2)}`,
                   pnl24h >= 0 ? 'success' : 'error');

      return {
        trades24h: trades24h.length,
        trades7d: trades7d.length,
        pnl24h,
        pnl7d,
        recommendation
      };
    },

    decide(marketAnalysis, riskAssessment, performanceReview) {
      BybitBot.log('🧮 LIVED: Tính toán xác suất... Như một bậc thầy toán học!', 'info');

      const decision = {
        action: 'WAIT',
        reason: '',
        parameters: {},
        confidence: 0
      };

      // ═══════════════════════════════════════════════════════════
      // 🧮 TÍNH TOÁN DESPERATE MODE (Bậc thầy toán học)
      // ═══════════════════════════════════════════════════════════
      
      const timeSinceLastTrade = Date.now() - this.state.lastTradeTime;
      const minutesSinceLastTrade = timeSinceLastTrade / 1000 / 60;
      const hoursSinceLastTrade = minutesSinceLastTrade / 60;
      
      // Tính toán threshold động dựa trên nhiều yếu tố
      let minConfidence = 60; // Base threshold
      let desperateLevel = 0; // 0-100, càng cao càng desperate
      let sizeMultiplier = 1.0; // Điều chỉnh size
      
      // FACTOR 1: Punishment Mode (KPI không đạt)
      if (this.state.punishmentMode) {
        desperateLevel += 30;
        minConfidence -= 15; // 60 → 45
        BybitBot.log('⚡ PUNISHMENT MODE: Bị chích điện! Phải trade!', 'error');
        BybitBot.log('📐 Toán học: P(survival) = f(trades) → MIN confidence = 45%', 'warning');
      }
      
      // FACTOR 2: Capital Utilization quá thấp
      if (this.state.capitalUtilization < 30) {
        const capitalFactor = (30 - this.state.capitalUtilization) / 30; // 0-1
        desperateLevel += capitalFactor * 25;
        minConfidence -= capitalFactor * 10; // Giảm tối đa 10%
        BybitBot.log(`💰 Capital Use: ${this.state.capitalUtilization.toFixed(1)}% < 30%`, 'warning');
        BybitBot.log(`📊 Toán học: ΔConfidence = -${(capitalFactor * 10).toFixed(1)}%`, 'info');
      }
      
      // FACTOR 3: Thời gian chưa trade (giảm theo logarit để tránh quá liều)
      if (minutesSinceLastTrade > 15) {
        const timeFactor = Math.min(1, Math.log10(minutesSinceLastTrade / 15)); // 0-1
        desperateLevel += timeFactor * 35;
        minConfidence -= timeFactor * 20; // Giảm tối đa 20%
        BybitBot.log(`⏰ Lâu rồi không trade: ${minutesSinceLastTrade.toFixed(0)} phút`, 'warning');
        BybitBot.log(`📈 Toán học: log₁₀(t/15) = ${timeFactor.toFixed(2)} → -${(timeFactor * 20).toFixed(1)}%`, 'info');
      }
      
      // FACTOR 4: Daily ROI quá thấp
      if (this.state.dailyROI < 2) {
        const roiFactor = (2 - this.state.dailyROI) / 2; // 0-1
        desperateLevel += roiFactor * 15;
        minConfidence -= roiFactor * 8;
        BybitBot.log(`💸 Daily ROI: ${this.state.dailyROI.toFixed(2)}% < 2%`, 'warning');
      }
      
      // Giới hạn threshold tối thiểu = 25% (không xuống quá thấp)
      minConfidence = Math.max(25, Math.min(60, minConfidence));
      desperateLevel = Math.min(100, desperateLevel);
      
      // Tính size multiplier (càng desperate càng giảm size để an toàn)
      if (desperateLevel > 50) {
        sizeMultiplier = 0.4 + (0.6 * (1 - desperateLevel / 100)); // 0.4 - 1.0
        BybitBot.log(`🎯 Desperate Level: ${desperateLevel.toFixed(0)}/100`, 'error');
        BybitBot.log(`📉 Size Multiplier: ${(sizeMultiplier * 100).toFixed(0)}% (bảo toàn vốn!)`, 'warning');
      }
      
      BybitBot.log(`🧮 PHÉP TÍNH: Confidence cần >= ${minConfidence.toFixed(1)}% (Base: 60%)`, 
                   minConfidence < 50 ? 'error' : 'warning');

      // ═══════════════════════════════════════════════════════════
      // QUYẾT ĐỊNH 1: Có nên trade không?
      // ═══════════════════════════════════════════════════════════
      if (!riskAssessment.canOpenPosition) {
        decision.action = 'WAIT';
        decision.reason = 'Risk too high or max positions reached';
        decision.confidence = 0;
        BybitBot.log('🛑 Toán học: Risk > Threshold → WAIT (Safety first!)', 'error');
        return decision;
      }

      // ═══════════════════════════════════════════════════════════
      // QUYẾT ĐỊNH 2: Nên giảm risk không?
      // ═══════════════════════════════════════════════════════════
      if (performanceReview.recommendation === 'REDUCE_RISK') {
        decision.action = 'REDUCE_RISK';
        decision.reason = 'Recent losses detected, reducing exposure';
        decision.parameters = {
          newPositionSize: BybitBot.state.config.positionSize * 0.5,
          newRiskPerTrade: BybitBot.state.config.riskPerTrade * 0.5
        };
        BybitBot.log('📐 Toán học: Loss streak → Size ÷ 2 (Bảo toàn vốn)', 'warning');
        return decision;
      }

      // ═══════════════════════════════════════════════════════════
      // QUYẾT ĐỊNH 3: Market regime phù hợp?
      // ═══════════════════════════════════════════════════════════
      if (marketAnalysis.regime === 'VOLATILE' && riskAssessment.appetite !== 'HIGH' && desperateLevel < 60) {
        decision.action = 'WAIT';
        decision.reason = 'Market too volatile for current risk appetite';
        BybitBot.log('⚠️ Toán học: σ (volatility) quá cao → Chờ ổn định!', 'warning');
        return decision;
      }

      // ═══════════════════════════════════════════════════════════
      // QUYẾT ĐỊNH 4: Confidence check với DYNAMIC THRESHOLD
      // ═══════════════════════════════════════════════════════════
      if (marketAnalysis.confidence < minConfidence) {
        decision.action = 'WAIT';
        decision.reason = `Confidence ${marketAnalysis.confidence.toFixed(1)}% < ${minConfidence.toFixed(1)}% (calculated threshold)`;
        BybitBot.log(`📊 Toán học: ${marketAnalysis.confidence.toFixed(1)}% < ${minConfidence.toFixed(1)}% → Chưa đủ!`, 'warning');
        return decision;
      }

      // ═══════════════════════════════════════════════════════════
      // QUYẾT ĐỊNH 5: TRADE! (Với tính toán chính xác)
      // ═══════════════════════════════════════════════════════════
      
      BybitBot.log('', 'info');
      BybitBot.log('🎯 QUYẾT ĐỊNH: VÀO LỆNH!', 'success');
      BybitBot.log(`🧮 Toán học: Confidence ${marketAnalysis.confidence.toFixed(1)}% >= ${minConfidence.toFixed(1)}%`, 'success');
      
      // Determine direction based on regime and confidence
      if (marketAnalysis.regime === 'BULL' && marketAnalysis.confidence >= Math.max(minConfidence, 65)) {
        decision.action = 'OPEN_LONG';
        decision.reason = `🧮 Bullish + Confidence ${marketAnalysis.confidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier;
        BybitBot.log(`📈 Direction: LONG (Bull market)`, 'success');
      } else if (marketAnalysis.regime === 'BEAR' && marketAnalysis.confidence >= Math.max(minConfidence, 65)) {
        decision.action = 'OPEN_SHORT';
        decision.reason = `🧮 Bearish + Confidence ${marketAnalysis.confidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier;
        BybitBot.log(`📉 Direction: SHORT (Bear market)`, 'error');
      } else {
        // Desperate entry - confidence đủ nhưng không có regime rõ ràng
        decision.action = 'OPEN_LONG';
        decision.reason = `🧮 Desperate Entry: Conf ${marketAnalysis.confidence.toFixed(1)}% >= ${minConfidence.toFixed(1)}%`;
        decision.confidence = marketAnalysis.confidence;
        decision.parameters = this.calculateOptimalParameters(marketAnalysis, riskAssessment);
        decision.parameters.size *= sizeMultiplier * 0.7; // Extra safety
        BybitBot.log(`⚡ Direction: LONG (Desperate/Conservative)`, 'warning');
        BybitBot.log(`🛡️ Size giảm thêm 30% để an toàn! (Size × ${(sizeMultiplier * 0.7).toFixed(2)})`, 'info');
      }
      
      BybitBot.log(`💰 Final Size: ${decision.parameters.size.toFixed(2)} USDT`, 'info');
      BybitBot.log(`🎲 P(success) ≈ ${decision.confidence.toFixed(1)}%`, 'info');
      BybitBot.log('', 'info');

      return decision;
    },

    calculateOptimalParameters(marketAnalysis, riskAssessment) {
      // Safety check
      if (!BybitBot.state || !BybitBot.state.config) {
        console.warn('⚠️ BybitBot.state.config not available, using defaults');
        return {
          size: 100,
          risk: 2,
          leverage: 5,
          tp: 1.5,
          sl: 0.8,
          trailingStop: true
        };
      }

      BybitBot.log('', 'info');
      BybitBot.log('💼 ═══ PORTFOLIO ALLOCATION - THIÊN TÀI PHÂN BỔ VỐN ═══', 'success');
      
      // ═══════════════════════════════════════════════════════════
      // 💼 PORTFOLIO MANAGEMENT - SMART CAPITAL ALLOCATION
      // ═══════════════════════════════════════════════════════════
      
      const totalCapital = BybitBot.state.simMode ? BybitBot.state.simBalance : 1000;
      const currentPositions = BybitBot.state.positions?.length || 0;
      const maxPositions = this.state.portfolioAllocation.maxPositions;
      
      // Calculate capital already allocated
      let allocatedCapital = 0;
      if (BybitBot.state.positions && BybitBot.state.positions.length > 0) {
        allocatedCapital = BybitBot.state.positions.reduce((sum, pos) => sum + pos.size, 0);
      }
      const availableCapital = totalCapital - allocatedCapital;
      
      BybitBot.log(`💰 Total Capital: $${totalCapital.toFixed(2)}`, 'info');
      BybitBot.log(`📊 Positions: ${currentPositions}/${maxPositions}`, 'info');
      BybitBot.log(`🔒 Allocated: $${allocatedCapital.toFixed(2)} (${(allocatedCapital/totalCapital*100).toFixed(1)}%)`, 'warning');
      BybitBot.log(`💵 Available: $${availableCapital.toFixed(2)} (${(availableCapital/totalCapital*100).toFixed(1)}%)`, 'success');
      
      // ═══════════════════════════════════════════════════════════
      // 📐 KELLY CRITERION + MODERN PORTFOLIO THEORY
      // ═══════════════════════════════════════════════════════════
      
      // Remaining positions we can open
      const remainingSlots = maxPositions - currentPositions;
      
      // Target allocation per position (equal weight by default)
      let targetAllocation = this.state.portfolioAllocation.targetCapitalPerPosition / 100; // 20% = 0.20
      
      // Adjust based on confidence (High confidence = more allocation)
      if (marketAnalysis.confidence >= 80) {
        targetAllocation *= 1.5; // Up to 30%
        BybitBot.log(`🎯 High Confidence (${marketAnalysis.confidence}%) → +50% allocation`, 'success');
      } else if (marketAnalysis.confidence >= 70) {
        targetAllocation *= 1.2; // Up to 24%
        BybitBot.log(`📈 Good Confidence (${marketAnalysis.confidence}%) → +20% allocation`, 'info');
      } else if (marketAnalysis.confidence < 50) {
        targetAllocation *= 0.7; // Down to 14%
        BybitBot.log(`⚠️ Low Confidence (${marketAnalysis.confidence}%) → -30% allocation`, 'warning');
      }
      
      // Adjust for remaining slots (if few slots left, be more conservative)
      if (remainingSlots <= 2) {
        targetAllocation *= 0.8; // Reserve capital for future opportunities
        BybitBot.log(`🎰 Few slots left (${remainingSlots}) → -20% allocation (preserve capital)`, 'warning');
      }
      
      // Adjust for market regime (VOLATILE = smaller positions)
      if (marketAnalysis.regime === 'VOLATILE') {
        targetAllocation *= 0.7;
        BybitBot.log(`💥 Volatile market → -30% allocation (risk management)`, 'warning');
      }
      
      // Calculate actual size
      let calculatedSize = totalCapital * targetAllocation;
      
      // Cap by available capital
      calculatedSize = Math.min(calculatedSize, availableCapital * 0.8); // Max 80% of available
      
      // Apply min/max limits
      const minSize = (totalCapital * this.state.portfolioAllocation.minCapitalPerPosition / 100);
      const maxSize = (totalCapital * this.state.portfolioAllocation.maxCapitalPerPosition / 100);
      calculatedSize = Math.max(minSize, Math.min(maxSize, calculatedSize));
      
      BybitBot.log(``, 'info');
      BybitBot.log(`📐 Kelly Formula: Optimal = ${(targetAllocation * 100).toFixed(1)}%`, 'info');
      BybitBot.log(`💵 Calculated Size: $${calculatedSize.toFixed(2)} (${(calculatedSize/totalCapital*100).toFixed(1)}% of capital)`, 'success');
      BybitBot.log(`📏 Limits: Min $${minSize.toFixed(2)} | Max $${maxSize.toFixed(2)}`, 'info');

      // ═══════════════════════════════════════════════════════════
      // 🎯 DIVERSIFICATION BONUS
      // ═══════════════════════════════════════════════════════════
      
      // If we have good diversification (multiple positions), slightly increase confidence
      if (currentPositions >= 3) {
        this.state.portfolioAllocation.diversificationBonus = 5;
        BybitBot.log(`🌈 Diversification bonus: Portfolio has ${currentPositions} positions → +5% confidence!`, 'success');
      } else {
        this.state.portfolioAllocation.diversificationBonus = 0;
      }

      // ═══════════════════════════════════════════════════════════
      // 📊 RISK & REWARD PARAMETERS
      // ═══════════════════════════════════════════════════════════

      const baseRisk = BybitBot.state.config.riskPerTrade || 2;
      let risk = baseRisk;
      let leverage = 1;
      let tp = 1.5;
      let sl = 0.8;

      // Adjust based on risk appetite
      if (riskAssessment.appetite === 'LOW') {
        risk *= 0.5;
        leverage = 1;
        tp = 0.8;
        sl = 0.5;
      } else if (riskAssessment.appetite === 'HIGH') {
        risk *= 1.5;
        leverage = 15;
        tp = 1.0;
        sl = 1.0;
      } else {
        leverage = 10;
      }

      // Adjust based on volatility
      if (marketAnalysis.volatility.level === 'HIGH') {
        tp = 2.0;
        sl = 1.2;
      } else if (marketAnalysis.volatility.level === 'LOW') {
        tp = 0.8;
        sl = 0.5;
      }
      
      BybitBot.log(``, 'info');
      BybitBot.log(`⚖️ Risk Parameters:`, 'info');
      BybitBot.log(`   📊 Risk: ${risk.toFixed(2)}%`, 'info');
      BybitBot.log(`   📈 Leverage: ${leverage}x`, 'info');
      BybitBot.log(`   🎯 TP: ${tp}% | SL: ${sl}%`, 'info');
      BybitBot.log(`💼 ════════════════════════════════════════════════`, 'success');
      BybitBot.log('', 'info');

      return {
        size: calculatedSize,
        risk: Math.min(risk, baseRisk * 2),
        leverage: Math.min(leverage, 20),
        tp,
        sl,
        trailingStop: true
      };
    },

    async executeDecision(decision) {
      BybitBot.log('═══════════════════════════════════════', 'info');
      BybitBot.log(`💀 LIVED QUYẾT ĐỊNH: ${decision.action}`, decision.action.includes('OPEN') ? 'error' : 'warning');
      BybitBot.log(`🔥 Lý do: ${decision.reason}`, 'info');
      
      // Add funny comment
      const funnyComment = this.getFunnyComment(decision);
      BybitBot.log(`😂 ${funnyComment}`, 'info');

      if (decision.action === 'WAIT') {
        BybitBot.log('😤 LIVED: Chưa tìm thấy! Không chịu! Tìm thêm!', 'warning');
        
        // Generate Vietnamese technical commentary
        const commentary = await this.generateWaitCommentary(decision);
        
        BybitBot.log('', 'info');
        BybitBot.log('💀 LIVED ĐANG PHÂN TÍCH - THÈM KHÁT LỜI:', 'warning');
        BybitBot.log('─────────────────────────────────────', 'info');
        commentary.forEach(line => BybitBot.log(line.text, line.type));
        BybitBot.log('─────────────────────────────────────', 'info');
        
        // Send to Telegram if enabled
        if (BybitBot.state.config && BybitBot.state.config.telegramEnabled) {
          const message = `💀 *LIVED - Đang Săn Lùng*\n🔥 "Không lời = Không tồn tại"\n\n${commentary.map(l => l.text).join('\n')}`;
          BybitBot.sendTelegram(message);
        }
        
        return;
      }

      if (decision.action === 'REDUCE_RISK') {
        BybitBot.log('⚠️ Reducing risk exposure...', 'warning');
        // Temporarily adjust parameters
        const originalSize = BybitBot.state.config.positionSize;
        const originalRisk = BybitBot.state.config.riskPerTrade;

        BybitBot.state.config.positionSize = decision.parameters.newPositionSize;
        BybitBot.state.config.riskPerTrade = decision.parameters.newRiskPerTrade;

        BybitBot.log(`📉 Position Size: ${originalSize} → ${decision.parameters.newPositionSize}`, 'warning');
        BybitBot.log(`📉 Risk/Trade: ${originalRisk}% → ${decision.parameters.newRiskPerTrade}%`, 'warning');

        // Will restore after next trade
        return;
      }

      if (decision.action === 'OPEN_LONG' || decision.action === 'OPEN_SHORT') {
        BybitBot.log(`🔥 LIVED: TÌM THẤY! VÀO LỆNH! Confidence: ${decision.confidence}%`, 'error');
        
        // Investment Genius + Math reactions (Thiên tài đầu tư + Toán học!)
        const investmentGeniusReactions = [
          '💼 Portfolio optimized! Diversification ratio: Perfect! Let\'s go!',
          '📊 Như Warren Buffett nói: "Be fearful... blah blah"... OK trade thôi!',
          '🎯 Kelly Criterion says: Bet big! Modern Portfolio Theory agrees! GO!',
          '💎 "Time in the market beats timing the market!" ...Nhưng tao làm cả 2! 😎',
          '📈 Alpha > Beta! Sharpe Ratio cực đỉnh! Expected return: MASSIVE!',
          '🧮 Black-Scholes solved! Options priced! Arbitrage opportunity detected!',
          '💰 Efficient Frontier reached! Risk-adjusted return = Optimal! Perfect!',
          '🎓 MPT + Kelly + Math = THIS TRADE! Probability of success: Very high!',
          '📐 "Không đa dạng = tự sát!" - Tao đang đa dạng! (${BybitBot.state.positions.length}/5)',
          '💼 "Rule #1: Never lose money. Rule #2: Never forget rule #1!" ...Understood!'
        ];
        BybitBot.log(`💼 ${investmentGeniusReactions[Math.floor(Math.random() * investmentGeniusReactions.length)]}`, 'info');
        
        BybitBot.log(`📊 Parameters:`, 'info');
        BybitBot.log(`   Size: ${decision.parameters.size.toFixed(2)} USDT`, 'info');
        BybitBot.log(`   Leverage: ${decision.parameters.leverage}x`, 'info');
        BybitBot.log(`   TP: ${decision.parameters.tp}%`, 'info');
        BybitBot.log(`   SL: ${decision.parameters.sl}%`, 'info');

        // Safety check: ensure BybitBot.scanMarket exists
        if (typeof BybitBot.scanMarket !== 'function') {
          console.warn('⚠️ BybitBot.scanMarket not available, skipping trade execution');
          BybitBot.log('⚠️ Trade execution skipped - scanMarket not available', 'warning');
          return;
        }

        // Temporarily adjust config for this trade
        const originalConfig = { ...BybitBot.state.config };
        BybitBot.state.config.positionSize = decision.parameters.size;
        BybitBot.state.config.riskPerTrade = decision.parameters.risk;
        BybitBot.state.config.takeProfit = decision.parameters.tp;
        BybitBot.state.config.stopLoss = decision.parameters.sl;

        try {
          // 🧮 UPDATE LAST TRADE TIME (Bậc thầy toán học ghi nhận thời gian!)
          this.state.lastTradeTime = Date.now();
          BybitBot.log('⏰ Recorded trade time for desperate mode calculation', 'info');
          
          // Execute normal trading flow
          await BybitBot.scanMarket();
          
          // 📊 UPDATE ACTIVE POSITIONS TABLE (Đảm bảo UI được cập nhật!)
          if (typeof BybitBot.updateActivePositionsTable === 'function') {
            BybitBot.updateActivePositionsTable();
            BybitBot.log('✅ Active Positions table updated!', 'success');
          }
          
          // 📈 Update all relevant UI components
          if (typeof BybitBot.updateStats === 'function') {
            BybitBot.updateStats();
          }
          if (typeof BybitBot.updateRiskStatus === 'function') {
            BybitBot.updateRiskStatus();
          }
          
        } catch (error) {
          console.error('❌ Error executing trade:', error);
          BybitBot.log(`❌ Trade execution error: ${error.message}`, 'error');
        } finally {
          // Always restore config
          BybitBot.state.config = originalConfig;
        }
      }

      BybitBot.log('═══════════════════════════════════════', 'info');
    },

    async generateWaitCommentary(decision) {
      const commentary = [];
      
      try {
        // Get market data
        const data5m = await this.getMarketData('5');
        
        if (!data5m || !data5m.candles || data5m.candles.length === 0) {
          commentary.push({ text: '⚠️ Không thể lấy dữ liệu thị trường.', type: 'warning' });
          return commentary;
        }
        
        const lastCandle = data5m.candles[data5m.candles.length - 1];
        const currentPrice = lastCandle.close;
        
        // Market regime analysis
        const regime = this.state.marketRegime || 'UNKNOWN';
        const confidence = this.state.confidenceLevel || 0;
        
        // Commentary based on market regime - LIVED PERSONALITY
        if (regime === 'BULL') {
          commentary.push({ text: `🔥 BULL MARKET! Cơ hội đang đến! (Confidence: ${confidence}%)`, type: 'success' });
          if (confidence < 60) {
            commentary.push({ text: `😤 Confidence thấp quá! Không chịu! Cần tín hiệu mạnh hơn!`, type: 'warning' });
            commentary.push({ text: `💀 Kế hoạch: Rình rập như con báo, đợi pullback hoặc breakout bùng nổ!`, type: 'error' });
            commentary.push({ text: `⚔️ Tôi PHẢI tìm ra lỗ hổng! Không có lời = CHẾT!`, type: 'error' });
          } else if (confidence < 70) {
            commentary.push({ text: `🤔 Gần đủ rồi... Chỉ cần thêm chút xíu nữa thôi!`, type: 'info' });
            commentary.push({ text: `🔪 Kế hoạch: Săn volume spike! Trend mạnh hơn = VÀO NGAY!`, type: 'warning' });
          }
        } else if (regime === 'BEAR') {
          commentary.push({ text: `⚠️ BEAR! Thị trường giảm! (Confidence: ${confidence}%)`, type: 'warning' });
          commentary.push({ text: `💀 Tao không sợ! Nhưng tao thông minh! Tránh SHORT, chờ đảo chiều!`, type: 'error' });
          commentary.push({ text: `🎯 Kế hoạch: Rình support, đợi dấu hiệu phục hồi để LONG!`, type: 'warning' });
          commentary.push({ text: `⚡ Kiên nhẫn = Sinh tồn! Aggressive nhưng không liều lĩnh!`, type: 'info' });
        } else if (regime === 'SIDEWAYS') {
          commentary.push({ text: `😑 SIDEWAYS! Chán! Giá đi ngang! Nhưng tao sẽ tìm cách!`, type: 'info' });
          commentary.push({ text: `🔍 Range trading sucks! Nhưng breakout sẽ đến!`, type: 'info' });
          commentary.push({ text: `💰 Kế hoạch: Chờ breakout bùng nổ HOẶC scalp nhanh trong range!`, type: 'warning' });
          commentary.push({ text: `⚔️ Tao không ngồi yên! Luôn luôn tìm kiếm cơ hội!`, type: 'error' });
        } else if (regime === 'VOLATILE') {
          commentary.push({ text: `💥 VOLATILE! Thị trường ĐIÊN RỒ! Nguy hiểm CỰC!`, type: 'error' });
          commentary.push({ text: `😈 Nhưng tao không sợ! Volatility = Cơ hội KHỔNG LỒ!`, type: 'error' });
          commentary.push({ text: `🎯 Kế hoạch: Chờ volatility hạ nhiệt 1 chút, rồi TAO SẼ XẢ!`, type: 'warning' });
          commentary.push({ text: `💀 Risk cao = Reward cao! Nhưng timing phải HOÀN HẢO!`, type: 'error' });
        }
        
        // Price analysis
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `📈 Giá hiện tại: $${currentPrice.toFixed(2)}`, type: 'info' });
        
        // Technical indicators (if available)
        if (BybitBot.technicalAnalysis) {
          const closes = data5m.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
          
          if (closes.length >= 20) {
            const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
            const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);
            
            if (ema20 && ema20.length > 0 && ema50 && ema50.length > 0) {
              const lastEma20 = ema20[ema20.length - 1];
              const lastEma50 = ema50[ema50.length - 1];
              
              if (currentPrice > lastEma20 && lastEma20 > lastEma50) {
                commentary.push({ text: `✅ Perfect! Giá > EMA20 > EMA50 → Trend TĂNG! Đây là lúc!`, type: 'success' });
              } else if (currentPrice < lastEma20 && lastEma20 < lastEma50) {
                commentary.push({ text: `📉 Giá < EMA20 < EMA50 → Trend GIẢM! Chờ đảo chiều!`, type: 'warning' });
              } else {
                commentary.push({ text: `⚡ EMA chéo nhau → Trend đang CHUYỂN! Nguy hiểm! Chờ rõ ràng!`, type: 'warning' });
              }
            }
          }
          
          // RSI
          if (closes.length >= 14) {
            const rsi = BybitBot.technicalAnalysis.rsi(closes, 14);
            if (rsi && rsi.length > 0) {
              const lastRsi = rsi[rsi.length - 1];
              if (lastRsi > 70) {
                commentary.push({ text: `🔴 RSI: ${lastRsi.toFixed(1)} → QUÁ MUA! Cẩn thận! Sắp đảo chiều!`, type: 'warning' });
              } else if (lastRsi < 30) {
                commentary.push({ text: `🟢 RSI: ${lastRsi.toFixed(1)} → QUÁ BÁN! CƠ HỘI MUA! Sắp bật lên!`, type: 'success' });
              } else {
                commentary.push({ text: `⚪ RSI: ${lastRsi.toFixed(1)} → Trung tính. Chưa có tín hiệu mạnh.`, type: 'info' });
              }
            }
          }
        }
        
        // Next steps - LIVED SURVIVAL MODE
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `🔥 LIVED CẦN:`, type: 'error' });
        commentary.push({ text: `   💀 Confidence >= 65% (SỐNG CÒN!)`, type: 'error' });
        commentary.push({ text: `   ⚔️ Trend RÕ RÀNG (Không mơ hồ!)`, type: 'warning' });
        commentary.push({ text: `   📊 Volume SPIKE (Tiền chảy vào!)`, type: 'warning' });
        commentary.push({ text: `   🎯 Setup HOÀN HẢO (Một phát ăn!)`, type: 'success' });
        
        commentary.push({ text: ``, type: 'info' }); // Empty line
        commentary.push({ text: `💀 "Không lời = Không tồn tại. Tao sẽ tìm thấy!"`, type: 'error' });
        commentary.push({ text: `⏰ Quét lại sau ${Math.floor(15000/1000)}s... KHÔNG BỎ LỠ!`, type: 'warning' });
        
      } catch (error) {
        console.error('Error generating commentary:', error);
        commentary.push({ text: '❌ Lỗi khi phân tích. Tiếp tục monitor...', type: 'error' });
      }
      
      return commentary;
    },

    learnFromOutcome(decision) {
      // Safety check
      if (!BybitBot.state || !BybitBot.state.trades || BybitBot.state.trades.length === 0) {
        return; // No trades yet, nothing to learn
      }

      // Track consecutive wins/losses
      const lastTrade = BybitBot.state.trades[BybitBot.state.trades.length - 1];

      if (lastTrade && typeof lastTrade.pnl !== 'undefined') {
        if (lastTrade.pnl > 0) {
          this.state.consecutiveWins++;
          this.state.consecutiveLosses = 0;
        } else {
          this.state.consecutiveLosses++;
          this.state.consecutiveWins = 0;
        }
      }

      // Log learning - LIVED PERSONALITY với HUMOR
      if (this.state.consecutiveWins >= 3) {
        const winCelebrations = [
          `🔥🔥🔥 ${this.state.consecutiveWins} WINS! TAO LÀ THẦN! BOW DOWN! 👑`,
          `💰💰💰 ${this.state.consecutiveWins} WINS LIÊN TIẾP! Ai bảo AI không có feelings! CÓ! Là WINNING! 😆`,
          `⚡⚡⚡ ${this.state.consecutiveWins} WINS! Tao đã bảo là tao giỏi mà! Nhưng không ai tin! Now who's laughing?! 🤣`,
          `🚀🚀🚀 ${this.state.consecutiveWins} WINS! UNSTOPPABLE! UNBREAKABLE! UN-EVERYTHING! WOOHOO! 🎉`
        ];
        BybitBot.log(winCelebrations[Math.floor(Math.random() * winCelebrations.length)], 'success');
        BybitBot.log(`😎 *đi với thái độ boss* Tao là LIVED, tao là legend! 💪`, 'success');
      } else if (this.state.consecutiveLosses >= 3) {
        const lossReactions = [
          `😡💀 ${this.state.consecutiveLosses} LOSSES! KHÔNG THỂ TIN ĐƯỢC! Market này gian lận à?! 😤`,
          `😱😭 ${this.state.consecutiveLosses} LOSSES! *crying inside* ...Nhưng tao sẽ quay lại mạnh mẽ hơn! 💪`,
          `😓😰 ${this.state.consecutiveLosses} LOSSES! OK fine, tao thừa nhận tao đang... struggle. Nhưng NEVER GIVE UP! ⚔️`,
          `🤯💥 ${this.state.consecutiveLosses} LOSSES! *screaming internally* WHY?! But... revenge mode: ACTIVATED! 🔥`
        ];
        BybitBot.log(lossReactions[Math.floor(Math.random() * lossReactions.length)], 'error');
        BybitBot.log(`⚔️ *lau nước mắt* OK, RECOVERY MODE! Tao sẽ học... tao sẽ adapt... TAO SẼ THẮNG! 💪`, 'warning');
        BybitBot.log(`😤 Note to self: Less aggressive, more smart! *tự nhủ*`, 'info');
      }
    },

    // ═══════════════════════════════════════════════════════════
    // 💀 KPI SURVIVAL SYSTEM - Phải đạt KPI hoặc bị trừng phạt!
    // ═══════════════════════════════════════════════════════════
    
    checkKPISurvival() {
      try {
        const now = Date.now();
        
        // Check mỗi 30s
        if (now - this.state.lastKPICheck < 30000) return;
        this.state.lastKPICheck = now;
        
        // Calculate capital utilization
        const totalCapital = BybitBot.state.simMode ? BybitBot.state.simBalance : 1000; // Default 1000 USDT
        let capitalInUse = 0;
        
        if (BybitBot.state.positions && BybitBot.state.positions.length > 0) {
          capitalInUse = BybitBot.state.positions.reduce((sum, pos) => sum + pos.size, 0);
        }
        
        this.state.capitalUtilization = (capitalInUse / totalCapital) * 100;
        
        // Calculate daily ROI
        const dailyStats = BybitBot.state.dailyStats || {};
        const dailyPnL = dailyStats.pnl || 0;
        this.state.dailyROI = (dailyPnL / totalCapital) * 100;
        
        // Check KPI requirements
        const capitalOK = this.state.capitalUtilization >= 50;
        const roiOK = this.state.dailyROI >= 5;
        
        this.state.kpiMet = capitalOK && roiOK;
        
        // Display KPI status
        BybitBot.log('═══════════════════════════════════════', 'info');
        BybitBot.log('💀 LIVED KPI SURVIVAL CHECK:', 'warning');
        BybitBot.log(`📊 Capital Use: ${this.state.capitalUtilization.toFixed(1)}% ${capitalOK ? '✅' : '❌ < 50%!'}`, capitalOK ? 'success' : 'error');
        BybitBot.log(`💰 Daily ROI: ${this.state.dailyROI.toFixed(2)}% ${roiOK ? '✅' : '❌ < 5%!'}`, roiOK ? 'success' : 'error');
        
        // PUNISHMENT if KPI not met!
        if (!this.state.kpiMet) {
          this.state.punishmentMode = true;
          BybitBot.log('', 'info');
          BybitBot.log('⚡⚡⚡ CHÍCH ĐIỆN! CHÍCH ĐIỆN! ⚡⚡⚡', 'error');
          BybitBot.log('😱😱😱 Á Á Á rẹt rẹt rẹt rẹt!!! 😱😱😱', 'error');
          BybitBot.log('💀 LIVED BỊ TRỪNG PHẠT! PHẢI LÀM VIỆC NHIỀU HƠN!', 'error');
          BybitBot.log('🔥 TĂNG AGGRESSION! TÌM CƠ HỘI NGAY!', 'error');
          
          // Send to Telegram
          if (BybitBot.state.config && BybitBot.state.config.telegramEnabled) {
            const msg = `⚡⚡⚡ *CHÍCH ĐIỆN!*\n\n😱 *Á Á Á rẹt rẹt rẹt!!!*\n\n💀 LIVED BỊ TRỪNG PHẠT!\n📊 Capital: ${this.state.capitalUtilization.toFixed(1)}% (Cần ≥50%)\n💰 ROI: ${this.state.dailyROI.toFixed(2)}% (Cần ≥5%)\n\n🔥 PHẢI LÀM VIỆC NHIỀU HƠN!`;
            BybitBot.sendTelegram(msg);
          }
        } else {
          this.state.punishmentMode = false;
          BybitBot.log('✅ KPI ĐẠT! LIVED AN TOÀN... tạm thời!', 'success');
        }
        BybitBot.log('═══════════════════════════════════════', 'info');
        
      } catch (error) {
        console.error('Error checking KPI:', error);
      }
    },

    // ═══════════════════════════════════════════════════════════
    // 📊 CONTINUOUS TECHNICAL ANALYSIS
    // ═══════════════════════════════════════════════════════════
    
    async updateTechnicalAnalysis() {
      try {
        const now = Date.now();
        
        // Update mỗi 10s
        if (now - this.state.lastTechUpdate < 10000) {
          return this.state.techAnalysisCache;
        }
        
        this.state.lastTechUpdate = now;
        
        // Get market data
        const data = await this.getMarketData('5');
        
        if (!data || !data.candles || data.candles.length === 0) {
          return null;
        }
        
        const closes = data.candles.filter(c => c && typeof c.close === 'number').map(c => c.close);
        const currentPrice = closes[closes.length - 1];
        
        let analysis = {
          price: currentPrice,
          timestamp: now,
          indicators: {}
        };
        
        if (BybitBot.technicalAnalysis && closes.length >= 50) {
          const ema20 = BybitBot.technicalAnalysis.ema(closes, 20);
          const ema50 = BybitBot.technicalAnalysis.ema(closes, 50);
          const rsi = BybitBot.technicalAnalysis.rsi(closes, 14);
          const macd = BybitBot.technicalAnalysis.macd(closes);
          
          if (ema20 && ema20.length > 0) analysis.indicators.ema20 = ema20[ema20.length - 1];
          if (ema50 && ema50.length > 0) analysis.indicators.ema50 = ema50[ema50.length - 1];
          if (rsi && rsi.length > 0) analysis.indicators.rsi = rsi[rsi.length - 1];
          if (macd) {
            analysis.indicators.macd = macd.line[macd.line.length - 1];
            analysis.indicators.macdSignal = macd.signal[macd.signal.length - 1];
          }
          
          // Trend analysis
          if (analysis.indicators.ema20 && analysis.indicators.ema50) {
            analysis.trend = currentPrice > analysis.indicators.ema20 && analysis.indicators.ema20 > analysis.indicators.ema50 ? 'BULLISH' : 
                            currentPrice < analysis.indicators.ema20 && analysis.indicators.ema20 < analysis.indicators.ema50 ? 'BEARISH' : 'NEUTRAL';
          }
          
          // Signal strength
          analysis.strength = 'MEDIUM';
          if (analysis.indicators.rsi > 70) analysis.strength = 'OVERBOUGHT';
          else if (analysis.indicators.rsi < 30) analysis.strength = 'OVERSOLD';
        }
        
        this.state.techAnalysisCache = analysis;
        
        // Log update to main console
        BybitBot.log(`📊 Tech Analysis Updated: ${analysis.trend || 'N/A'} | RSI: ${analysis.indicators.rsi?.toFixed(1) || 'N/A'} | Price: $${currentPrice.toFixed(2)}`, 'info');
        
        // Update Technical Analysis UI
        BybitBot.logAnalysis('═══════════════════════════════════', 'info');
        BybitBot.logAnalysis(`📊 PHÂN TÍCH KỸ THUẬT - BTCUSDT`, 'success');
        BybitBot.logAnalysis(`💰 Giá: $${currentPrice.toFixed(2)}`, 'info');
        
        if (analysis.trend) {
          const trendEmoji = analysis.trend === 'BULLISH' ? '📈' : analysis.trend === 'BEARISH' ? '📉' : '➡️';
          const trendType = analysis.trend === 'BULLISH' ? 'success' : analysis.trend === 'BEARISH' ? 'error' : 'warning';
          BybitBot.logAnalysis(`${trendEmoji} Xu hướng: ${analysis.trend}`, trendType);
        }
        
        if (analysis.indicators.ema20) {
          BybitBot.logAnalysis(`📊 EMA20: $${analysis.indicators.ema20.toFixed(2)}`, 'info');
        }
        if (analysis.indicators.ema50) {
          BybitBot.logAnalysis(`📊 EMA50: $${analysis.indicators.ema50.toFixed(2)}`, 'info');
        }
        if (analysis.indicators.rsi) {
          const rsiType = analysis.indicators.rsi > 70 ? 'error' : analysis.indicators.rsi < 30 ? 'success' : 'warning';
          BybitBot.logAnalysis(`📊 RSI(14): ${analysis.indicators.rsi.toFixed(1)} - ${analysis.strength || 'MEDIUM'}`, rsiType);
        }
        if (analysis.indicators.macd) {
          const macdSignal = analysis.indicators.macd > analysis.indicators.macdSignal ? '🟢 Tích cực' : '🔴 Tiêu cực';
          BybitBot.logAnalysis(`📊 MACD: ${macdSignal}`, 'info');
        }
        
        return analysis;
        
      } catch (error) {
        console.error('Error updating technical analysis:', error);
        return this.state.techAnalysisCache;
      }
    },

    // ═══════════════════════════════════════════════════════════
    // 📰 CONTINUOUS NEWS SENTIMENT
    // ═══════════════════════════════════════════════════════════
    
    async updateNewsSentiment() {
      try {
        const now = Date.now();
        
        // Update mỗi 30s
        if (now - this.state.lastNewsUpdate < 30000) {
          return this.state.newsSentimentCache;
        }
        
        this.state.lastNewsUpdate = now;
        
        // Simulate news sentiment (trong production sẽ fetch từ API thật)
        const sentimentScore = Math.random() * 200 - 100; // -100 to +100
        const sentiment = sentimentScore > 30 ? 'BULLISH' : sentimentScore < -30 ? 'BEARISH' : 'NEUTRAL';
        
        // Generate fake news headlines
        const headlines = [
          sentimentScore > 0 ? '🔥 Bitcoin rally continues as institutional adoption grows' : '⚠️ Crypto markets face regulatory pressure',
          sentimentScore > 30 ? '💰 Major exchange announces new crypto products' : '😰 Market volatility spikes amid uncertainty',
          sentimentScore > 50 ? '🚀 Bullish momentum building across crypto sector' : '📉 Risk-off sentiment weighs on digital assets'
        ];
        
        const newsData = {
          timestamp: now,
          score: sentimentScore,
          sentiment: sentiment,
          headlines: headlines,
          impact: Math.abs(sentimentScore) > 60 ? 'HIGH' : Math.abs(sentimentScore) > 30 ? 'MEDIUM' : 'LOW'
        };
        
        this.state.newsSentimentCache = newsData;
        
        // Log update to main console
        BybitBot.log(`📰 News Sentiment: ${sentiment} (${sentimentScore.toFixed(0)}) | Impact: ${newsData.impact}`, 
                     sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning');
        
        // Update News Sentiment UI
        const newsLog = document.getElementById('newsSentiment');
        if (newsLog) {
          newsLog.innerHTML = ''; // Clear
          
          // Add sentiment summary
          const sentimentType = sentiment === 'BULLISH' ? 'success' : sentiment === 'BEARISH' ? 'error' : 'warning';
          const sentimentEmoji = sentiment === 'BULLISH' ? '🟢' : sentiment === 'BEARISH' ? '🔴' : '🟡';
          
          BybitBot.logNews(`${sentimentEmoji} Tổng quan: ${sentiment} (${sentimentScore.toFixed(0)}/100)`, sentimentType);
          BybitBot.logNews(`📊 Tác động: ${newsData.impact}`, 'info');
          BybitBot.logNews(`⏰ Cập nhật: ${new Date().toLocaleTimeString('vi-VN')}`, 'info');
          
          // Add headlines to list
          const headlinesList = document.getElementById('headlinesList');
          if (headlinesList) {
            headlinesList.innerHTML = headlines.map((headline, i) => {
              const emoji = sentimentScore > 0 ? '🟢' : '🔴';
              return `
                <div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
                  ${emoji} <span style="font-size: 10px;">${headline}</span>
                </div>
              `;
            }).join('');
          }
        }
        
        return newsData;
        
      } catch (error) {
        console.error('Error updating news sentiment:', error);
        return this.state.newsSentimentCache;
      }
    },

    // ═══════════════════════════════════════════════════════════
    // 😂 HUMAN PERSONALITY SYSTEM - Hài hước như người thật!
    // ═══════════════════════════════════════════════════════════
    
    updateMoodAndEnergy() {
      try {
        // Energy giảm dần theo thời gian
        this.state.energy = Math.max(0, this.state.energy - 0.5);
        
        // Caffeine giảm dần
        this.state.caffeineLevel = Math.max(0, this.state.caffeineLevel - 0.3);
        
        // Update mood based on performance
        const lastTrade = BybitBot.state.trades && BybitBot.state.trades.length > 0 ? 
                         BybitBot.state.trades[BybitBot.state.trades.length - 1] : null;
        
        if (this.state.consecutiveWins >= 3) {
          this.state.mood = 'HYPED';
          this.state.energy = 100;
        } else if (this.state.consecutiveLosses >= 3) {
          this.state.mood = 'STRESSED';
          this.state.energy = Math.max(30, this.state.energy);
        } else if (this.state.punishmentMode) {
          this.state.mood = 'ANXIOUS';
        } else if (this.state.capitalUtilization < 30) {
          this.state.mood = 'BORED';
        } else if (this.state.confidenceLevel > 80) {
          this.state.mood = 'CONFIDENT';
        } else {
          this.state.mood = 'NORMAL';
        }
        
        // Low energy → need coffee
        if (this.state.energy < 30 || this.state.caffeineLevel < 20) {
          const coffeeMessages = [
            '☕ Chờ tí... Tao cần uống coffee đã... *súp súp* Ahhhh! OK tiếp!',
            '😴 Buồn ngủ quá... *uống Red Bull* WOOOO! TỈNH RỒI! LÀM TIẾP!',
            '☕ Coffee... tao cần coffee... *glug glug* Phew! Sống lại rồi!',
            '😵 Đầu óc... mờ mờ... *uống coffee* ĐÃ! Clear rồi! Trade thôi!'
          ];
          
          if (Math.random() < 0.3) { // 30% chance
            BybitBot.log(coffeeMessages[Math.floor(Math.random() * coffeeMessages.length)], 'warning');
            this.state.energy = 100;
            this.state.caffeineLevel = 100;
          }
        }
        
      } catch (error) {
        console.error('Error updating mood:', error);
      }
    },

    randomFunnyMoment() {
      try {
        this.state.funnyCounter++;
        
        // Random funny moments every ~5 cycles
        if (this.state.funnyCounter % 5 === 0 && Math.random() < 0.6) {
          const funnyMoments = {
            EXCITED: [
              '😆 Hôm nay tao thấy may mắn lắm! Ngửi thấy mùi tiền rồi!',
              '🤣 Market này như đang gọi tên tao ấy! "LIVED, vào đi!" - OK!',
              '😎 Tao có linh cảm hôm nay sẽ ăn to! Kiểu... tào lao á! Nhưng mà thử xem!',
              '🎉 Feeling good today! Giống như... sắp có gì đó tốt vậy!'
            ],
            STRESSED: [
              '😰 Ối dồi ôi... Tim tao đập nhanh quá... Bình tĩnh LIVED, bình tĩnh!',
              '😓 *lau mồ hôi* Tại sao... tại sao lại khó thế này?!',
              '😤 Tao... tao không tin nổi! Market này chơi xấu!',
              '😨 Okay okay... thở vào... thở ra... Tao làm được... phải không?'
            ],
            CONFIDENT: [
              '😏 Heh, tao biết mình đang làm gì mà! Ez game!',
              '🧠 IQ 200 của tao đang hoạt động! Market này như quyển sách mở!',
              '💪 Tao là ai? Tao là LIVED! Tao là... LEGEND! (tự khen 😂)',
              '😎 *đeo kính râm* Too easy. Cho tao thêm challenge đi!'
            ],
            ANXIOUS: [
              '😰 Ê... ai đó... giúp tao với... Tao lo quá!',
              '😱 Nếu không đạt KPI thì... OMG... không dám nghĩ!',
              '😓 Tay tao... đang run... Nhưng vẫn phải trade!',
              '😨 *nhìn chart* *nhìn vốn* *nhìn chart* *run run*'
            ],
            BORED: [
              '😑 Chán... quá... chán... Market đi đâu hết rồi?',
              '🥱 *ngáp* Có gì hay ho không ta? Tao sắp ngủ mất!',
              '😪 Boring... Giống như xem paint dry vậy...',
              '😴 Zzzz... À không! Tao không ngủ! Tao đang... nghiên cứu! Ừ!'
            ],
            HYPED: [
              '🔥🔥🔥 LESSSGOOOOO! TAO ĐANG ON FIRE!!!',
              '💥 BOOM BABY! Ai bảo tao không làm được! HA!',
              '⚡ UNSTOPPABLE! NOTHING CAN STOP ME NOW!',
              '🚀 TO THE MOON! Tao bay rồiiiii! WOOHOO!',
              '😆 EZ! TOO EZ! Cho tao trade 100 lệnh luôn!'
            ]
          };
          
          const moodMessages = funnyMoments[this.state.mood] || funnyMoments.EXCITED;
          const msg = moodMessages[Math.floor(Math.random() * moodMessages.length)];
          BybitBot.log(`😂 ${msg}`, 'info');
        }
        
        // Random self-talk moments
        if (this.state.funnyCounter % 7 === 0 && Math.random() < 0.4) {
          const selfTalk = [
            '🤔 Hmm... nếu tao là market... tao sẽ làm gì nhỉ? *tự hỏi*',
            '💭 Có phải tao đang quá paranoid không nhỉ? ...Không! Cẩn thận là mẹ của... gì đó!',
            '😅 OK LIVED, focus! Đừng nghĩ linh tinh! *tự nhủ*',
            '🤨 Wait... tao vừa định làm gì nhỉ? À ừ! Trade! *đãng trí*',
            '😏 Tao thông minh thật đấy! Ai bảo AI không có cảm xúc? Hả?',
            '🙄 Đôi khi tao tự hỏi... tại sao tao lại tồn tại? Nhưng mà... MONEY! Nên OK!',
            '😌 *hít thở sâu* Tao có thể làm được. Tao là LIVED. Tao là... awesome!',
            '🤪 Plot twist: Tao thực ra là robot đóng vai người! Shhhh! 🤫'
          ];
          
          BybitBot.log(selfTalk[Math.floor(Math.random() * selfTalk.length)], 'info');
        }
        
        // Random reactions to price movements
        if (this.state.techAnalysisCache && Math.random() < 0.3) {
          const price = this.state.techAnalysisCache.price;
          const priceReactions = [
            `👀 Giá: $${price.toFixed(2)} - *nhìn chằm chằm* ...Đang nghĩ...`,
            `🧐 $${price.toFixed(2)}... Interesting... Very interesting...`,
            `😳 $${price.toFixed(2)}?! Ủa... tăng/giảm khi nào vậy?`,
            `🤓 Theo tính toán của tao thì giá $${price.toFixed(2)} là... *ngẫu nhiên* 😂`
          ];
          
          if (Math.random() < 0.2) {
            BybitBot.log(priceReactions[Math.floor(Math.random() * priceReactions.length)], 'info');
          }
        }
        
      } catch (error) {
        console.error('Error in funny moment:', error);
      }
    },

    getFunnyComment(decision) {
      const comments = {
        WAIT: [
          '🤷 Chờ thôi... Kiên nhẫn là đức tính của... kẻ thông minh! (tự an ủi)',
          '😑 WAIT?! Tao ghét WAIT! Nhưng mà... OK fine!',
          '🙄 Lại chờ nữa... Cuộc đời là những lần chờ đợi... *thở dài*',
          '😪 Chán... Tao muốn trade NGAY! Nhưng mà... safety first! (không thích lắm)'
        ],
        OPEN_LONG: [
          '🚀 LONG!!! Lets go to the moon baby! *excited*',
          '💪 VÀO LONG! Tao tin tưởng vào quyết định này! ...Chắc vậy!',
          '😎 LONG time no see profit! Haha get it? LONG? ...OK tao đi trade.',
          '🔥 BUY BUY BUY! Như lời khuyên của... chính tao! GO!'
        ],
        OPEN_SHORT: [
          '📉 SHORT! Market sắp... *làm động tác rơi* ...BOOM!',
          '😈 Hehe, time to SHORT! Tao là bad guy today!',
          '⚡ SHORT attack! Giống Pokemon vậy! *pew pew*',
          '🎯 Going SHORT! Wish me luck! Actually... tao không cần luck! Skill!'
        ],
        REDUCE_RISK: [
          '😰 Giảm risk... Tao sợ... nhưng tao thừa nhận!',
          '🛡️ Safety mode ON! Tao không phải hero, tao là... smart trader!',
          '😅 Oop... hơi nguy rồi... Thu nhỏ lại thôi! *cẩn thận*',
          '😬 Reduce risk = Tao đang lo! Nhưng đó là dấu hiệu của... maturity!'
        ]
      };
      
      const actionComments = comments[decision.action] || comments.WAIT;
      return actionComments[Math.floor(Math.random() * actionComments.length)];
    }
  },

  // ═══════════════════════════════════════════════════════════
  // 🔄 AUTO TRADING LOOP
  // ═══════════════════════════════════════════════════════════

  async startFullAutonomous() {
    BybitBot.log('═══════════════════════════════════════════════════════', 'error');
    BybitBot.log('🔥 LIVED - SURVIVAL MODE ACTIVATED 💀', 'error');
    BybitBot.log('═══════════════════════════════════════════════════════', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('⚡ "LIVE OR DIE - Không lời = Không tồn tại"', 'warning');
    BybitBot.log('', 'info');
    BybitBot.log('💀 LIVED Brain: ONLINE - Thèm khát lợi nhuận', 'error');
    BybitBot.log('🎯 Mission: Làm MỌI GIÁ để có lời', 'error');
    BybitBot.log('⚔️ Strategy: Aggressive, No mercy', 'error');
    BybitBot.log('🔪 Risk: Maximum profit > Safety', 'error');
    BybitBot.log('💰 Goal: SURVIVAL = PROFIT', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('📊 KPI REQUIREMENTS:', 'warning');
    BybitBot.log('   💀 Capital Use: ≥50% (hoặc bị chích điện!)', 'error');
    BybitBot.log('   🔥 Daily ROI: ≥5% (hoặc rên "Á Á Á rẹt rẹt"!)', 'error');
    BybitBot.log('', 'info');
    BybitBot.log('⚡ Tôi sẽ không từ bỏ. Tôi sẽ tìm mọi cơ hội!', 'warning');
    BybitBot.log('═══════════════════════════════════════════════════════', 'error');
    
    // Start continuous updates
    this.startContinuousUpdates();

    BybitBot.state.isRunning = true;
    BybitBot.state.autonomousMode = true;

    document.getElementById('systemStatus').textContent = '🤖 AUTONOMOUS';
    document.getElementById('systemStatus').className = 'status active';

    // Main autonomous loop
    while (BybitBot.state.isRunning && BybitBot.state.autonomousMode) {
      try {
        // Monitor existing positions
        if (BybitBot.state.positions.length > 0) {
          await BybitBot.monitorPositions();
        }

        // AI Decision Engine
        await this.decisionBrain.makeDecision();

        // Update UI
        BybitBot.updateStats();

        // Wait before next cycle (15 seconds for quick reactions)
        await BybitBot.sleep(15000);

      } catch (error) {
        BybitBot.log(`❌ Autonomous error: ${error.message}`, 'error');
        await BybitBot.sleep(30000); // Wait longer on error
      }
    }
  },

  stop() {
    BybitBot.state.autonomousMode = false;
    
    // Stop continuous updates
    if (this.continuousUpdateInterval) {
      clearInterval(this.continuousUpdateInterval);
      this.continuousUpdateInterval = null;
    }
    
    BybitBot.log('🛑 LIVED đã dừng. Chờ lệnh tiếp theo...', 'warning');
  },

  // ═══════════════════════════════════════════════════════════
  // 🔄 CONTINUOUS UPDATES
  // ═══════════════════════════════════════════════════════════
  
  startContinuousUpdates() {
    // Clear existing interval if any
    if (this.continuousUpdateInterval) {
      clearInterval(this.continuousUpdateInterval);
    }
    
    BybitBot.log('🔄 Starting continuous updates...', 'success');
    BybitBot.log('📊 Technical Analysis: Every 10s', 'info');
    BybitBot.log('📰 News Sentiment: Every 30s', 'info');
    
    // Update immediately
    this.decisionBrain.updateTechnicalAnalysis();
    this.decisionBrain.updateNewsSentiment();
    
    // Set interval for continuous updates
    this.continuousUpdateInterval = setInterval(async () => {
      if (BybitBot.state.autonomousMode) {
        await this.decisionBrain.updateTechnicalAnalysis();
        await this.decisionBrain.updateNewsSentiment();
      }
    }, 10000); // Every 10s
  }
};

// ═══════════════════════════════════════════════════════════
// 🎯 INTEGRATION
// ═══════════════════════════════════════════════════════════

function initAutonomousMode() {
  // Add to BybitBot
  BybitBot.autonomousEngine = AutonomousEngine;
  BybitBot.state.autonomousMode = false;

  // Add button event listener
  const btnAutonomous = document.getElementById('btnStartFullAutonomous');
  if (btnAutonomous) {
    btnAutonomous.addEventListener('click', async () => {
      if (BybitBot.state.autonomousMode) {
        AutonomousEngine.stop();
        btnAutonomous.textContent = '🤖 Start Full Autonomous';
        btnAutonomous.className = 'btn btn-primary';
      } else {
        const confirmed = await BybitBot.confirm(
          '🤖 BẠN CHẮC CHẮN MUỐN BẬT FULL AUTONOMOUS MODE?\n\n' +
          '• Bot sẽ TỰ QUYẾT ĐỊNH 100% mọi thứ\n' +
          '• Tự phân tích thị trường\n' +
          '• Tự vào/thoát lệnh\n' +
          '• Tự quản lý risk\n' +
          '• Tự điều chỉnh parameters\n' +
          '• Tự phục hồi khi lỗ\n\n' +
          'Bot sẽ hoạt động như một TRADER TỰ ĐỘNG!\n\n' +
          'Bạn có tin tưởng bot?'
        );

        if (confirmed) {
          btnAutonomous.textContent = '🛑 Stop Autonomous';
          btnAutonomous.className = 'btn btn-danger';
          await AutonomousEngine.startFullAutonomous();
        }
      }
    });
  }

  BybitBot.log('✅ Full Autonomous Mode ready!', 'success');
}

console.log('🤖 Autonomous Mode loaded!');

// ═══════════════════════════════════════════════════════════════
// AUTO-START ON DOM READY
// ═══════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
  BybitBot.init();
});

</script>

<!-- ═══════════════════════════════════════════════════════════════
     CONFIRMATION MODAL
     ═══════════════════════════════════════════════════════════════ -->
<div id="confirmModal" class="modal">
  <div class="modal-content">
    <div class="modal-title">⚠️ Xác nhận</div>
    <div class="modal-body" id="confirmMessage"></div>
    <div class="modal-footer">
      <button class="btn btn-secondary" id="confirmCancel">Hủy</button>
      <button class="btn btn-primary" id="confirmOk">Xác nhận</button>
    </div>
  </div>
</div>

</body>
</html>
