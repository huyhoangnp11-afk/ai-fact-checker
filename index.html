<!DOCTYPE html>
<html lang="vi" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Trading Bot Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #d1d5db; }
        .card { background-color: #1f2937; border: 1px solid #374151; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.625rem 1.25rem; border-radius: 0.5rem; font-weight: 500; transition: background-color 0.2s, opacity 0.2s; cursor: pointer; opacity: 1; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .input-field, textarea { width: 100%; background-color: #374151; border: 1px solid #4b5563; color: #d1d5db; border-radius: 0.5rem; padding: 0.625rem; transition: border-color 0.2s, box-shadow 0.2s; }
        .input-field:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px #1e40af; }
        .status-badge { padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; display: inline-block; }
        .status-running { background-color: #10b981; color: #064e3b; }
        .status-stopped { background-color: #f87171; color: #991b1b; }
        .status-cooldown { background-color: #f59e0b; color: #92400e; }
        .log-container { height: 250px; background-color: #111827; border: 1px solid #374151; border-radius: 0.5rem; padding: 0.75rem; overflow-y: auto; font-family: monospace; font-size: 0.875rem; }
        #chartContainer { height: 350px; }
        #currentPrice.price-up { color: #10b981; transition: color 0.2s ease; }
        #currentPrice.price-down { color: #ef4444; transition: color 0.2s ease; }
        .radio-label { display: flex; align-items: center; padding: 0.5rem 1rem; border: 1px solid #4b5563; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; }
        .radio-label:hover { background-color: #374151; }
        input[type="radio"]:checked + .radio-label { border-color: #3b82f6; background-color: #1f2937; box-shadow: 0 0 0 2px #1e40af; }
        input[type="radio"] { opacity: 0; width: 0; height: 0; }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-white">Bảng điều khiển Bot Giao dịch Bybit (Advanced Order Flow)</h1>
            <p class="text-gray-400 mt-1">Sử dụng phân tích dòng lệnh nâng cao để tìm kiếm các cơ hội giao dịch có xác suất cao.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Cột cài đặt -->
            <div class="lg:col-span-1 space-y-6">
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Cài đặt API</h2>
                    <div class="space-y-4">
                        <div><label for="apiKey" class="block text-sm font-medium mb-1">API Key</label><input type="password" id="apiKey" class="input-field" placeholder="Nhập API Key để giao dịch"></div>
                        <div><label for="apiSecret" class="block text-sm font-medium mb-1">API Secret</label><input type="password" id="apiSecret" class="input-field" placeholder="Nhập API Secret để giao dịch"></div>
                        <button id="saveApi" class="btn btn-primary w-full pt-2">Lưu API & Lấy số dư</button>
                    </div>
                </div>
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Cấu hình Bot</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2">Chế độ Giao dịch</label>
                            <div class="grid grid-cols-3 gap-2">
                                <div>
                                    <input type="radio" name="tradeMode" id="modeSafe" value="Safe" checked>
                                    <label for="modeSafe" class="radio-label justify-center">An toàn</label>
                                </div>
                                <div>
                                    <input type="radio" name="tradeMode" id="modeBalanced" value="Balanced">
                                    <label for="modeBalanced" class="radio-label justify-center">Cân bằng</label>
                                </div>
                                <div>
                                    <input type="radio" name="tradeMode" id="modeAggressive" value="Aggressive">
                                    <label for="modeAggressive" class="radio-label justify-center">Táo bạo</label>
                                </div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                           <div><label for="orderValue" class="block text-sm font-medium mb-1">Giá trị lệnh ($)</label><input type="number" id="orderValue" class="input-field" step="1" value="8"></div>
                           <div><label for="timeStop" class="block text-sm font-medium mb-1">Time Stop (giây)</label><input type="number" id="timeStop" class="input-field" value="120"><p class="text-xs text-gray-400 mt-1">Sẽ được điều chỉnh tự động theo chế độ.</p></div>
                        </div>
                         <div class="grid grid-cols-2 gap-4 pt-2">
                            <button id="startBot" class="btn btn-primary" disabled>Bắt đầu Giao dịch</button>
                            <button id="stopBot" class="btn btn-danger">Dừng Giao dịch</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cột thông tin và nhật ký -->
            <div class="lg:col-span-2 space-y-6">
                 <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Trạng thái Hệ thống</h2>
                    <div class="grid grid-cols-2 lg:grid-cols-3 gap-4">
                        <div><span class="text-gray-400">Trạng thái Bot:</span> <span id="botStatus" class="status-badge status-stopped ml-2">Đang Quét...</span></div>
                        <div><span class="text-gray-400">Số dư USDT:</span> <span id="usdtBalance" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Cặp tiềm năng:</span> <span id="topCoin" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Pump Score:</span> <span id="pumpScore" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Advanced Score:</span> <span id="advancedScore" class="text-white font-semibold ml-2">--</span></div>
                        <div><span class="text-gray-400">Giá theo dõi:</span> <span id="currentPrice" class="text-white font-semibold ml-2 text-lg">--</span></div>
                        <div class="lg:col-span-3"><span class="text-gray-400">Vị thế hiện tại:</span> <span id="currentPosition" class="text-white font-semibold ml-2">Không có</span></div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4" id="chartTitle">Biểu đồ (BTCUSDT)</h2>
                     <div id="chartContainer"></div>
                </div>
                <div class="card">
                    <h2 class="text-xl font-semibold text-white mb-4">Nhật ký hoạt động</h2>
                    <div id="logContainer" class="log-container">
                        <p class="text-gray-500">Chờ bot khởi động...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const elements = {
                apiKeyInput: document.getElementById('apiKey'), apiSecretInput: document.getElementById('apiSecret'), saveApiButton: document.getElementById('saveApi'),
                startBotButton: document.getElementById('startBot'), stopBotButton: document.getElementById('stopBot'), orderValueInput: document.getElementById('orderValue'),
                timeStopInput: document.getElementById('timeStop'), botStatus: document.getElementById('botStatus'), usdtBalance: document.getElementById('usdtBalance'),
                topCoin: document.getElementById('topCoin'), pumpScore: document.getElementById('pumpScore'), advancedScore: document.getElementById('advancedScore'),
                currentPosition: document.getElementById('currentPosition'), logContainer: document.getElementById('logContainer'), currentPriceEl: document.getElementById('currentPrice'),
                tradeModeRadios: document.querySelectorAll('input[name="tradeMode"]'),
                chartContainer: document.getElementById('chartContainer'),
                chartTitle: document.getElementById('chartTitle'),
            };

            // --- State Variables ---
            let state = {
                scanInterval: null, tradeInterval: null, apiKey: '', apiSecret: '', ws: null, pingInterval: null, lastPrice: 0, isTradingRunning: false,
                instrumentInfo: new Map(), cooldownUntil: 0, activeSymbolWs: null, position: { hasPosition: false, symbol: null, entryTime: 0, coin: null },
                risk: { consecutiveLosses: 0 }, realtimeData: new Map(), timeOffset: 0, isTimeSynced: false, mode: 'Safe',
                latestTopCoin: null,
                chart: null, candlestickSeries: null, currentCandle: null
            };

            const ADAPTIVE_MODES = {
                Safe:       { minPumpScore: 70, tpMultiplier: 1.0, timeStop: 120, maxSpread: 0.06, minDepthMultiplier: 10, atrRange: [0.20, 0.80] },
                Balanced:   { minPumpScore: 65, tpMultiplier: 1.2, timeStop: 90,  maxSpread: 0.08, minDepthMultiplier: 7,  atrRange: [0.15, 1.00] },
                Aggressive: { minPumpScore: 60, tpMultiplier: 1.4, timeStop: 75,  maxSpread: 0.10, minDepthMultiplier: 5,  atrRange: [0.10, 1.20] }
            };

            // --- Chart Logic ---
            function initChart() {
                state.chart = LightweightCharts.createChart(elements.chartContainer, {
                    width: elements.chartContainer.clientWidth,
                    height: elements.chartContainer.clientHeight,
                    layout: { backgroundColor: '#1f2937', textColor: '#d1d5db' },
                    grid: { vertLines: { color: '#374151' }, horzLines: { color: '#374151' } },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                    rightPriceScale: { borderColor: '#4b5563' },
                    timeScale: { borderColor: '#4b5563' }
                });
                state.candlestickSeries = state.chart.addCandlestickSeries({
                    upColor: '#10b981', downColor: '#ef4444',
                    borderDownColor: '#ef4444', borderUpColor: '#10b981',
                    wickDownColor: '#ef4444', wickUpColor: '#10b981',
                });
            }

            async function updateChart(symbol) {
                if (!state.chart || !state.candlestickSeries) return;
                elements.chartTitle.textContent = `Biểu đồ (${symbol})`;
                
                const klineData = await publicBybitRequest('/v5/market/kline', { category: 'spot', symbol, interval: '1', limit: 200 });
                if (klineData?.list) {
                    const formattedData = klineData.list.map(d => ({
                        time: parseInt(d[0]) / 1000,
                        open: parseFloat(d[1]),
                        high: parseFloat(d[2]),
                        low: parseFloat(d[3]),
                        close: parseFloat(d[4]),
                    })).reverse();
                    
                    state.candlestickSeries.setData(formattedData);
                    if (formattedData.length > 0) {
                       state.currentCandle = formattedData[formattedData.length - 1];
                    }
                    state.chart.timeScale().fitContent();
                }
            }

            // --- WebSocket for Real-time Data ---
            function connectWebSocket(symbol) {
                if (state.activeSymbolWs === symbol) return;
                if (state.ws) { state.ws.close(); }
                if (state.pingInterval) { clearInterval(state.pingInterval); }
                
                state.activeSymbolWs = symbol;
                elements.currentPriceEl.textContent = '--';
                if (!state.realtimeData.has(symbol)) {
                    state.realtimeData.set(symbol, { orderbook: null, trades: [], cvd: 0, micropriceTilts: [], iceberg: { price: 0, displayed: 0, traded: 0 } });
                }
                
                state.ws = new WebSocket('wss://stream.bybit.com/v5/public/spot');
                state.ws.onopen = () => {
                    addLog(`Đã kết nối WebSocket cho ${symbol}.`);
                    state.ws.send(JSON.stringify({ op: 'subscribe', args: [`publicTrade.${symbol}`, `orderbook.50.${symbol}`] }));
                    state.pingInterval = setInterval(() => { if (state.ws.readyState === WebSocket.OPEN) state.ws.send(JSON.stringify({ op: 'ping' })); }, 28000);
                };
                state.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const symbolData = state.realtimeData.get(symbol);
                    if (!symbolData) return;

                    if (data.topic?.startsWith('publicTrade')) {
                        const trade = data.data[0];
                        const newPrice = parseFloat(trade.p);
                        const tradeTime = parseInt(trade.T) / 1000;
                        
                        elements.currentPriceEl.classList.toggle('price-up', newPrice > state.lastPrice);
                        elements.currentPriceEl.classList.toggle('price-down', newPrice < state.lastPrice);
                        elements.currentPriceEl.textContent = newPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 });
                        state.lastPrice = newPrice;
                        
                        // Update Chart Candle
                        if (state.currentCandle && state.candlestickSeries) {
                           const candleTime = state.currentCandle.time;
                           const nextCandleTime = candleTime + 60; // 1-minute candles
                           if(tradeTime >= nextCandleTime) {
                               state.currentCandle = { time: nextCandleTime, open: newPrice, high: newPrice, low: newPrice, close: newPrice };
                           } else {
                               state.currentCandle.high = Math.max(state.currentCandle.high, newPrice);
                               state.currentCandle.low = Math.min(state.currentCandle.low, newPrice);
                               state.currentCandle.close = newPrice;
                           }
                           state.candlestickSeries.update(state.currentCandle);
                        }

                        const volume = parseFloat(trade.v);
                        if (trade.S === 'Buy') symbolData.cvd += volume; else symbolData.cvd -= volume;
                        if(symbolData.orderbook?.b.length > 0 && newPrice === parseFloat(symbolData.orderbook.b[0][0])) {
                            if(symbolData.iceberg.price === newPrice) { symbolData.iceberg.traded += volume; } 
                            else { symbolData.iceberg.price = newPrice; symbolData.iceberg.displayed = parseFloat(symbolData.orderbook.b[0][1]); symbolData.iceberg.traded = volume; }
                        }
                    } else if (data.topic?.startsWith('orderbook')) {
                        symbolData.orderbook = data.data;
                        if (symbolData.orderbook.b.length > 0 && symbolData.orderbook.a.length > 0) {
                            const [pBid, qBid] = [parseFloat(symbolData.orderbook.b[0][0]), parseFloat(symbolData.orderbook.b[0][1])];
                            const [pAsk, qAsk] = [parseFloat(symbolData.orderbook.a[0][0]), parseFloat(symbolData.orderbook.a[0][1])];
                            if (qBid + qAsk > 0) {
                                const microprice = (pAsk * qBid + pBid * qAsk) / (qBid + qAsk);
                                const midprice = (pAsk + pBid) / 2;
                                const tilt = (microprice - midprice) / midprice * 100;
                                symbolData.micropriceTilts.push(tilt);
                                if (symbolData.micropriceTilts.length > 5) symbolData.micropriceTilts.shift();
                            }
                        }
                    }
                };
                state.ws.onclose = () => { addLog('Kết nối WebSocket đã đóng.', 'info'); if(state.pingInterval) clearInterval(state.pingInterval); };
                state.ws.onerror = (error) => addLog(`Lỗi WebSocket: ${error.message || 'Unknown error'}`, 'error');
            }
            
            // --- API Communication & Time Sync ---
             async function syncTime() {
              try {
                addLog('Bắt đầu đồng bộ thời gian với máy chủ Bybit...', 'info');
                const t0 = Date.now();
                const res = await fetch('https://api.bybit.com/v5/market/time?_=' + t0, { cache: 'no-store' });
                const json = await res.json();
                const t1 = Date.now();
                if (json.retCode !== 0) throw new Error(json.retMsg || 'time API error');
                const r = json.result || {};
                const serverMs = r.timeSecond ? (parseInt(r.timeSecond, 10) * 1000) : Math.floor(parseInt(r.timeNano, 10) / 1e6);
                const midpoint = (t0 + t1) / 2;
                const oldOffset = state.timeOffset;
                state.timeOffset = serverMs - midpoint;
                state.isTimeSynced = true;
                addLog(`Đồng bộ thời gian thành công. Lệch: ${state.timeOffset.toFixed(0)}ms (thay đổi: ${(state.timeOffset - oldOffset).toFixed(0)}ms).`, 'success');
                return true;
              } catch (e) {
                state.isTimeSynced = false;
                addLog(`Lỗi đồng bộ thời gian: ${e.message}. API có thể không hoạt động.`, 'error');
                return false;
              }
            }
            
            async function publicBybitRequest(endpoint, params) {
                const API_BASE = 'https://api.bybit.com';
                const url = new URL(API_BASE + endpoint);
                const usp = new URLSearchParams();
                Object.keys(params || {}).sort().forEach(k => {
                    usp.append(k, params[k]);
                });
                const qs = usp.toString();
                if (qs) url.search = qs;

                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    if (data.retCode !== 0) {
                        addLog(`Lỗi API công khai (${endpoint}): ${data.retMsg}`, 'error');
                        return null;
                    }
                    return data.result;
                } catch (error) {
                    addLog(`Lỗi mạng công khai: ${error.message}`, 'error');
                    return null;
                }
            }

            async function bybitRequest(endpoint, method, params, isRetry = false) {
                if (!state.apiKey || !state.apiSecret) { addLog('Lỗi: Vui lòng lưu API Key và Secret trước.', 'error'); return null; }
                if (!state.isTimeSynced && !isRetry) {
                    const syncSuccess = await syncTime();
                    if (!syncSuccess) return null;
                }

                const API_BASE = 'https://api.bybit.com';
                const fudgeMs = 250;
                const timestamp = (Date.now() + state.timeOffset - fudgeMs).toString();
                const recvWindow = '20000';
                let body = null;
                let qs = '';
                const url = new URL(API_BASE + endpoint);

                if (method === 'GET') {
                  const usp = new URLSearchParams();
                  Object.keys(params || {}).sort().forEach(k => {
                    const v = params[k];
                    usp.append(k, Array.isArray(v) ? v.join(',') : String(v));
                  });
                  qs = usp.toString();
                  if (qs) url.search = qs;
                } else {
                  body = JSON.stringify(params || {});
                  qs = body;
                }

                const stringToSign = timestamp + state.apiKey + recvWindow + qs;
                const signature = CryptoJS.HmacSHA256(stringToSign, state.apiSecret).toString();
                
                const headers = { 
                    'Content-Type': 'application/json', 'X-BAPI-API-KEY': state.apiKey, 'X-BAPI-TIMESTAMP': timestamp, 
                    'X-BAPI-RECV-WINDOW': recvWindow, 'X-BAPI-SIGN': signature, 'X-BAPI-SIGN-TYPE': '2',
                };

                try {
                    const response = await fetch(url, { method, headers, body });
                    const data = await response.json();
                    const msg = String(data.retMsg || "");
                    const isTimestampError = data.retCode === 10002 || (data.retCode === 10001 && /timestamp|req_timestamp/i.test(msg));

                    if (isTimestampError && !isRetry) {
                        addLog(`Phát hiện lỗi timestamp (Code: ${data.retCode}). Tự động đồng bộ lại thời gian và thử lại...`, 'info');
                        const syncSuccess = await syncTime();
                        if (syncSuccess) { return await bybitRequest(endpoint, method, params, true); } 
                        else { addLog('Thử lại thất bại do không thể đồng bộ thời gian.', 'error'); return null; }
                    }

                    if (data.retCode !== 0) { addLog(`Lỗi API (${endpoint}): ${data.retMsg} (Code: ${data.retCode})`, 'error'); return null; }
                    return data.result;
                } catch (error) { addLog(`Lỗi mạng: ${error.message}`, 'error'); return null; }
            }
            
            // --- UI & Helper Functions ---
            const addLog = (message, type = 'info') => {
                const p = document.createElement('p');
                p.innerHTML = `<span class="text-gray-500">${new Date().toLocaleTimeString()}</span> - ${message}`;
                if (type === 'error') p.className = 'text-red-400';
                if (type === 'success') p.className = 'text-green-400';
                elements.logContainer.appendChild(p);
                elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            };
            const setBotStatusUI = (status) => {
                state.isTradingRunning = (status === 'running');
                let text = 'Đang Quét...', className = 'status-stopped';
                if (status === 'running') { text = 'Đang Giao dịch'; className = 'status-running'; }
                if (status === 'cooldown') { text = 'Tạm nghỉ'; className = 'status-cooldown'; }
                if (status === 'stopped') { text = 'Đã dừng'; className = 'status-stopped'; }

                elements.botStatus.textContent = text;
                elements.botStatus.className = `status-badge ml-2 ${className}`;
                elements.startBotButton.disabled = state.isTradingRunning;
                elements.stopBotButton.disabled = !state.isTradingRunning;
            };
            const roundToTickSize = (num, tickSize) => Math.floor(num / tickSize) * tickSize;

            // --- Technical Analysis Calculations ---
            const calculateEMA = (d, p) => { const k = 2/(p+1); let e=[d[0]]; for(let i=1;i<d.length;i++) e.push(d[i]*k+e[i-1]*(1-k)); return e; };
            const calculateATR = (klines, p) => { let tr=[]; for(let i=1;i<klines.length;i++) {tr.push(Math.max(klines[i].high-klines[i].low,Math.abs(klines[i].high-klines[i-1].close),Math.abs(klines[i].low-klines[i-1].close)));} return calculateEMA(tr, p).pop(); };
            const calculateVWAP = (klines, p) => { const rk=klines.slice(-p); let pv=0, v=0; rk.forEach(k => { pv += ((k.high+k.low+k.close)/3)*k.volume; v+=k.volume; }); return v > 0 ? pv/v : 0; };

            // --- Core Bot Logic ---
            async function runTradingLogic() {
                if (!state.isTradingRunning) return;
                
                const syncSuccess = await syncTime();
                if (!syncSuccess) {
                    addLog('Dừng giao dịch do lỗi đồng bộ thời gian.', 'error');
                    elements.stopBotButton.click();
                    return;
                }
                if (Date.now() < state.cooldownUntil) {
                    setBotStatusUI('cooldown');
                    addLog(`Bot đang trong thời gian nghỉ, còn lại ${Math.round((state.cooldownUntil - Date.now()) / 1000)}s...`);
                    return;
                }
                
                setBotStatusUI('running');
                await updatePositionStatus();

                if (state.position.hasPosition) { 
                    await manageOpenPosition(); 
                } else if (state.latestTopCoin) {
                    const modeParams = ADAPTIVE_MODES[state.mode];
                    if (state.latestTopCoin.pumpScore >= modeParams.minPumpScore && state.latestTopCoin.advancedScore >= 30) {
                        addLog(`Tín hiệu hợp lệ cho ${state.latestTopCoin.symbol} được tìm thấy. Chuẩn bị vào lệnh.`, 'success');
                        await executeTrade(state.latestTopCoin);
                    } else {
                        addLog(`Chờ tín hiệu giao dịch hợp lệ...`);
                    }
                }
            }
            
            async function discoverPromisingPairs() {
                const tickersData = await publicBybitRequest('/v5/market/tickers', { category: 'spot' });
                if (!tickersData?.list) { addLog('Không thể tải danh sách tickers từ Bybit.', 'error'); return []; }
                const promisingPairs = tickersData.list.filter(t=>t.symbol.endsWith('USDT')).sort((a,b)=>parseFloat(b.turnover24h)-parseFloat(a.turnover24h)).slice(0,40).map(t=>t.symbol);
                if (promisingPairs.length > 0) addLog(`Quét Top ${promisingPairs.length} cặp...`, 'info');
                return promisingPairs;
            }

            async function scanMarket() {
                const coinList = await discoverPromisingPairs();
                if (!coinList || coinList.length === 0) { return; }
                
                let scoredCoins = [];
                for (const symbol of coinList) {
                    try {
                        const scores = await calculateScores(symbol);
                        if(scores) scoredCoins.push({ symbol, ...scores });
                    } catch (e) { /* silent fail for single coin scan */ }
                }
                
                if (scoredCoins.length === 0) { return; }
                
                scoredCoins.sort((a, b) => (b.pumpScore + b.advancedScore) - (a.pumpScore + a.advancedScore));
                const topCoin = scoredCoins[0];
                if (state.latestTopCoin?.symbol !== topCoin.symbol) {
                    updateChart(topCoin.symbol);
                }
                state.latestTopCoin = topCoin;
                
                elements.topCoin.textContent = topCoin.symbol;
                elements.pumpScore.textContent = `${topCoin.pumpScore.toFixed(0)}/100`;
                elements.advancedScore.textContent = `${topCoin.advancedScore.toFixed(0)}/60`;
                connectWebSocket(topCoin.symbol);
            }

            async function calculateScores(symbol) {
                const klineData = await publicBybitRequest('/v5/market/kline', { category: 'spot', symbol, interval: '1', limit: 100 });
                const realtime = state.realtimeData.get(symbol);
                if (!klineData?.list || klineData.list.length < 50 || !realtime?.orderbook) return null;
                const klines = klineData.list.map(k=>({time:k[0],open:parseFloat(k[1]),high:parseFloat(k[2]),low:parseFloat(k[3]),close:parseFloat(k[4]),volume:parseFloat(k[5])})).reverse();
                
                const modeParams = ADAPTIVE_MODES[state.mode];
                let pumpScore = 0;
                const currentPrice = klines[klines.length-1].close;
                const orderBookData = realtime.orderbook;
                const bestBid = parseFloat(orderBookData.b[0][0]), bestAsk = parseFloat(orderBookData.a[0][0]);
                const spread = (bestAsk - bestBid) / bestAsk * 100;

                if (spread <= modeParams.maxSpread) pumpScore += 15;
                else if (spread <= modeParams.maxSpread + 0.02) pumpScore += 5;

                let depth10 = 0; orderBookData.b.forEach(([p,s]) => { if (parseFloat(p) >= bestBid*0.999) depth10 += parseFloat(s)*parseFloat(p); });
                if (depth10 >= modeParams.minDepthMultiplier * parseFloat(elements.orderValueInput.value)) pumpScore += 15;
                else if (depth10 >= (modeParams.minDepthMultiplier / 2) * parseFloat(elements.orderValueInput.value)) pumpScore += 5;

                const bidNotional = orderBookData.b.slice(0,5).reduce((a,[p,s])=>a+(parseFloat(p)*parseFloat(s)),0);
                const askNotional = orderBookData.a.slice(0,5).reduce((a,[p,s])=>a+(parseFloat(p)*parseFloat(s)),0);
                if (askNotional > 0 && (bidNotional/askNotional) >= 1.2) pumpScore += 10;
                
                const closes = klines.map(k => k.close);
                if (closes[closes.length-1] > closes[closes.length-2]) pumpScore += 10;
                if (closes[closes.length-1] > closes[closes.length-4]) pumpScore += 10;
                const [ema9,ema20,ema50] = [calculateEMA(closes,9).pop(),calculateEMA(closes,20).pop(),calculateEMA(closes,50).pop()];
                if (ema9>ema20 && ema20>ema50) pumpScore += 10;
                const atr = calculateATR(klines, 14);
                if (Math.abs(klines[klines.length-1].close - klines[klines.length-1].open) < 1.5 * atr && Math.abs(klines[klines.length-2].close-klines[klines.length-2].open) < 1.5 * atr) pumpScore += 5;
                const atrPercent = (atr / currentPrice) * 100;
                if (atrPercent >= modeParams.atrRange[0] && atrPercent <= modeParams.atrRange[1]) pumpScore += 15;
                const vwap = calculateVWAP(klines, 20);
                if (currentPrice > vwap) pumpScore += 10;

                let advancedScore = 0;
                if (realtime.micropriceTilts.length >= 3 && realtime.micropriceTilts.slice(-3).every(t => t >= 0.02)) advancedScore += 10;
                const cumBid = orderBookData.b.slice(0,5).reduce((a,[,s])=>a+parseFloat(s),0);
                const cumAsk = orderBookData.a.slice(0,5).reduce((a,[,s])=>a+parseFloat(s),0);
                if (cumBid + cumAsk > 0 && (cumBid - cumAsk) / (cumBid + cumAsk) >= 0.2) advancedScore += 10;
                const cvdTrend = realtime.cvd > (state.realtimeData.get(symbol)?.trades[0]?.cvd_start || 0);
                const priceTrend = currentPrice > klines[klines.length-5].close;
                if (cvdTrend && !priceTrend) advancedScore += 10;
                if (realtime.iceberg.traded > realtime.iceberg.displayed * 1.5) advancedScore += 10;
                
                return { pumpScore, advancedScore, currentPrice, spread, atrPercent, vwap, ema20, klines };
            }
            
            async function executeTrade(coinData) {
                const { symbol, advancedScore, currentPrice, spread, atrPercent, vwap, ema20, klines } = coinData;
                const info = state.instrumentInfo.get(symbol);
                if (!info) return addLog(`Thiếu thông tin của cặp ${symbol}`, 'error');
                
                const modeParams = ADAPTIVE_MODES[state.mode];
                const orderValue = parseFloat(elements.orderValueInput.value);
                const minOrderValue = parseFloat(info.lotSizeFilter.minOrderValue || '5');
                if(orderValue < minOrderValue) return addLog(`Giá trị lệnh ${orderValue}$ quá nhỏ cho ${symbol} (yêu cầu ≥ ${minOrderValue}$).`);

                const pullbackFactor = advancedScore >= 30 ? 0.45 : 0.6;
                const hh20 = Math.max(...klines.slice(-20).map(k => k.high));
                const vungChuan = Math.max(vwap, ema20, hh20);
                const atrStep = (atrPercent / 100) * currentPrice;
                const entryPrice = roundToTickSize(vungChuan - pullbackFactor * atrStep, parseFloat(info.priceFilter.tickSize));
                const tpPercent = Math.max(0.35, modeParams.tpMultiplier * spread, 0.8 * atrPercent) / 100;
                const takeProfitPrice = roundToTickSize(entryPrice * (1 + (tpPercent + (state.mode === 'Safe' ? 0.0015 : 0.0025) )), parseFloat(info.priceFilter.tickSize));
                const stopLossPrice = roundToTickSize(vungChuan * 0.996, parseFloat(info.priceFilter.tickSize));
                const qty = Math.floor((orderValue / entryPrice) / parseFloat(info.lotSizeFilter.qtyStep)) * parseFloat(info.lotSizeFilter.qtyStep);

                addLog(`Chuẩn bị lệnh MUA ${qty} ${symbol} tại ${entryPrice} (pullback ${pullbackFactor}x). TP: ${takeProfitPrice}, SL: ${stopLossPrice}`, 'success');
                const orderResult = await bybitRequest('/v5/order/create', 'POST', {
                    category: 'spot', symbol, side: 'Buy', orderType: 'Limit', qty: qty.toString(),
                    price: entryPrice.toString(), timeInForce: 'PostOnly',
                    takeProfit: takeProfitPrice.toString(), stopLoss: stopLossPrice.toString(),
                });
                
                if (orderResult?.orderId) {
                    addLog(`Đặt lệnh thành công. OrderID: ${orderResult.orderId}`, 'success');
                    state.position.entryTime = Date.now() + state.timeOffset;
                    state.position.coin = info.baseCoin;
                    state.position.symbol = symbol;
                    state.position.hasPosition = true;
                }
            }

            async function manageOpenPosition() {
                const modeParams = ADAPTIVE_MODES[state.mode];
                const timeStopSeconds = modeParams.timeStop;
                const elapsedSeconds = ((Date.now() + state.timeOffset) - state.position.entryTime) / 1000;
                if (elapsedSeconds > timeStopSeconds) {
                    addLog(`Vị thế đã vượt quá Time-Stop (${timeStopSeconds}s). Đang đóng...`, 'info');
                    await closePosition(state.position.symbol, state.position.coin);
                } else {
                    addLog(`Đang giữ ${state.position.symbol}. Thời gian mở: ${Math.round(elapsedSeconds)}s / ${timeStopSeconds}s.`);
                }
            }
            
            async function updatePositionStatus() {
                 const usdtPortfolio = await bybitRequest('/v5/asset/transfer/query-account-coins-balance', 'GET', { accountType: "UNIFIED", coin: "USDT" });
                 if (usdtPortfolio?.balance) {
                    const usdtBalance = usdtPortfolio.balance.find(c => c.coin === 'USDT');
                    if (usdtBalance) elements.usdtBalance.textContent = parseFloat(usdtBalance.walletBalance).toFixed(2);
                 }
                 
                 if (state.position.coin) {
                    const coinPortfolio = await bybitRequest('/v5/asset/transfer/query-account-coins-balance', 'GET', { accountType: "UNIFIED", coin: state.position.coin });
                    const coinBalance = coinPortfolio?.balance.find(c => c.coin === state.position.coin);
                    
                    if (coinBalance && parseFloat(coinBalance.walletBalance) > 1e-6) {
                        if (!state.position.hasPosition) { addLog('Phát hiện vị thế mới.', 'success'); }
                        state.position.hasPosition = true;
                        elements.currentPosition.textContent = `${coinBalance.coin}: ${parseFloat(coinBalance.walletBalance)}`;
                    } else {
                        if (state.position.hasPosition) { addLog(`Vị thế ${state.position.coin} đã được đóng.`, 'info'); }
                        state.position.hasPosition = false;
                        state.position.coin = null;
                        state.position.symbol = null;
                        elements.currentPosition.textContent = 'Không có';
                    }
                 } else {
                    state.position.hasPosition = false;
                    elements.currentPosition.textContent = 'Không có';
                 }
            }

            async function closePosition(symbol, coin) {
                addLog(`Đang đóng vị thế ${symbol} bằng lệnh Market...`, 'info');
                await bybitRequest('/v5/order/cancel-all', 'POST', { category: 'spot', symbol });
                const portfolio = await bybitRequest('/v5/asset/transfer/query-account-coins-balance', 'GET', { accountType: "UNIFIED", coin });
                const coinBalance = portfolio?.balance[0];
                if (coinBalance && parseFloat(coinBalance.walletBalance) > 0) {
                    const info = state.instrumentInfo.get(symbol);
                    const qty = Math.floor(parseFloat(coinBalance.walletBalance)/parseFloat(info.lotSizeFilter.qtyStep))*parseFloat(info.lotSizeFilter.qtyStep);
                    if(qty > 0) {
                        const closeResult = await bybitRequest('/v5/order/create', 'POST', { category: 'spot', symbol, side: 'Sell', orderType: 'Market', qty: qty.toString() });
                        if (closeResult?.orderId) { addLog('Đóng vị thế thành công.', 'success'); state.risk.consecutiveLosses++; }
                    }
                }
                state.position.hasPosition = false;
                state.position.coin = null;
                state.position.symbol = null;
                if(state.risk.consecutiveLosses >= 2) {
                    addLog('2 lệnh thua liên tiếp, tạm nghỉ 30 phút.', 'error');
                    state.cooldownUntil = Date.now() + 30 * 60 * 1000;
                    state.risk.consecutiveLosses = 0;
                }
            }

            // --- Event Listeners & Initialization ---
            elements.saveApiButton.addEventListener('click', async () => {
                state.apiKey = elements.apiKeyInput.value.trim();
                state.apiSecret = elements.apiSecretInput.value.trim();
                if (state.apiKey && state.apiSecret) {
                    localStorage.setItem('bybitApiKey', state.apiKey);
                    localStorage.setItem('bybitApiSecret', state.apiSecret);
                    
                    const syncSuccess = await syncTime();
                    if (!syncSuccess) {
                        addLog('Không thể khởi tạo bot do lỗi đồng bộ thời gian. Vui lòng thử lại.', 'error');
                        return;
                    }

                    addLog('Đã lưu khóa API thành công.', 'success');
                    await updatePositionStatus();
                    
                    const instruments = await publicBybitRequest('/v5/market/instruments-info', { category: 'spot', limit: 1000 });
                    if (instruments?.list) {
                        instruments.list.forEach(i => state.instrumentInfo.set(i.symbol, i));
                        addLog(`Đã tải thông tin cho ${state.instrumentInfo.size} cặp. Bot đã sẵn sàng.`, 'success');
                        elements.startBotButton.disabled = false;
                    } else { addLog('Không thể tải thông tin cặp giao dịch.', 'error'); }
                } else { addLog('Vui lòng nhập cả API Key và Secret.', 'error'); }
            });
            elements.startBotButton.addEventListener('click', async () => {
                if (!state.apiKey || !state.apiSecret) return addLog('Lỗi: Vui lòng lưu API trước khi bắt đầu.', 'error');
                
                addLog('Đang kiểm tra & đồng bộ lại thời gian trước khi bắt đầu...', 'info');
                const syncSuccess = await syncTime();
                if (!syncSuccess) {
                    return addLog('Lỗi: Đồng bộ thời gian thất bại. Không thể bắt đầu bot.', 'error');
                }

                if (state.instrumentInfo.size === 0) return addLog('Lỗi: Chưa có thông tin cặp giao dịch. Vui lòng lưu lại API.', 'error');

                addLog('Bot đã bắt đầu GIAO DỊCH...', 'success');
                setBotStatusUI('running');
                
                if (state.tradeInterval) clearInterval(state.tradeInterval);
                state.tradeInterval = setInterval(runTradingLogic, 15000);
            });
            elements.stopBotButton.addEventListener('click', () => {
                if (state.tradeInterval) clearInterval(state.tradeInterval);
                state.tradeInterval = null;
                addLog('Bot đã dừng GIAO DỊCH. Chế độ quét vẫn chạy.', 'info');
                setBotStatusUI('stopped');
            });
             elements.tradeModeRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    state.mode = event.target.value;
                    addLog(`Chế độ giao dịch đã được đổi thành: ${state.mode}`, 'success');
                });
            });
            async function initialize() {
                addLog('Khởi tạo bot... Bắt đầu quét thị trường công khai.');
                initChart();
                updateChart('BTCUSDT');
                setBotStatusUI('stopped');
                elements.stopBotButton.disabled = true;

                const storedApiKey = localStorage.getItem('bybitApiKey');
                const storedApiSecret = localStorage.getItem('bybitApiSecret');
                if (storedApiKey && storedApiSecret) {
                    elements.apiKeyInput.value = storedApiKey;
                    elements.apiSecretInput.value = storedApiSecret;
                    await elements.saveApiButton.click();
                } else { 
                    addLog('Chào mừng! Bot đang ở chế độ quét. Vui lòng nhập API Key để bật giao dịch.');
                     const instruments = await publicBybitRequest('/v5/market/instruments-info', { category: 'spot', limit: 1000 });
                     if (instruments?.list) {
                        instruments.list.forEach(i => state.instrumentInfo.set(i.symbol, i));
                     }
                }
                
                if(state.scanInterval) clearInterval(state.scanInterval);
                state.scanInterval = setInterval(scanMarket, 15000);
                scanMarket();
            }
            initialize();
        });
    </script>
</body>
</html>

