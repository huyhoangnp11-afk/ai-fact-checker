<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <title>Bybit Browser Bot v7.0 (UI Polish) ‚Äî Autopilot ‚Ä¢ ALT Hunter</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    /* A more refined color palette and modern UI styling */
    :root{
      --bg:#0d1117;
      --card:#161b22;
      --line:#30363d;
      --text:#c9d1d9;
      --muted:#8b949e;
      --ok:#56d364;
      --bad:#f85149;
      --warn:#d29922;
      --accent:#58a6ff;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1280px;margin:24px auto;padding:0 20px}
    h1{margin:0 0 12px;font-size:24px; font-weight: 500;}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:16px}
    .col-3{grid-column:span 3}.col-4{grid-column:span 4}.col-5{grid-column:span 5}.col-6{grid-column:span 6}.col-7{grid-column:span 7}.col-8{grid-column:span 8}.col-12{grid-column:span 12}
    @media (max-width: 992px) { .col-3, .col-4, .col-5 { grid-column: span 6; } }
    @media (max-width: 768px) { .col-3, .col-4, .col-5, .col-6, .col-7, .col-8 { grid-column: span 12; } }
    label{display:block;color:var(--muted);font-size:12px;margin:8px 0 4px; font-weight: 500;}
    input,select,textarea{width:100%;background:#0d1117;border:1px solid var(--line);color:var(--text);border-radius:8px;padding:10px; transition: border-color 0.2s ease, box-shadow 0.2s ease;}
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.2);}
    input[type="checkbox"]{width:auto; accent-color: var(--accent);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 12px;border-radius:999px;background:#0d1117;border:1px solid var(--line);color:var(--text); cursor:pointer; font-size: 13px;}
    .tiny{font-size:12px;color:var(--muted); opacity: 0.9;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--ok)}.bad{color:var(--bad)}.warn{color:var(--warn)}
    #logLive,#logBack{height:220px;overflow:auto;background:#010409;border:1px solid var(--line);border-radius:8px;padding:12px;white-space:pre-wrap; font-size: 13px; line-height: 1.6;}
    table{width:100%;border-collapse:collapse;margin-top:8px;} th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left; font-size: 13px;} th {color: var(--muted); font-weight: 500;}
    .tabs{display:flex;gap:8px;margin:16px 0; border-bottom: 1px solid var(--line);}
    .tab{padding:10px 16px;border:1px solid transparent; border-bottom: 2px solid transparent; border-radius:8px 8px 0 0; color: var(--muted); cursor:pointer; transition: all 0.2s ease; margin-bottom: -1px;}
    .tab:hover { background: var(--card); color: var(--text); }
    .tab.active{background:var(--card); color:var(--text); border-bottom-color:var(--accent);}
    .tabview{display:none}.tabview.active{display:block}
    .btn{
        width:auto; padding: 10px 16px; font-weight: 500; cursor: pointer; border-radius: 8px;
        background: #21262d; border: 1px solid var(--line); color: var(--text);
        transition: all 0.2s ease;
    }
    .btn:hover:not(:disabled){background:#30363d; border-color: #8b949e;}
    .btn:disabled { opacity: 0.6; cursor: not-allowed;}
    button#start, button#B_run, button#autopilot { background: #238636; border-color: #38a24a; color: white; }
    button#start:hover:not(:disabled), button#B_run:hover:not(:disabled), button#autopilot:hover:not(:disabled) { background: #2ea043; }
    button#stop { background: #da3633; border-color: #e5534b; color: white;}
    button#stop:hover:not(:disabled) { background: #f04747; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Bybit Browser Bot v7.0 <span class="tiny">‚Äî T·ªëi ∆∞u ho√° ‚Ä¢ Autopilot ‚Ä¢ ALT Hunter</span></h1>
  <div class="tabs">
    <div class="tab active" data-tab="live">‚ö° Live Bot</div>
    <div class="tab" data-tab="back">‚õè Backtester</div>
    <div class="tab" data-tab="help">üß† Autopilot & Help</div>
  </div>

  <!-- LIVE TAB -->
  <section class="tabview active" id="tab-live">
    <div class="grid">
      <div class="card col-4">
        <b>1) API & Security</b>
        <label>API Key</label><input id="apiKey" placeholder="BYBITxxxx" autocomplete="off" spellcheck="false" />
        <label>API Secret</label><input id="apiSecret" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="off" spellcheck="false" />
        <label>Encryption Passphrase</label><input id="passphrase" type="password" placeholder="e.g., batman-2002" autocomplete="new-password" />
        <div class="row" style="margin-top:12px">
          <button id="saveKeys" class="btn">Save</button>
          <button id="loadKeys" class="btn">Load</button>
          <button id="clearKeys" class="btn">Clear</button>
        </div>
        <div class="row" style="margin-top:12px">
          <label class="pill"><input id="useTestnet" type="checkbox" checked> Testnet</label>
          <label class="pill"><input id="simMode" type="checkbox"> SIM mode</label>
          <label class="pill"><input id="autoRun" type="checkbox"> Auto‚Äërun</label>
        </div>
        <div class="tiny" style="margin-top:12px">‚ö†Ô∏è Spot trading only. Secrets are AES‚ÄëGCM encrypted with your passphrase and saved in local storage.</div>
        <div class="tiny warn" id="corsWarn" style="display:none;margin-top:6px">CORS error detected ‚Üí Use Testnet or a private Proxy.</div>
      </div>

      <div class="card col-8">
        <b>2) Strategy & Automation (Live)</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>USDT per Trade</label><input id="orderQuote" type="number" min="5" step="0.1" value="8"/></div>
          <div class="col-3"><label>Candle Timeframe</label><select id="tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-3"><label>Recv Window (ms)</label><input id="recvWindow" type="number" value="5000"/></div>
          <div class="col-3"><label>Proxy (optional)</label><input id="proxy" placeholder="https://your-worker.workers.dev" inputmode="url" spellcheck="false" autocomplete="off" /></div>
          <div class="col-12 row">
            <label class="pill"><input id="autoMode" type="checkbox"> Auto Buy</label>
            <label class="pill"><input id="btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
            <label class="pill"><input id="useTrailing" type="checkbox" checked> Trailing SL</label>
            <label class="pill"><input id="useBreakeven" type="checkbox" checked> Breakeven Lock</label>
            <label class="pill"><input id="useOCOEmu" type="checkbox" checked> Emulated OCO</label>
          </div>
          <div class="col-12 row">
            <label class="pill"><input id="useBalanceSizing" type="checkbox" checked> Use % Balance Sizing</label>
            <div style="width:110px"><label>Risk %</label><input id="riskPct" type="number" step="0.5" value="15"/></div>
            <div style="width:130px"><label>Reserve (USDT)</label><input id="reserveUsd" type="number" step="0.1" value="2"/></div>
            <div style="width:130px"><label>Min / Max (USDT)</label><input id="minQuote" type="number" step="0.1" value="5"/></div>
            <div style="width:110px"><label>&nbsp;</label><input id="maxQuote" type="number" step="0.1" value="25"/></div>
            <div style="width:160px"><label>Account Type</label>
              <select id="balanceAcct"><option value="AUTO" selected>AUTO</option><option value="SPOT">SPOT</option><option value="UNIFIED">UNIFIED</option></select>
            </div>
          </div>
          <div class="col-12"><label>Symbol List (CSV, empty = ALT Hunter)</label><input id="symbolList" placeholder="Leave empty for auto-selection of trending ALTs"/></div>
          <div class="col-3"><label>Min Signal Score (>=)</label><input id="minScore" type="number" value="5"/></div>
          <div class="col-3"><label>Time‚Äëstop (minutes)</label><input id="timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>Max Daily Losses</label><input id="maxLossDay" type="number" value="2"/></div>
          <div class="col-3"><label>Base Scan Interval (s)</label><input id="scanSec" type="number" value="20"/></div>
        </div>
        <div class="grid" style="margin-top:12px">
          <div class="col-12" style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px">
            <div><div class="tiny">Status</div><div id="status" class="ok">Idle</div></div>
            <div><div class="tiny">Watching</div><div id="watching">‚Äî</div></div>
            <div><div class="tiny">Signal</div><div id="signal">‚Äî</div></div>
            <div><div class="tiny">Last Update</div><div id="lastUpdate">‚Äî</div></div>
            <div><div class="tiny">Daily Losses</div><div id="lossStreak">0</div></div>
            <div><div class="tiny">Daily PnL</div><div id="pnlDay">0.00</div></div>
             <div><div class="tiny">USDT free</div><div id="usdtFree">‚Äî</div></div>
          </div>
        </div>
        <div class="row" style="margin-top:12px">
          <button id="start" class="btn">‚ñ∂ Start</button>
          <button id="stop" class="btn">‚ñ† Stop</button>
          <button id="resetDay" class="btn">‚ü≤ Reset Session</button>
          <label class="pill" style="margin-left:auto;"><input id="autoResetStart" type="checkbox" checked> Auto-reset on start</label>
        </div>
      </div>

      <div class="card col-12">
        <b>Live Log</b>
        <div id="logLive" role="log" aria-live="polite"></div>
      </div>
      <div class="card col-12">
        <b>Journal & Performance (Live)</b>
        <table id="journalLive"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>Result/PnL</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-back">
    <div class="grid">
      <div class="card col-5">
        <b>Backtester ‚Äì Data Configuration</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-4"><label>Candle Timeframe</label><select id="B_tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-4"><label>Lookback (candles)</label><input id="B_lookback" type="number" value="1000" /></div>
          <div class="col-4"><label>Top N Coins by Turnover</label><input id="B_topN" type="number" value="12" /></div>
          <div class="col-12"><label>Symbol List (CSV, empty = top N)</label><input id="B_symbolList" placeholder="BTCUSDT,ETHUSDT,SOLUSDT"/></div>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="pill"><input id="B_btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
          <label class="pill"><input id="B_pessimistic" type="checkbox" checked> Pessimistic fills (SL first)</label>
        </div>
      </div>
      <div class="card col-7">
        <b>Backtester ‚Äì Strategy & Fees</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>Min Score</label><input id="B_minScore" type="number" value="5"/></div>
          <div class="col-3"><label>TP = k√óATR</label><input id="B_tpK" type="number" step="0.1" value="1.2"/></div>
          <div class="col-3"><label>SL = k√óATR</label><input id="B_slK" type="number" step="0.1" value="0.8"/></div>
          <div class="col-3"><label>Time‚Äëstop (min)</label><input id="B_timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>USDT/Trade</label><input id="B_quote" type="number" step="0.1" value="8"/></div>
          <div class="col-3"><label>Taker Fee (%)</label><input id="B_feePct" type="number" step="0.01" value="0.10"/></div>
          <div class="col-3"><label>Slippage (bps)</label><input id="B_slipBps" type="number" step="0.1" value="2"/></div>
          <div class="col-3 row"><label class="pill"><input id="B_useBreakeven" type="checkbox" checked> BE Lock</label></div>
          <div class="col-9 row"><label class="pill"><input id="B_useTrailing" type="checkbox" checked> Trailing after TP</label></div>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="B_run" class="btn">‚ñ∂ Backtest</button>
          <button id="B_grid" class="btn">‚õè Grid Search</button>
          <button id="autopilot" class="btn">üöÄ Autopilot: Optimize ‚Üí Start</button>
        </div>
      </div>
      <div class="card col-12"><div id="logBack" role="log" aria-live="polite"></div></div>
      <div class="card col-12"><div id="B_summary" class="mono"></div></div>
      <div class="card col-12">
        <b>Equity Curve</b>
        <canvas id="pnlChart" style="margin-top: 10px;"></canvas>
      </div>
      <div class="card col-12">
        <b>Journal (Backtest)</b>
        <table id="journalBack"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>PnL($)</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="card col-12">
        <b>Result by Symbol (Backtest)</b>
        <table id="bySymBack"><thead><tr><th>Symbol</th><th>Trades</th><th>Win %</th><th>PnL($)</th><th>Avg R</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-help">
    <div class="card col-12">
      <b>User Guide & Autopilot</b>
      <ul>
        <li><b>Autopilot (üöÄ):</b> Press the "Autopilot: Optimize ‚Üí Start" button in the Backtester tab. The bot will:
          <ol>
            <li>Run a <b>Grid Search</b> to find the best TP/SL multipliers (k√óATR).</li>
            <li>Automatically <b>copy</b> the optimal parameters to the Live Bot tab.</li>
            <li>If you have saved API keys, it will <b>prompt for your passphrase</b>, decrypt, and load them. If this fails or no keys are saved, it will automatically run in <b>SIM mode</b>.</li>
            <li>Enable <b>Auto Buy</b> and <b>start</b> the bot. (If not in SIM mode, it will connect to the private WebSocket for faster fill detection).</li>
          </ol>
        </li>
        <li><b>ALT Hunter:</b> When the symbol list is empty, the bot prioritizes high-liquidity, low-priced ALT coins suitable for your trade size. During BTC downtrends, it seeks ALTs showing relative strength against BTC.</li>
        <li><b>Smart Scan:</b> The bot automatically scans faster (2-4s) near candle closes and slows down to the base interval mid-candle to optimize performance and reduce API load.</li>
        <li><b>Timestamp Guard (10001):</b> The bot periodically syncs its clock with Bybit's servers and will automatically retry once if it encounters a timestamp-related API error.</li>
        <li><b>Session Reset:</b> The "Auto-reset on start" option (enabled by default) clears the previous session's PnL and loss streak each time you press Start.</li>
        <li><b>Manual Workflow:</b> 1Ô∏è‚É£ Backtest ‚Üí 2Ô∏è‚É£ Fine-tune Live settings ‚Üí 3Ô∏è‚É£ Load API keys (for real trading) ‚Üí 4Ô∏è‚É£ Start.</li>
        <li>‚ö†Ô∏è <b>Disclaimer:</b> Always test in SIM/Testnet mode first. Use at your own risk. Do not use API keys with withdrawal permissions. For CORS issues, use a private proxy like a Cloudflare Worker.</li>
      </ul>
    </div>
  </section>
</div>

<script>
// ================================================================================= //
//                            BYBIT BOT v7.0 SCRIPT START                            //
// ================================================================================= //

const BybitBotApp = {
    // --- App State ---
    state: {
        isRunning: false,
        isStopping: false,
        isInPosition: false,
        currentPosition: {},
        timers: {
            scheduler: null,
            monitor: null,
            simMonitor: null,
        },
        ws: {
            instance: null,
            ping: null,
            watchdog: null,
            backoff: 3000,
        },
        time: {
            serverOffset: 0,
            lastSync: 0,
            netRTT: 300,
            lastTs: 0,
        },
        apiQueue: Promise.resolve(),
        cancelLock: false,
        cancelTimer: null,
    },

    // --- DOM Elements Cache ---
    DOMElements: {},

    // --- Configuration ---
    config: {
        values: {},
        ids: [
            'apiKey', 'apiSecret', 'passphrase', 'useTestnet', 'simMode', 'autoRun',
            'orderQuote', 'tf', 'recvWindow', 'proxy', 'autoMode', 'btcFilter',
            'useTrailing', 'useBreakeven', 'useOCOEmu', 'symbolList', 'minScore',
            'timeStopMin', 'maxLossDay', 'scanSec', 'autoResetStart',
            'useBalanceSizing','riskPct','reserveUsd','minQuote','maxQuote','balanceAcct',
            'B_tf', 'B_lookback', 'B_topN', 'B_symbolList', 'B_btcFilter', 'B_pessimistic',
            'B_minScore', 'B_tpK', 'B_slK', 'B_timeStopMin', 'B_quote', 'B_feePct', 'B_slipBps',
            'B_useBreakeven', 'B_useTrailing'
        ],
        
        load() {
            // Load from UI inputs into values object
            this.ids.forEach(id => {
                const el = BybitBotApp.DOMElements[id];
                if (!el) return;
                this.values[id] = el.type === 'checkbox' ? el.checked : (el.type === 'number' ? +el.value : el.value);
            });
        },

        saveToStorage() {
            const cfgToSave = {
                q: this.values.orderQuote, tf: this.values.tf, rw: this.values.recvWindow, p: this.values.proxy,
                am: this.values.autoMode, bf: this.values.btcFilter, ut: this.values.useTrailing,
                ub: this.values.useBreakeven, uo: this.values.useOCOEmu, sl: this.values.symbolList,
                ms: this.values.minScore, ts: this.values.timeStopMin, ml: this.values.maxLossDay,
                ss: this.values.scanSec, ar: this.values.autoRun, sm: this.values.simMode, ars: this.values.autoResetStart,
                bs: this.values.useBalanceSizing, rp: this.values.riskPct, rz: this.values.reserveUsd,
                mn: this.values.minQuote, mx: this.values.maxQuote, ba: this.values.balanceAcct,
            };
            // v7 storage key (gi·ªØ backward-compat khi load)
            localStorage.setItem('bb_bot_config_v7', JSON.stringify(cfgToSave));
        },
        
        loadFromStorage() {
            const j = localStorage.getItem('bb_bot_config_v7') || localStorage.getItem('bb_bot_config_v6');
            if (!j) return;
            const c = JSON.parse(j);
            const { DOMElements } = BybitBotApp;
            DOMElements.orderQuote.value = c.q ?? 8;
            DOMElements.tf.value = c.tf ?? '5';
            DOMElements.recvWindow.value = c.rw ?? 5000;
            DOMElements.proxy.value = c.p ?? '';
            DOMElements.autoMode.checked = !!c.am;
            DOMElements.btcFilter.checked = c.bf !== false;
            DOMElements.useTrailing.checked = c.ut !== false;
            DOMElements.useBreakeven.checked = c.ub !== false;
            DOMElements.useOCOEmu.checked = c.uo !== false;
            DOMElements.symbolList.value = c.sl ?? '';
            DOMElements.minScore.value = c.ms ?? 5;
            DOMElements.timeStopMin.value = c.ts ?? 15;
            DOMElements.maxLossDay.value = c.ml ?? 2;
            DOMElements.scanSec.value = c.ss ?? 20;
            DOMElements.autoRun.checked = !!c.ar;
            DOMElements.simMode.checked = !!c.sm;
            DOMElements.autoResetStart.checked = c.ars !== false;

            DOMElements.useBalanceSizing.checked = c.bs !== false;
            DOMElements.riskPct.value   = c.rp ?? 15;
            DOMElements.reserveUsd.value= c.rz ?? 2;
            DOMElements.minQuote.value  = c.mn ?? 5;
            DOMElements.maxQuote.value  = c.mx ?? 25;
            DOMElements.balanceAcct.value = c.ba ?? 'AUTO';
            
            this.load(); // Reload values from UI after setting them
        },

        async saveApiKeys() {
            const k = BybitBotApp.DOMElements.apiKey.value.trim();
            const s = BybitBotApp.DOMElements.apiSecret.value.trim();
            const p = BybitBotApp.DOMElements.passphrase.value;
            if (!k || !s || !p) return BybitBotApp.ui.logLive('Thi·∫øu API Key, Secret, ho·∫∑c Passphrase', 'error');
            
            const sealed = await BybitBotApp.utils.crypto.seal(p, s);
            localStorage.setItem('bb_bot_key_v7', k);
            localStorage.setItem('bb_bot_sec_v7', JSON.stringify(sealed));
            localStorage.setItem('bb_bot_testnet_v7', BybitBotApp.DOMElements.useTestnet.checked ? '1' : '0');
            BybitBotApp.ui.logLive('ƒê√£ m√£ ho√° & l∆∞u tr·ªØ API.', 'ok');
        },

        async loadApiKeys() {
            try {
                const p = BybitBotApp.DOMElements.passphrase.value;
                if (!p) return BybitBotApp.ui.logLive('Vui l√≤ng nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£.', 'warn');

                const k = localStorage.getItem('bb_bot_key_v7') || localStorage.getItem('bb_bot_key_v6');
                const b = localStorage.getItem('bb_bot_sec_v7') || localStorage.getItem('bb_bot_sec_v6');
                if (!k || !b) return BybitBotApp.ui.logLive('Kh√¥ng t√¨m th·∫•y API ƒë√£ l∆∞u.', 'warn');

                const s = await BybitBotApp.utils.crypto.open(p, JSON.parse(b));
                BybitBotApp.DOMElements.apiKey.value = k;
                BybitBotApp.DOMElements.apiSecret.value = s;
                BybitBotApp.DOMElements.useTestnet.checked = (localStorage.getItem('bb_bot_testnet_v7') || localStorage.getItem('bb_bot_testnet_v6')) === '1';
                BybitBotApp.ui.logLive('ƒê√£ gi·∫£i m√£ v√† n·∫°p API Secret.', 'ok');
                return true;
            } catch (e) {
                BybitBotApp.ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i: ' + e.message, 'error');
                return false;
            }
        },

        clearApiKeys() {
            ['bb_bot_key_v7','bb_bot_sec_v7','bb_bot_testnet_v7','bb_bot_key_v6','bb_bot_sec_v6','bb_bot_testnet_v6'].forEach(k=>localStorage.removeItem(k));
            BybitBotApp.ui.logLive('ƒê√£ xo√° API kh·ªèi tr√¨nh duy·ªát.', 'ok');
        }
    },

    // --- UI Update Module ---
    ui: {
        logLive(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logLive;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
        },
        logBack(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logBack;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
        },
        updateStatus(text, level = 'ok') {
            const el = BybitBotApp.DOMElements.status;
            el.textContent = text;
            el.className = level;
        },
        updateStats() {
            const { DOMElements, api } = BybitBotApp;
            const { currentPosition } = BybitBotApp.state;
            DOMElements.lastUpdate.textContent = new Date().toLocaleTimeString();
            DOMElements.watching.textContent = currentPosition.watching || '‚Äî';
            DOMElements.signal.textContent = currentPosition.signal || '‚Äî';

            const bc = api.balanceCache;
            if (bc && bc.ts) DOMElements.usdtFree.textContent = (bc.free ?? 0).toFixed(2);
        },
        renderJournal(logId, trades) {
            const table = BybitBotApp.DOMElements[logId];
            const body = table.querySelector('tbody');
            body.innerHTML = '';
            trades.slice(0, 200).forEach(r => {
                const pnlClass = r.pnl > 0 ? 'ok' : (r.pnl < 0 ? 'bad' : '');
                const row = `
                    <td>${new Date(r.ts).toLocaleString()}</td>
                    <td>${r.sym}</td>
                    <td>${r.entry?.toFixed(6) || '-'}</td>
                    <td>${r.tp?.toFixed(6) || '-'}</td>
                    <td>${(logId === 'journalBack' ? r.initialSl : r.sl)?.toFixed(6) || '-'}</td>
                    <td>${r.exit?.toFixed(6) || '-'}</td>
                    <td class="${pnlClass}">${r.pnl?.toFixed(2) || '-'}</td>
                    <td>${r.note || ''}</td>`;
                body.innerHTML += `<tr>${row}</tr>`;
            });
        },
    },

    // --- Utility Functions ---
    utils: {
        canonQS(obj = {}) {
            const enc = v => encodeURIComponent(v == null ? '' : v);
            return Object.keys(obj).sort().map(k => `${k}=${enc(obj[k])}`).join('&');
        },
        crypto: {
            enc: new TextEncoder(),
            dec: new TextDecoder(),
            async kdf(p, s) {
                const baseKey = await crypto.subtle.importKey('raw', this.enc.encode(p), { name: 'PBKDF2' }, false, ['deriveKey']);
                return crypto.subtle.deriveKey({ name: 'PBKDF2', salt: s, iterations: 120000, hash: 'SHA-256' }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
            },
            async seal(p, t) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await this.kdf(p, salt);
                const sealedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, this.enc.encode(t));
                return {
                    iv: btoa(String.fromCharCode(...iv)),
                    s: btoa(String.fromCharCode(...salt)),
                    d: btoa(String.fromCharCode(...new Uint8Array(sealedData)))
                };
            },
            async open(p, b) {
                const iv = Uint8Array.from(atob(b.iv), c => c.charCodeAt(0));
                const salt = Uint8Array.from(atob(b.s), c => c.charCodeAt(0));
                const data = Uint8Array.from(atob(b.d), c => c.charCodeAt(0));
                const key = await this.kdf(p, salt);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, data);
                return this.dec.decode(decrypted);
            },
            async hmac(s, m) {
                const key = await crypto.subtle.importKey('raw', this.enc.encode(s), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const signature = await crypto.subtle.sign('HMAC', key, this.enc.encode(m));
                return Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        },
        indicators: {
            sma(a, n) { if (a.length < n) return null; let s = 0; for (let i = a.length - n; i < a.length; i++) s += a[i]; return s / n; },
            rsi(v, p = 14) {
                if (v.length <= p) return null;
                let g = 0, l = 0;
                for (let i = 1; i <= p; i++) { const d = v[i] - v[i - 1]; d >= 0 ? g += d : l -= d; }
                let ag = g / p, al = l / p;
                for (let i = p + 1; i < v.length; i++) {
                    const d = v[i] - v[i - 1], G = d > 0 ? d : 0, L = d < 0 ? -d : 0;
                    ag = (ag * (p - 1) + G) / p;
                    al = (al * (p - 1) + L) / p;
                }
                return 100 - 100 / (1 + ag / (al || 1e-12));
            },
            trArr(H, L, C) { const o = []; let pc = C[0]; for (let i = 0; i < H.length; i++) { o.push(Math.max(H[i] - L[i], Math.abs(H[i] - pc), Math.abs(L[i] - pc))); pc = C[i]; } return o; },
            median(a) { const b = [...a].sort((x, y) => x - y), m = Math.floor(b.length / 2); return b.length % 2 ? b[m] : (b[m - 1] + b[m]) / 2; },
        },
        strategy: {
            pullbackScore(kl) {
                const C = kl.map(k => k.c), H = kl.map(k => k.h), L = kl.map(k => k.l);
                const { sma, rsi, trArr, median } = BybitBotApp.utils.indicators;
                const ema20 = sma(C, 20), ema50 = sma(C, 50);
                if (ema20 == null || ema50 == null) return { score: 0 };
                const last = C[C.length - 1], prev = C[C.length - 2], r = rsi(C, 14) || 0;
                let s = 0;
                if (ema20 > ema50) s += 2;
                if (last > ema20) s += 1;
                if (r > 52) s += 1;
                if (prev < ema20 && last > ema20) s += 2;
                const tr = trArr(H, L, C).slice(-30), atr = median(tr);
                return { score: s, atr, last };
            },
            calcTPSL(e, a, t, s) {
                const p = e + t * a, l = Math.max(e - s * a, 1e-9);
                return { tp: +p.toFixed(8), sl: +l.toFixed(8), rr: +(p - e) / (e - l || 1e-9) };
            }
        },
        precision: {
            __precToStep(x) {
                if (x == null) return null;
                const s = String(x).trim();
                if (s.includes('e-')) return Math.pow(10, -Number(s.split('e-')[1]));
                if (s.includes('.'))  return Number(s);
                const n = Number(s);
                if (!isNaN(n) && Number.isInteger(n) && n >= 0) return Math.pow(10, -n);
                return null;
            },
            __dec(step) {
                const s = String(step);
                return s.includes('e-') ? Number(s.split('e-')[1]) : (s.split('.')[1]?.length || 0);
            },
            stepOf(info) {
                const ls = info?.lotSizeFilter || {};
                return this.__precToStep(ls.qtyStep) ?? this.__precToStep(ls.basePrecision) ?? 1e-8;
            },
            tickOf(info) {
                const pf = info?.priceFilter || {};
                return this.__precToStep(pf.tickSize) ?? this.__precToStep(pf.pricePrecision) ?? 1e-8;
            },
            quoteStepOf(info) {
                const ls = info?.lotSizeFilter || {};
                // N·∫øu kh√¥ng c√≥ quotePrecision, fallback 0.01 ƒë·ªÉ kh√¥ng ‚Äúdecimal too long‚Äù
                return this.__precToStep(ls.quotePrecision) ?? 1e-2;
            },
            floorStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.floor(xi / si) * si;
                return ri / scale;
            },
            ceilStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.ceil(xi / si) * si;
                return ri / scale;
            },
            // qty (base)
            fmtQty(q, step) {
                const dec = this.__dec(step);
                const floored = this.floorStep(q, step);
                if (floored < step) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            // amount (quote USDT) cho marketUnit='quoteCoin'
            fmtAmt(a, qstep) {
                const dec = this.__dec(qstep);
                const floored = this.floorStep(a, qstep);
                if (floored < qstep) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            // price formatted to tick precision
            fmtPrice(p, tick) {
                const dec = this.__dec(tick);
                const snapped = this.floorStep(p, tick);
                return snapped.toFixed(dec);
            },
            snapUp(p, tick)   { return this.floorStep(+p + +tick, tick); },
            snapDown(p, tick) { return this.floorStep(+p, tick); },
        }
    },

    // --- Bybit API Module ---
    api: {
        balanceCache: { ts: 0, free: 0, acct: 'AUTO' },
        async withApiQueue(fn) {
            const { state } = BybitBotApp;
            const prev = state.apiQueue;
            let release;
            state.apiQueue = new Promise(res => (release = res));
            try { await prev; return await fn(); } finally { release(); }
        },
        
        buildUrl(p, q) {
            const { DOMElements, config, utils } = BybitBotApp;
            const proxy = DOMElements.proxy.value.trim();
            const baseUrl = config.values.useTestnet ? 'https://api-testnet.bybit.com' : 'https://api.bybit.com';
            const qstr = (typeof q === 'string') ? q : (q && Object.keys(q).length ? utils.canonQS(q) : '');
            const u = baseUrl + p + (qstr ? ('?' + qstr) : '');
            return (proxy ? proxy.replace(/\/$/, '') + '/' : '') + u;
        },

        async sign(method, path, qs = {}, body = null) {
            return this.withApiQueue(async () => {
                const { config, state, ui, utils } = BybitBotApp;
                await this.syncTime();
                const apiKey = config.values.apiKey.trim();
                const apiSecret = config.values.apiSecret.trim();
                if (!apiKey || !apiSecret) throw new Error('Thi·∫øu API');

                const attempt = async (rwVal) => {
                    const rw = String(rwVal);
                    const ts = this.tsNow();
                    let url, payloadStr = '';

                    if (method === 'GET') {
                        payloadStr = utils.canonQS(qs);
                        url = this.buildUrl(path, payloadStr);
                    } else {
                        // Bybit V5: body string ph·∫£i ƒë√∫ng JSON kh√¥ng kho·∫£ng tr·∫Øng d∆∞
                        payloadStr = body ? JSON.stringify(body) : '';
                        url = this.buildUrl(path, '');
                    }
                    // SignType=2: HMAC-SHA256-HEX(ts + apiKey + recvWindow + query/body)
                    const sign = await utils.crypto.hmac(apiSecret, `${ts}${apiKey}${rw}${payloadStr}`);
                    const headers = { 'X-BAPI-API-KEY': apiKey, 'X-BAPI-TIMESTAMP': ts, 'X-BAPI-RECV-WINDOW': rw, 'X-BAPI-SIGN-TYPE': '2', 'X-BAPI-SIGN': sign };
                    if (method === 'POST') headers['Content-Type'] = 'application/json';

                    const resp = await fetch(url, { method, headers, body: (method === 'POST' && payloadStr) ? payloadStr : undefined });
                    if (resp.status === 403) BybitBotApp.DOMElements.corsWarn.style.display = 'block';
                    
                    const data = await resp.json().catch(() => ({ retCode: -1, retMsg: 'Non-JSON' }));
                    if (!resp.ok || data.retCode !== 0) {
                        const err = new Error(`HTTP ${resp.status} ‚Äì ${data.retMsg || 'ERR'} (${data.retCode})`);
                        err.retCode = data.retCode; err.msg = data.retMsg;
                        throw err;
                    }
                    return data.result;
                };

                try {
                    return await attempt(this.suggestedRecvWindow());
                } catch (e) {
                    if ([10001, 10002, 10004].includes(e.retCode) || /recvWindow|timestamp|Signature/i.test(e.msg || '')) {
                        ui.logLive(`API Error (${e.retCode}), ƒëang th·ª≠ l·∫°i...`, 'warn');
                        await this.syncTime(true);
                        return await attempt(this.suggestedRecvWindow() + 5000);
                    }
                    throw e;
                }
            });
        },

        async syncTime(force = false) {
            const { time } = BybitBotApp.state;
            if (!force && Date.now() - time.lastSync < 30000) return;
            try {
                const t0 = Date.now();
                const r = await fetch(this.buildUrl('/v5/market/time'));
                const j = await r.json();
                const t1 = Date.now();
                const srvMs = (j?.result?.timeNano ? Math.floor(Number(j.result.timeNano) / 1e6) : j?.result?.timeSecond ? Number(j.result.timeSecond) * 1000 : Number(j?.result?.time) || Date.parse(r.headers.get('date')) || t1);
                time.netRTT = Math.min(5000, Math.max(50, t1 - t0));
                time.serverOffset = srvMs - ((t0 + t1) / 2);
                time.lastSync = t1;
                BybitBotApp.ui.logLive(`ƒê·ªìng b·ªô th·ªùi gian: Offset=${time.serverOffset.toFixed(0)}ms, RTT=${time.netRTT}ms`, 'ok');
            } catch (e) {
                BybitBotApp.ui.logLive('Kh√¥ng ƒë·ªìng b·ªô ƒë∆∞·ª£c th·ªùi gian', 'warn');
            }
        },
        now() { return Date.now() + BybitBotApp.state.time.serverOffset; },
        nowSec() { return Math.floor(this.now()/1000); },
        tsNow() { const t = this.now(); const { time } = BybitBotApp.state; time.lastTs = t <= time.lastTs ? (time.lastTs + 1) : t; return String(Math.floor(time.lastTs)); },
        suggestedRecvWindow() { const { config } = BybitBotApp; const { netRTT } = BybitBotApp.state.time; const pad = 2 * netRTT + 1500; return Math.max(10000, +config.values.recvWindow || 5000, pad); },
        
        async pub(p, q = {}) { const r = await fetch(this.buildUrl(p, q)); if (r.status === 403 && !BybitBotApp.DOMElements.proxy.value.trim()) { BybitBotApp.DOMElements.corsWarn.style.display = 'block'; } return r.json(); },
        async klines(s, i = '5', l = 200) { const j = await this.pub('/v5/market/kline', { category: 'spot', symbol: s, interval: i, limit: l }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list.map(r => ({ t: +r[0], o: +r[1], h: +r[2], l: +r[3], c: +r[4], v: +r[5] })).reverse(); },
        async tickers() { const j = await this.pub('/v5/market/tickers', { category: 'spot' }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list; },
        async instruments(s) { const j = await this.pub('/v5/market/instruments-info', { category: 'spot', symbol: s }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list[0]; },
        async btcOk() { 
             try {
                // Lu√¥n 5m ƒë√∫ng nh∆∞ label
                const k = await this.klines('BTCUSDT', '5', 100);
                const C = k.map(k => k.c);
                const { sma, rsi } = BybitBotApp.utils.indicators;
                return sma(C, 20) > sma(C, 50) && rsi(C, 14) > 48;
             } catch { return true; }
        },
        
        // --- Order Placement (with precision & min rules) ---
        async __norms(symbol) {
            const i = await BybitBotApp.api.instruments(symbol);
            const pr = BybitBotApp.utils.precision;
            const tick = pr.tickOf(i), step = pr.stepOf(i);
            const minQty = +(i?.lotSizeFilter?.minOrderQty ?? 0) || 0;
            const minAmt = +(i?.lotSizeFilter?.minOrderAmt ?? 0) || 0; // quote min for marketUnit=quoteCoin
            const qstep = pr.quoteStepOf(i);
            return { i, pr, tick, step, minQty, minAmt, qstep };
        },
        async buy(symbol, quoteUSDT) {
            const n = await this.__norms(symbol);
            let q = Math.max(+quoteUSDT, n.minAmt || 0);
            // Chu·∫©n ho√° amount theo quotePrecision (qstep) ƒë·ªÉ tr√°nh 170148
            // N·∫øu sau khi floor < minAmt ‚Üí ceil l√™n ƒë√∫ng b·ªôi b∆∞·ªõc
            q = n.pr.floorStep(q, n.qstep);
            if (q < n.minAmt) q = n.pr.ceilStep(n.minAmt, n.qstep);
            const qtyStr = n.pr.fmtAmt(q, n.qstep);
            if (+qtyStr <= 0) throw new Error('Quote amount <= 0 sau khi l√†m tr√≤n');
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Buy', orderType: 'Market',
                marketUnit: 'quoteCoin', qty: qtyStr,
                orderLinkId: `buy_${symbol}_${Date.now()}`
            });
        },
        async sell(symbol, baseQty) {
            const n = await this.__norms(symbol);
            const qty = n.pr.fmtQty(baseQty, n.step);
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Sell', orderType: 'Market',
                marketUnit: 'baseCoin', qty, timeInForce: 'IOC',
                orderLinkId: `sell_${symbol}_${Date.now()}`
            });
        },
        async tp(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapUp(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 1,              // ‚Üë kh·ªõp khi gi√° tƒÉng v∆∞·ª£t
                    triggerBy: 'LastPrice',
                    triggerPrice: n.pr.fmtPrice(trig, n.tick),
                    qty,
                    orderLinkId: `tp_${symbol}_${Date.now()}`
                });
            } catch (e) {
                // Fallback sang OCO gi·∫£ l·∫≠p n·∫øu s√†n t·ª´ ch·ªëi StopOrder
                BybitBotApp.ui.logLive(`TP spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'tp', price: trig, qty };
            }
        },
        async sl(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapDown(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 2,              // ‚Üì kh·ªõp khi gi√° gi·∫£m xuy√™n th·ªßng
                    triggerBy: 'LastPrice',
                    triggerPrice: n.pr.fmtPrice(trig, n.tick),
                    qty,
                    orderLinkId: `sl_${symbol}_${Date.now()}`
                });
            } catch (e) {
                BybitBotApp.ui.logLive(`SL spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'sl', price: trig, qty };
            }
        },
        realtimeOrders: async (s) => await BybitBotApp.api.sign('GET', '/v5/order/realtime', { category: 'spot', symbol: s }),
        async cancelAll(symbol) {
            const { state, ui } = BybitBotApp;
            if (state.cancelLock || state.isStopping) return;
            state.cancelLock = true;
            clearTimeout(state.cancelTimer);
            try { await this.syncTime(true); await this.sign('POST', '/v5/order/cancel-all', {}, { category: 'spot', symbol }); } 
            catch (e) { ui.logLive('Hu·ª∑ l·ªánh th·∫•t b·∫°i: ' + e.message, 'warn'); } 
            finally { state.cancelTimer = setTimeout(() => { state.cancelLock = false; }, 800); }
        },
        async usdtFreeBalance(force=false) {
            const { config } = BybitBotApp;
            const now = Date.now();
            // cache 10s
            if (!force && now - this.balanceCache.ts < 10_000 && this.balanceCache.free >= 0) {
              return this.balanceCache;
            }
            const pref = (config.values.balanceAcct || 'AUTO').toUpperCase();
            const tryOrder = pref === 'AUTO' ? ['SPOT','UNIFIED'] : [pref];

            for (const acct of tryOrder) {
              try {
                const r = await BybitBotApp.api.sign('GET', '/v5/account/wallet-balance', { accountType: acct, coin: 'USDT' });
                const list = r?.list?.[0]?.coin || [];
                const usdt = list.find(c => c.coin === 'USDT');
                if (!usdt) continue;

                let free = 0;
                if (acct === 'SPOT' && usdt.free != null) {
                  free = +usdt.free;
                } else {
                  const wb = +usdt.walletBalance || 0;
                  const locked = +usdt.locked || 0;
                  free = Math.max(wb - locked, 0);
                }
                this.balanceCache = { ts: now, free: +free.toFixed(4), acct };
                return this.balanceCache;
              } catch (e) { /* continue to next account type */ }
            }
            throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c s·ªë d∆∞ USDT.');
          }
    },

    // --- OCO Emulation Module ---
    oco: {
      timer: null,
      async watch(symbol, baseQty, tpPrice, slPrice) {
        clearInterval(this.timer);
        this.timer = setInterval(async () => {
          try {
            const t = await BybitBotApp.api.pub('/v5/market/tickers', { category: 'spot', symbol });
            if (t.retCode !== 0) return;
            const last = +t.result.list[0].lastPrice;
            if (tpPrice && last >= tpPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] TakeProfit @ ${last} ‚Üí SELL`, 'ok');
              await BybitBotApp.api.sell(symbol, baseQty);
            } else if (slPrice && last <= slPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] StopLoss @ ${last} ‚Üí SELL`, 'warn');
              await BybitBotApp.api.sell(symbol, baseQty);
            }
          } catch {}
        }, 1500);
      },
      stop(){ clearInterval(this.timer); }
    },

    // --- WebSocket Module ---
    ws: {
        async connect() {
            try {
                if (BybitBotApp.state.ws.instance) { try { BybitBotApp.state.ws.instance.close() } catch {} }
                const { config, ui, api } = BybitBotApp;
                config.load(); // Ensure latest API keys are used
                const { apiKey, apiSecret } = config.values;
                if (!apiKey || !apiSecret) return ui.logLive('WS private: thi·∫øu API', 'warn');

                const url = config.values.useTestnet ? 'wss://stream-testnet.bybit.com/v5/private' : 'wss://stream.bybit.com/v5/private';
                
                const makeArgs = async () => {
                    const expires = api.now() + 10000; // 10 seconds expiry, in MS
                    const expiresStr = String(Math.floor(expires));
                    const sig = await BybitBotApp.utils.crypto.hmac(apiSecret, `GET/realtime${expiresStr}`);
                    return [apiKey, expiresStr, sig];
                };

                const ws = new WebSocket(url);
                BybitBotApp.state.ws.instance = ws;
                let lastPong = Date.now();

                ws.onopen = async () => {
                    ws.send(JSON.stringify({ op: 'auth', args: await makeArgs() }));
                    clearInterval(BybitBotApp.state.ws.ping);
                    BybitBotApp.state.ws.ping = setInterval(() => { try { ws.send(JSON.stringify({ op: 'ping' })); } catch {} }, 15000);
                    clearInterval(BybitBotApp.state.ws.watchdog);
                    BybitBotApp.state.ws.watchdog = setInterval(() => { if (Date.now() - lastPong > 45000) { ui.logLive('WS private: heartbeat timeout ‚Üí reconnect', 'warn'); try { ws.close(); } catch {} } }, 10000);
                };

                ws.onmessage = async ev => {
                    let msg; try { msg = JSON.parse(ev.data); } catch { return; }
                    if (msg.op === 'pong' || msg.ret_msg === 'pong') { lastPong = Date.now(); return; }
                    if (msg.op === 'auth') {
                        if (msg.success) {
                            BybitBotApp.state.ws.backoff = 3000;
                            ui.logLive('WS private: auth OK', 'ok');
                            ws.send(JSON.stringify({ op: 'subscribe', args: ['order'] }));
                            return;
                        }
                        ui.logLive(`WS private: auth failed (${msg.ret_msg})`, 'error');
                        try { ws.close(); } catch {}
                        return;
                    }
                    if (msg.topic === 'order') {
                        const { state, liveBot } = BybitBotApp;
                        const ds = msg.data || [];
                        const filledSell = ds.find(o => o.symbol === state.currentPosition.sym && o.side === 'Sell' && (o.orderStatus === 'Filled' || o.orderStatus === 'PartiallyFilled'));
                        if (filledSell) {
                            liveBot.handlePositionExit(filledSell.avgPrice, 'WS Fill');
                        }
                    }
                };
                
                const cleanup = () => {
                    clearInterval(BybitBotApp.state.ws.ping); BybitBotApp.state.ws.ping = null;
                    clearInterval(BybitBotApp.state.ws.watchdog); BybitBotApp.state.ws.watchdog = null;
                };

                ws.onclose = () => {
                    cleanup();
                    ui.logLive('WS private: closed', 'warn');
                    const { state, config } = BybitBotApp;
                    if (state.isRunning && !config.values.simMode) {
                        const d = Math.min(state.ws.backoff, 30000);
                        setTimeout(() => { state.ws.backoff = Math.min(state.ws.backoff * 1.7, 30000); this.connect(); }, d);
                    }
                };
                ws.onerror = () => { cleanup(); ui.logLive('WS private error', 'warn'); };

            } catch (e) {
                BybitBotApp.ui.logLive('M·ªü WS private l·ªói: ' + e.message, 'warn');
            }
        },
        disconnect() {
            const { state } = BybitBotApp;
            clearInterval(state.ws.ping); state.ws.ping = null;
            clearInterval(state.ws.watchdog); state.ws.watchdog = null;
            if (state.ws.instance) { try { state.ws.instance.close() } catch {}; state.ws.instance = null; }
        }
    },

    // --- Journal Module ---
    journal: {
        state: { date: '', loss: 0, pnl: 0, trades: [] },
        today: () => new Date().toISOString().slice(0, 10),
        load() {
            const j = localStorage.getItem('bb_journal_v6');
            this.state = j ? JSON.parse(j) : { date: this.today(), loss: 0, pnl: 0, trades: [] };
            if (this.state.date !== this.today()) this.reset();
            this.updateUI();
        },
        save() {
            localStorage.setItem('bb_journal_v6', JSON.stringify(this.state));
        },
        push(trade) {
            this.state.trades.unshift(trade);
            if (trade.pnl !== undefined) this.state.pnl += trade.pnl;
            if (trade.pnl < 0) this.state.loss += 1;
            else if (trade.pnl > 0) this.state.loss = 0;
            this.save();
            this.updateUI();
        },
        reset() {
            this.state = { date: this.today(), loss: 0, pnl: 0, trades: [] };
            this.save();
            this.updateUI();
            BybitBotApp.ui.logLive('ƒê√£ reset phi√™n giao d·ªãch.', 'ok');
        },
        updateUI() {
            const { DOMElements, ui } = BybitBotApp;
            DOMElements.lossStreak.textContent = this.state.loss;
            DOMElements.pnlDay.textContent = this.state.pnl.toFixed(2);
            ui.renderJournal('journalLive', this.state.trades);
        }
    },

    // --- Live Trading Bot ---
    liveBot: {
        async computeOrderQtyLive(symbol, fixedQuote) {
          const { api, utils, config } = BybitBotApp;
          const info = await api.instruments(symbol);
          const ls = info.lotSizeFilter || {};
          const minOrderAmt = +ls.minOrderAmt || 5;
          const step   = utils.precision.stepOf(info);
          const qstep  = utils.precision.quoteStepOf(info);

          // L·∫•y gi√° hi·ªán t·∫°i
          const kl = await api.klines(symbol, config.values.tf, 2);
          const price = kl[kl.length - 1].c;

          // --- NEW: quote theo balance ---
          let quote = fixedQuote;
          let capByFree = Infinity;
          if (config.values.useBalanceSizing) {
            try {
                const { free, acct } = await api.usdtFreeBalance(false);
                const pct   = Math.max(0, Math.min(+config.values.riskPct || 0, 100)) / 100;
                const minQ  = Math.max(+config.values.minQuote || 5, minOrderAmt);
                const maxQ  = Math.max(+config.values.maxQuote || minQ, minQ);
                const rz    = Math.max(+config.values.reserveUsd || 0, 0);

                const capByPct = free * pct;
                capByFree = Math.max(0, free - rz);
                // Target quote must respect min/max but DO NOT clamp down by free here
                // We'll validate against free after precision & min rules
                quote = Math.min(Math.max(capByPct, minQ), maxQ);
                if (!isFinite(quote) || quote <= 0) quote = minQ;

                BybitBotApp.ui.logLive(`[Sizing] acct=${acct} free=${free.toFixed(2)} ‚Üí quote=${quote.toFixed(2)} USDT`);
            } catch(e) {
                BybitBotApp.ui.logLive(`L·ªói sizing: ${e.message}. D√πng quote c·ªë ƒë·ªãnh.`, 'warn');
                quote = fixedQuote;
            }
          }

          // ƒê·ªïi ra s·ªë l∆∞·ª£ng base, √©p minQty & step
          let qty = utils.precision.floorStep(quote / price, step);
          const minQty = +(ls.minOrderQty || 0);
          if (minQty && qty < minQty) {
            const times = Math.ceil(minQty / step);
            qty = +(times * step).toFixed(8);
          }
          
          let finalQuote = qty * price;
          // R√†ng amount theo quote step ƒë·ªÉ kh√¥ng b·ªã ‚Äúdecimal too long‚Äù
          finalQuote = utils.precision.floorStep(finalQuote, qstep);
          if (finalQuote < minOrderAmt) {
              let qtyForMinAmt = Math.ceil(minOrderAmt / price / step) * step;
              qty = Math.max(qty, qtyForMinAmt);
              finalQuote = utils.precision.floorStep(qty * price, qstep);
              if (finalQuote < minOrderAmt) {
                  // Ceil l√™n m·ª©c min theo b·ªôi b∆∞·ªõc quote (nh·ªè, nh∆∞ng b·∫Øt bu·ªôc)
                  finalQuote = utils.precision.ceilStep(minOrderAmt, qstep);
              }
          }

          // If using balance sizing, ensure we actually have enough free USDT to place this order
          if (config.values.useBalanceSizing) {
              if (capByFree < minOrderAmt - 1e-8) {
                  BybitBotApp.ui.logLive(`Insufficient free USDT (< min order ${minOrderAmt}) ‚Üí b·ªè qua l·ªánh`, 'warn');
                  return { qty: 0, step, finalQuote: 0 };
              }
              if (finalQuote > capByFree + 1e-8) {
                  BybitBotApp.ui.logLive(`Insufficient balance for ${finalQuote.toFixed(2)} USDT (free ${capByFree.toFixed(2)}) ‚Üí b·ªè qua l·ªánh`, 'warn');
                  return { qty: 0, step, finalQuote: 0 };
              }
          }
          return { qty, step, finalQuote };
        },

        async start() {
            const { state, config, api, ui, liveBot, ws } = BybitBotApp;
            if (state.isRunning) return;
            config.load(); // Load latest UI settings
            if (config.values.autoResetStart) BybitBotApp.journal.reset();

            if (!config.values.simMode) {
                const apiKey = BybitBotApp.DOMElements.apiKey.value.trim();
                const apiSecret = BybitBotApp.DOMElements.apiSecret.value.trim();
                if (!apiKey || !apiSecret) return ui.logLive('Thi·∫øu API Key/Secret. Vui l√≤ng n·∫°p API tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.', 'error');
            }

            state.isRunning = true;
            state.isStopping = false;
            await api.syncTime(true);

            if (!config.values.simMode) {
                ws.connect();
            }
            
            ui.updateStatus('ƒêang ch·∫°y...');
            liveBot.scheduler();
            ui.logLive('Bot ƒë√£ b·∫Øt ƒë·∫ßu.', 'ok');
        },

        async stop() {
            const { state, ui, liveBot, ws, oco } = BybitBotApp;
            if (!state.isRunning) return;
            state.isStopping = true;
            state.isRunning = false;
            clearTimeout(state.timers.scheduler);
            if (state.isInPosition) await liveBot.gracefulExit();
            
            ws.disconnect();
            oco.stop(); // Ensure OCO watcher is stopped as well
            
            ui.updateStatus('ƒê√£ d·ª´ng', 'warn');
            ui.logLive('Bot ƒë√£ d·ª´ng.', 'warn');
            state.isStopping = false;
        },
        
        async gracefulExit() {
            const { state, api, ui, liveBot, ws, oco } = BybitBotApp;
            clearTimeout(state.timers.monitor);
            clearTimeout(state.timers.simMonitor);
            oco.stop();
            
            state.isInPosition = false;
            ui.updateStatus('Nh√†n r·ªói');
            if (state.currentPosition.sym && !BybitBotApp.config.values.simMode) {
                await api.cancelAll(state.currentPosition.sym);
            }
            state.currentPosition = {};
            ws.disconnect();
        },
        
        handlePositionExit(exitPrice, note = '') {
            const { state, journal, ui } = BybitBotApp;
            const baseQty = state.currentPosition.sellQty ?? state.currentPosition.qty;
            const pnl = (exitPrice - state.currentPosition.entry) * baseQty;
            ui.logLive(`‚úÖ ${note}: L·ªánh kh·ªõp @ ${exitPrice} ‚Üí PnL: ${pnl.toFixed(2)}$`, pnl > 0 ? 'ok' : 'bad');
            journal.push({
                ts: Date.now(),
                ...state.currentPosition,
                exit: +exitPrice,
                pnl,
                note
            });
            this.gracefulExit();
        },

        async step() {
            const { state, config, api, ui, journal, utils } = BybitBotApp;
            ui.updateStats(); // Update time
            if (journal.state.loss >= config.values.maxLossDay) return ui.updateStatus('T·∫°m d·ª´ng (Max Loss)', 'warn');
            if (state.isInPosition) return;
            
            try {
                // Find best symbol
                const symbols = config.values.symbolList.trim() ? config.values.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean) : await this.getUniverseLiveAlt();
                state.currentPosition.watching = symbols.slice(0, 6).join(',') + (symbols.length > 6 ? ' ...' : '');
                
                const btcOk = config.values.btcFilter ? await api.btcOk() : true;
                let dynMin = config.values.minScore;
                if (!btcOk) dynMin += 1;

                let best = null;
                for (const sym of symbols) {
                    try {
                        const kl = await api.klines(sym, config.values.tf, 200);
                        const s = utils.strategy.pullbackScore(kl);
                        // Add relative strength logic if BTC is not OK
                        if (!btcOk && kl.length >= 10) {
                             const C = kl.map(k=>k.c);
                             const btcKl = await api.klines('BTCUSDT', config.values.tf, 10);
                             const btcROC = (btcKl.at(-1).c - btcKl.at(-10).c) / btcKl.at(-10).c;
                             const roc = (C.at(-1) - C.at(-10)) / C.at(-10);
                             if (roc - btcROC > 0.01) s.score += 1; else s.score -= 1;
                        }
                        if (!best || s.score > best.meta?.score) best = { sym, meta: s };
                    } catch (e) {}
                }
                state.currentPosition.signal = best ? `${best.sym} ‚Ä¢ ƒêi·ªÉm ${best.meta.score}` : '‚Äî';
                ui.updateStats();
                
                if (!best || !config.values.autoMode || best.meta.score < dynMin) return;
                
                // Calculate TP/SL
                const tpsl = utils.strategy.calcTPSL(best.meta.last, best.meta.atr || best.meta.last * 0.005, config.values.B_tpK, config.values.B_slK);
                if (tpsl.rr < 1.2) return ui.logLive(`B·ªè qua ${best.sym}: R:R ${tpsl.rr.toFixed(2)}<1.2`, 'warn');
                
                // Calculate quantity
                const { qty, step, finalQuote } = await this.computeOrderQtyLive(best.sym, config.values.orderQuote);
                if (qty <= 0 || finalQuote <= 0) return ui.logLive('Kh√¥ng t√≠nh ƒë∆∞·ª£c s·ªë l∆∞·ª£ng h·ª£p l·ªá', 'warn');
                
                state.isInPosition = true;
                state.currentPosition = { sym: best.sym, entry: best.meta.last, tp: tpsl.tp, sl: tpsl.sl, ts: Date.now(), qty, quote: finalQuote, atr: best.meta.atr || best.meta.last * 0.005 };
                
                if (config.values.simMode) {
                    ui.updateStatus('[SIM] Trong v·ªã th·∫ø');
                    ui.logLive(`[SIM] BUY ${best.sym} @${best.meta.last.toFixed(6)} | TP=${tpsl.tp.toFixed(6)} SL=${tpsl.sl.toFixed(6)}`, 'ok');
                    this.simMonitor();
                    return;
                }
                
                ui.updateStatus('ƒêang mua...');
                const buyOrder = await api.buy(best.sym, finalQuote);
                ui.logLive(`ƒê√£ ƒë·∫∑t l·ªánh BUY ${best.sym} (id=${buyOrder.orderId})`, 'ok');
                ui.updateStatus('Trong v·ªã th·∫ø');
                await api.cancelAll(best.sym);
                
                // Get filled quantity and place OCO
                let filledQty = 0;
                try {
                    const orders = await api.realtimeOrders(best.sym);
                    const exec = orders?.list?.find(o => o.orderId === buyOrder.orderId);
                    filledQty = +(exec?.cumExecQty || 0);
                } catch (e) {}
                
                let sellQty = filledQty > 0 ? filledQty : qty;
                sellQty = utils.precision.floorStep(sellQty * 0.98, step);
                const info = await api.instruments(best.sym);
                state.currentPosition.sellQty = +utils.precision.fmtQty(sellQty, utils.precision.stepOf(info));
                
                if (config.values.useOCOEmu) {
                    const tpOrder = await api.tp(best.sym, state.currentPosition.sellQty, tpsl.tp);
                    const slOrder = await api.sl(best.sym, state.currentPosition.sellQty, tpsl.sl);
                    if (tpOrder.emu || slOrder.emu) {
                        ui.logLive(`K√≠ch ho·∫°t OCO gi·∫£ l·∫≠p cho ${best.sym}`, 'warn');
                        // Only watch for the side that failed. If TP failed, tpPrice is its trigger. If SL failed, slPrice is its trigger.
                        // If both succeed, tpPrice and slPrice will be null.
                        BybitBotApp.oco.watch(
                            best.sym,
                            state.currentPosition.sellQty,
                            tpOrder.emu ? tpOrder.price : null,
                            slOrder.emu ? slOrder.price : null
                        );
                    } else {
                        ui.logLive(`ƒê√£ ƒë·∫∑t OCO tr√™n s√†n v·ªõi qty=${state.currentPosition.sellQty}`, 'ok');
                    }
                }
                this.monitor();
            } catch (e) {
                ui.logLive('L·ªói trong chu tr√¨nh: ' + (e.message || e), 'error');
                state.isInPosition = false;
            }
        },

        monitor() {
            const { state, config, api, ui, ws, utils } = BybitBotApp;
            // If using reliable WS, no need for REST polling
            if (ws.instance && ws.instance.readyState === WebSocket.OPEN && config.values.useOCOEmu) return;

            clearInterval(state.timers.monitor);
            const startTime = Date.now();
            state.timers.monitor = setInterval(async () => {
                try {
                    const { currentPosition } = state;
                    const kl = await api.klines(currentPosition.sym, '1', 2);
                    const px = kl[kl.length - 1].c;

                    if (Date.now() - startTime > config.values.timeStopMin * 60 * 1000) {
                        ui.logLive('Time-stop, ƒëang tho√°t l·ªánh...', 'warn');
                        const qtyExit = currentPosition.sellQty || currentPosition.qty;
                        let soldOk = true;
                        try { await api.sell(currentPosition.sym, qtyExit); } catch (e) { soldOk = false; ui.logLive('L·ªói Market SELL: ' + e.message, 'warn'); }
                        if (soldOk) { this.handlePositionExit(px, 'Time-stop'); return; }
                    }

                    let newSl = currentPosition.sl, needsUpdate = false, isTrailing = false;
                    if (config.values.useBreakeven && !currentPosition.beLocked && px >= currentPosition.entry + 0.6 * currentPosition.atr) {
                        newSl = Math.max(currentPosition.sl, currentPosition.entry - 0.1 * currentPosition.atr);
                        if (newSl > currentPosition.sl) { currentPosition.beLocked = true; ui.logLive(`BE-lock: d·ªùi SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); needsUpdate = true; }
                    }
                    if (config.values.useTrailing && px >= currentPosition.tp) {
                        newSl = Math.max(newSl, px - 0.6 * currentPosition.atr);
                        if (newSl > currentPosition.sl) { ui.logLive(`Trailing SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); needsUpdate = true; isTrailing = true; }
                    }

                    if (needsUpdate && config.values.useOCOEmu) {
                        state.currentPosition.sl = newSl;
                        if (isTrailing) state.currentPosition.tp *= 1.05;
                        await api.cancelAll(currentPosition.sym);
                        const qtyToUse = currentPosition.sellQty || currentPosition.qty;
                        await api.tp(currentPosition.sym, qtyToUse, state.currentPosition.tp);
                        await api.sl(currentPosition.sym, qtyToUse, state.currentPosition.sl);
                    }
                } catch (e) { ui.logLive('L·ªói theo d√µi l·ªánh: ' + e.message, 'warn'); }
            }, 8000); // Poll less frequently
        },

        simMonitor() {
            const { state, config, ui } = BybitBotApp;
            clearInterval(state.timers.simMonitor);
            const tS = config.values.timeStopMin * 60 * 1000;
            const st = Date.now();
            let p = state.currentPosition.entry;
            state.timers.simMonitor = setInterval(() => {
                const { currentPosition } = state;
                const d = (Math.random() - .48) * currentPosition.atr * .2;
                p += d;
                const checkExit = (e, n) => {
                    this.handlePositionExit(e, 'SIM ' + n);
                };
                if (p >= currentPosition.tp) return checkExit(currentPosition.tp, 'TP hit');
                if (p <= currentPosition.sl) return checkExit(currentPosition.sl, 'SL hit');
                if (Date.now() - st > tS) return checkExit(p, 'Time-stop');
                if (config.values.useBreakeven && !currentPosition.beLocked && p >= currentPosition.entry + .6 * currentPosition.atr) {
                    currentPosition.sl = Math.max(currentPosition.sl, currentPosition.entry - .1 * currentPosition.atr);
                    currentPosition.beLocked = true;
                    ui.logLive('[SIM] BE Lock: SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
                if (config.values.useTrailing && p > currentPosition.tp) {
                    currentPosition.sl = Math.max(currentPosition.sl, p - .6 * currentPosition.atr);
                    ui.logLive('[SIM] Trailing SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
            }, 1500);
        },
        
        async getUniverseLiveAlt() {
            const { api, config } = BybitBotApp;
            const list = await api.tickers();
            const EX = new Set(['BTCUSDT', 'ETHUSDT', 'USDCUSDT', 'FDUSDUSDT', 'TUSDUSDT']);
            let cands = list
                .filter(x => x.symbol.endsWith('USDT') && !EX.has(x.symbol))
                .filter(x => +x.turnover24h > 50_000_000)
                .filter(x => +x.lastPrice < 10);
            const quote = config.values.orderQuote;
            const out = [];
            for (const it of cands.slice(0, 80)) {
                try {
                    const info = await api.instruments(it.symbol);
                    const minAmt = +(info.lotSizeFilter?.minOrderAmt || 5);
                    if (minAmt <= quote) out.push(it.symbol);
                    if (out.length >= 30) break;
                } catch {}
            }
            return out.length ? out : cands.slice(0, 30).map(x => x.symbol);
        },
        
        async scheduler() {
            const { state } = BybitBotApp;
            if (!state.isRunning) return;
            await this.step();
            const delay = this.nextCandleDelayMs();
            state.timers.scheduler = setTimeout(() => this.scheduler(), delay);
        },
        
        nextCandleDelayMs() {
            const n = BybitBotApp.api.now();
            const tfSec = { '1': 60, '3': 180, '5': 300, '15': 900 }[BybitBotApp.config.values.tf] || 300;
            const tfMs = tfSec * 1000;
            const delta = (Math.ceil(n / tfMs) * tfMs) - n;
            let wait = BybitBotApp.config.values.scanSec * 1000;
            if (delta < 12000) wait = Math.min(wait, 4000);
            if (delta < 5000) wait = Math.min(wait, 2000);
            return Math.max(1500, wait);
        }
    },

    // --- Backtester Module ---
    backtester: {
        pnlChartInstance: null,

        async run(isGridSearch = false, gridParams = null) {
            const { config, ui, api, DOMElements } = BybitBotApp;
            config.load();

            ui.logBack('B·∫Øt ƒë·∫ßu Backtest...', 'ok');
            DOMElements.B_run.disabled = true;
            DOMElements.B_grid.disabled = true;
            DOMElements.autopilot.disabled = true;
            DOMElements.logBack.innerHTML = '';
            DOMElements.journalBack.querySelector('tbody').innerHTML = '';
            DOMElements.bySymBack.querySelector('tbody').innerHTML = '';
            DOMElements.B_summary.textContent = 'ƒêang ch·∫°y...';

            try {
                const params = gridParams || {
                    tf: String(config.values.B_tf), lookback: config.values.B_lookback, topN: config.values.B_topN,
                    symbolList: config.values.B_symbolList, btcFilter: config.values.B_btcFilter,
                    pessimistic: config.values.B_pessimistic, minScore: config.values.B_minScore,
                    tpK: config.values.B_tpK, slK: config.values.B_slK,
                    timeStopMin: config.values.B_timeStopMin, quote: config.values.B_quote,
                    feePct: config.values.B_feePct, slipBps: config.values.B_slipBps,
                    useBreakeven: config.values.B_useBreakeven, useTrailing: config.values.B_useTrailing
                };

                let symbols;
                if (params.symbolList.trim()) {
                    symbols = params.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean);
                } else {
                    ui.logBack(`ƒêang t√¨m ${params.topN} coin c√≥ volume cao nh·∫•t...`);
                    const tickers = await api.tickers();
                    symbols = tickers
                        .filter(t => t.symbol.endsWith('USDT') && !/BTC|ETH|USDC|FDUSD|TUSD/.test(t.symbol))
                        .sort((a, b) => +b.turnover24h - +a.turnover24h)
                        .slice(0, params.topN)
                        .map(t => t.symbol);
                }
                ui.logBack(`Backtest tr√™n c√°c symbols: ${symbols.join(', ')}`);

                let btcData = null;
                if (params.btcFilter) {
                    ui.logBack('ƒêang t·∫£i d·ªØ li·ªáu BTC filter...');
                    btcData = await api.klines('BTCUSDT', '5', Math.max(200, params.lookback));
                }

                const allTrades = [];
                for (const sym of symbols) {
                    ui.logBack(`ƒêang x·ª≠ l√Ω ${sym}...`);
                    try {
                        const klines = await api.klines(sym, params.tf, params.lookback);
                        const trades = this.runSymbol(sym, klines, params, btcData);
                        allTrades.push(...trades);
                    } catch (e) {
                        ui.logBack(`L·ªói khi x·ª≠ l√Ω ${sym}: ${e.message}`, 'error');
                    }
                }

                allTrades.sort((a, b) => a.ts - b.ts);
                
                if (isGridSearch) {
                    const totalPnl = allTrades.reduce((sum, t) => sum + t.pnl, 0);
                    return { pnl: totalPnl, trades: allTrades.length };
                }

                this.generateReport(allTrades, params);

            } catch (e) {
                ui.logBack(`Backtest th·∫•t b·∫°i: ${e.message}`, 'error');
                DOMElements.B_summary.textContent = `L·ªói: ${e.message}`;
            } finally {
                DOMElements.B_run.disabled = false;
                DOMElements.B_grid.disabled = false;
                DOMElements.autopilot.disabled = false;
            }
        },

        runSymbol(symbol, klines, params, btcData) {
            const trades = [];
            let inPosition = false;
            let currentTrade = {};
            const { strategy, indicators } = BybitBotApp.utils;
            const tfMs = (params.tf || 5) * 60 * 1000;

            const isBtcOk = (timestamp) => {
                if (!params.btcFilter || !btcData) return true;
                const btcCandleIndex = btcData.findIndex(k => k.t >= timestamp);
                if (btcCandleIndex < 50) return false;
                const btcSlice = btcData.slice(0, btcCandleIndex + 1);
                const C = btcSlice.map(k => k.c);
                return indicators.sma(C, 20) > indicators.sma(C, 50) && indicators.rsi(C, 14) > 48;
            };

            for (let i = 50; i < klines.length; i++) {
                const currentCandle = klines[i];
                const historicalSlice = klines.slice(0, i + 1);

                if (inPosition) {
                    let exitPrice = null, exitNote = '';
                    const slHit = currentCandle.l <= currentTrade.sl, tpHit = currentCandle.h >= currentTrade.tp;
                    if (slHit && tpHit && params.pessimistic) { exitPrice = currentTrade.sl; exitNote = 'SL Hit (Pessimistic)'; }
                    else if (slHit) { exitPrice = currentTrade.sl; exitNote = 'SL Hit'; }
                    else if (tpHit) { exitPrice = currentTrade.tp; exitNote = 'TP Hit'; }

                    if (!exitPrice && (currentCandle.t - currentTrade.ts) / tfMs > params.timeStopMin / params.tf) {
                        exitPrice = currentCandle.c; exitNote = 'Time-stop';
                    }

                    if (!exitPrice) {
                        if (params.useBreakeven && !currentTrade.beLocked && currentCandle.h >= currentTrade.entry + 0.6 * currentTrade.atr) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentTrade.entry); currentTrade.beLocked = true;
                        }
                        if (params.useTrailing && currentCandle.h >= currentTrade.tp) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentCandle.c - 0.6 * currentTrade.atr);
                            currentTrade.tp = currentCandle.c + (currentTrade.initialTp - currentTrade.entry);
                        }
                    }

                    if (exitPrice) {
                        inPosition = false;
                        currentTrade.exit = exitPrice; currentTrade.note = exitNote;
                        const slip = params.slipBps / 10000, fee = params.feePct / 100;
                        const entryCost = currentTrade.qty * currentTrade.entry * (1 + fee + slip);
                        const exitValue = currentTrade.qty * currentTrade.exit * (1 - fee - slip);
                        currentTrade.pnl = exitValue - entryCost;
                        trades.push(currentTrade);
                    }
                }

                if (!inPosition) {
                    const signal = strategy.pullbackScore(historicalSlice);
                    if (signal.score >= params.minScore && isBtcOk(currentCandle.t)) {
                        const entryPrice = currentCandle.c;
                        const tpsl = strategy.calcTPSL(entryPrice, signal.atr, params.tpK, params.slK);
                        if (tpsl.rr >= 1.2) {
                            inPosition = true;
                            currentTrade = {
                                ts: currentCandle.t, sym: symbol, entry: entryPrice, tp: tpsl.tp, sl: tpsl.sl,
                                initialSl: tpsl.sl, initialTp: tpsl.tp, atr: signal.atr, qty: params.quote / entryPrice, beLocked: false,
                            };
                        }
                    }
                }
            }
            return trades;
        },

        generateReport(trades, params) {
            const { ui, DOMElements } = BybitBotApp;
            ui.renderJournal('journalBack', [...trades].reverse());

            if (trades.length === 0) {
                DOMElements.B_summary.textContent = 'Kh√¥ng c√≥ trade n√†o ƒë∆∞·ª£c th·ª±c hi·ªán.';
                this.drawPnlChart([]);
                return;
            }
            
            const bySymbol = {};
            trades.forEach(t => {
                if (!bySymbol[t.sym]) bySymbol[t.sym] = { trades: 0, wins: 0, pnl: 0, sumR: 0 };
                bySymbol[t.sym].trades++; bySymbol[t.sym].pnl += t.pnl;
                const initialRisk = (t.entry - t.initialSl) * t.qty;
                bySymbol[t.sym].sumR += initialRisk > 0 ? t.pnl / initialRisk : 0;
                if (t.pnl > 0) bySymbol[t.sym].wins++;
            });

            const bySymBody = DOMElements.bySymBack.querySelector('tbody'); bySymBody.innerHTML = '';
            Object.entries(bySymbol).forEach(([sym, data]) => {
                bySymBody.innerHTML += `<tr><td>${sym}</td><td>${data.trades}</td><td>${(data.wins/data.trades*100).toFixed(1)}%</td><td class="${data.pnl>0?'ok':'bad'}">${data.pnl.toFixed(2)}</td><td>${(data.sumR/data.trades).toFixed(2)}</td></tr>`;
            });

            const totalPnl = trades.reduce((s, t) => s + t.pnl, 0), wins = trades.filter(t=>t.pnl>0).length, losses = trades.length - wins;
            const grossP = trades.filter(t=>t.pnl>0).reduce((s,t)=>s+t.pnl,0), grossL = Math.abs(trades.filter(t=>t.pnl<0).reduce((s,t)=>s+t.pnl,0));
            
            let equity=[1000], maxEquity=1000, maxDD=0;
            [...trades].sort((a,b)=>a.ts-b.ts).forEach(t => {
                const newEquity = equity[equity.length - 1] + t.pnl;
                equity.push(newEquity); maxEquity = Math.max(maxEquity, newEquity);
                maxDD = Math.max(maxDD, (maxEquity - newEquity) / maxEquity);
            });

            DOMElements.B_summary.textContent = `
K·∫øt qu·∫£ Backtest
----------------------------------
T·ªïng PnL      : ${totalPnl.toFixed(2)} USDT
T·ªïng s·ªë Trades : ${trades.length}
T·ª∑ l·ªá th·∫Øng   : ${trades.length>0?(wins/trades.length*100).toFixed(1):0}% (${wins} W / ${losses} L)
Profit Factor : ${grossL>0?(grossP/grossL).toFixed(2):'‚àû'}
Max Drawdown  : ${(maxDD * 100).toFixed(2)}%`;

            this.drawPnlChart(trades);
        },

        drawPnlChart(trades) {
            if (this.pnlChartInstance) this.pnlChartInstance.destroy();
            const { DOMElements } = BybitBotApp;
            const ctx = DOMElements.pnlChart.getContext('2d');
            let cumulativePnl = 0;
            const equityData = [...trades].sort((a, b) => a.ts - b.ts).map(trade => ({ x: trade.ts, y: cumulativePnl += trade.pnl }));
            this.pnlChartInstance = new Chart(ctx, {
                type: 'line', data: { datasets: [{ label: 'Equity Curve (USDT)', data: equityData, borderColor: '#58a6ff', backgroundColor: 'rgba(88,166,255,0.1)', borderWidth: 2, pointRadius: 0, fill: true }] },
                options: { scales: { x: { type: 'time', time: { unit: 'day' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { grid: { color: 'rgba(255,255,255,0.1)' } } }, plugins: { legend: { display: false } } }
            });
        },

        async gridSearch() {
            const { ui, config, DOMElements } = BybitBotApp;
            ui.logBack('B·∫Øt ƒë·∫ßu Grid Search...', 'ok');
            DOMElements.B_run.disabled = true; DOMElements.B_grid.disabled = true; DOMElements.autopilot.disabled = true;

            const tpRange = [1.0, 1.2, 1.5, 2.0], slRange = [0.6, 0.8, 1.0, 1.2];
            let bestParams = null, bestPnl = -Infinity;
            const totalCombos = tpRange.length * slRange.length;

            for (const [i, tpK] of tpRange.entries()) {
                for (const [j, slK] of slRange.entries()) {
                    const count = i * slRange.length + j + 1;
                    ui.logBack(`[${count}/${totalCombos}] Testing TP=${tpK}, SL=${slK}...`);
                    config.load();
                    const backtestParams = {
                        ...Object.keys(config.values).filter(k=>k.startsWith('B_')).reduce((o,k)=>(o[k.slice(2)]=config.values[k],o),{}),
                        tf: String(config.values.B_tf), tpK: tpK, slK: slK, lookback: 300 // Use shorter lookback for speed
                    };
                    const result = await this.run(true, backtestParams);
                    ui.logBack(`‚Üí PnL: ${result.pnl.toFixed(2)} USDT, Trades: ${result.trades}`);
                    if (result.pnl > bestPnl) { bestPnl = result.pnl; bestParams = { tpK, slK }; }
                }
            }

            if (bestParams) {
                ui.logBack(`Grid Search ho√†n t·∫•t! T·ªët nh·∫•t: TP=${bestParams.tpK}, SL=${bestParams.slK} v·ªõi PnL ${bestPnl.toFixed(2)} USDT`, 'ok');
                DOMElements.B_tpK.value = bestParams.tpK; DOMElements.B_slK.value = bestParams.slK;
                DOMElements.B_tpK.dispatchEvent(new Event('change')); DOMElements.B_slK.dispatchEvent(new Event('change'));
            } else { ui.logBack('Grid Search kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£.', 'warn'); }
            
            DOMElements.B_run.disabled = false; DOMElements.B_grid.disabled = false; DOMElements.autopilot.disabled = false;
            return bestParams;
        },

        async runAutopilot() {
            const { DOMElements, ui, config, liveBot } = BybitBotApp;
            ui.logBack('üöÄ B·∫Øt ƒë·∫ßu Autopilot...', 'ok');
            document.querySelector('.tab[data-tab="back"]').click();

            const bestParams = await this.gridSearch();
            if (!bestParams) { ui.logLive('Autopilot d·ª´ng: kh√¥ng t√¨m ƒë∆∞·ª£c th√¥ng s·ªë t·ªëi ∆∞u.', 'error'); return; }

            ui.logLive('ƒê√£ t·ªëi ∆∞u th√¥ng s·ªë, ƒëang kh·ªüi ƒë·ªông live bot...', 'ok');
            config.load();

            const passphrase = prompt("Nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£ API keys cho Autopilot. B·ªè tr·ªëng ƒë·ªÉ ch·∫°y ·ªü ch·∫ø ƒë·ªô SIM mode.");
            DOMElements.simMode.checked = true;
            if (passphrase) {
                DOMElements.passphrase.value = passphrase;
                if (await config.loadApiKeys()) {
                    DOMElements.simMode.checked = false;
                    ui.logLive('API keys ƒë√£ n·∫°p. Ch·∫°y ch·∫ø ƒë·ªô REAL.', 'ok');
                } else ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'warn');
            } else ui.logLive('Kh√¥ng c√≥ passphrase. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'ok');

            DOMElements.autoMode.checked = true;
            [DOMElements.autoMode, DOMElements.simMode].forEach(el => el.dispatchEvent(new Event('change')));
            
            document.querySelector('.tab[data-tab="live"]').click();
            liveBot.start();
            ui.logLive('üöÄ Autopilot ƒë√£ kh·ªüi ƒë·ªông!', 'ok');
        }
    },

    // --- App Initialization ---
    init() {
        // Cache all DOM elements
        this.DOMElements = {};
        const allIds = [
            ...this.config.ids, 'status', 'watching', 'signal', 'lastUpdate', 'lossStreak', 'pnlDay',
            'logLive', 'journalLive', 'logBack', 'B_summary', 'pnlChart', 'journalBack', 'bySymBack',
            'start', 'stop', 'resetDay', 'saveKeys', 'loadKeys', 'clearKeys',
            'B_run', 'B_grid', 'autopilot', 'corsWarn', 'tab-live', 'tab-back', 'tab-help', 'usdtFree'
        ];
        allIds.forEach(id => this.DOMElements[id] = document.getElementById(id));

        // Setup UI
        const tabs = [...document.querySelectorAll('.tab')];
        const views = { live: this.DOMElements['tab-live'], back: this.DOMElements['tab-back'], help: this.DOMElements['tab-help'] };
        tabs.forEach(t => t.onclick = () => {
            tabs.forEach(x => x.classList.remove('active'));
            t.classList.add('active');
            Object.values(views).forEach(v => v.classList.remove('active'));
            views[t.dataset.tab].classList.add('active');
        });

        // Load config and journal
        this.config.loadFromStorage();
        this.journal.load();
        
        // Attach event listeners
        this.config.ids.forEach(id => {
            const el = this.DOMElements[id];
            if (el) el.addEventListener('change', () => {
                this.config.load();
                this.config.saveToStorage();
            });
        });
        
        this.DOMElements.saveKeys.onclick = () => this.config.saveApiKeys();
        this.DOMElements.loadKeys.onclick = () => this.config.loadApiKeys();
        this.DOMElements.clearKeys.onclick = () => this.config.clearApiKeys();
        this.DOMElements.resetDay.onclick = () => this.journal.reset();
        
        this.DOMElements.start.onclick = () => this.liveBot.start();
        this.DOMElements.stop.onclick = () => this.liveBot.stop();
        
        // Attach backtester listeners
        this.DOMElements.B_run.onclick = () => this.backtester.run();
        this.DOMElements.B_grid.onclick = () => this.backtester.gridSearch();
        this.DOMElements.autopilot.onclick = () => this.backtester.runAutopilot();
        
        if (this.config.values.autoRun) {
            this.liveBot.start();
        }
    }
};

// --- Start the application ---
window.addEventListener('DOMContentLoaded', () => BybitBotApp.init());

</script>
</body>
</html>

