<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <title>Bybit Browser Bot v7.0 (UI Polish) ‚Äî Autopilot ‚Ä¢ ALT Hunter</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    /* macOS-inspired light palette */
    :root{
      --bg:#f5f5f7;              /* macOS window background */
      --card:#ffffff;            /* surfaces */
      --line:#d2d2d7;            /* separators */
      --text:#1d1d1f;            /* primary */
      --muted:#6e6e73;           /* secondary */
      --ok:#34c759;              /* system green */
      --bad:#ff3b30;             /* system red */
      --warn:#ff9f0a;            /* system orange */
      --accent:#0a84ff;          /* system blue */
      --shadow:0 1px 3px rgba(0,0,0,0.06), 0 6px 16px rgba(0,0,0,0.06);
      --card-bg:linear-gradient(180deg, #ffffff 0%, #fafafa 100%);
      --control:#ffffff;
      --control-line:#d2d2d7;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1280px;margin:24px auto;padding:0 20px}
    h1{margin:0 0 12px;font-size:24px; font-weight: 500;}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
    .card{background:var(--card-bg);border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:var(--shadow)}
    .col-3{grid-column:span 3}.col-4{grid-column:span 4}.col-5{grid-column:span 5}.col-6{grid-column:span 6}.col-7{grid-column:span 7}.col-8{grid-column:span 8}.col-12{grid-column:span 12}
    @media (max-width: 992px) { .col-3, .col-4, .col-5 { grid-column: span 6; } }
    @media (max-width: 768px) { .col-3, .col-4, .col-5, .col-6, .col-7, .col-8 { grid-column: span 12; } }
    label{display:block;color:var(--muted);font-size:12px;margin:8px 0 6px; font-weight: 600;}
    input,select,textarea{width:100%;background:var(--control);border:1px solid var(--control-line);color:var(--text);border-radius:10px;padding:10px; transition: border-color 0.15s ease, box-shadow 0.15s ease;}
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px rgba(10,132,255,0.16);}
    input[type="checkbox"]{width:auto; accent-color: var(--accent);}    
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 12px;border-radius:999px;background:var(--control);border:1px solid var(--control-line);color:var(--text); cursor:pointer; font-size: 13px; box-shadow: var(--shadow);}
    .tiny{font-size:12px;color:var(--muted); opacity: 0.9;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--ok)}.bad{color:var(--bad)}.warn{color:var(--warn)}
    #logLive,#logBack{height:220px;overflow:auto;background:#fff;border:1px solid var(--line);border-radius:10px;padding:12px;white-space:pre-wrap; font-size: 13px; line-height: 1.6; box-shadow: var(--shadow);}
    table{width:100%;border-collapse:collapse;margin-top:8px;} th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left; font-size: 13px;} th {color: var(--muted); font-weight: 500;}
    .tabs{display:flex;gap:8px;margin:16px 0; border-bottom: 1px solid var(--line);}    
    .tab{padding:10px 16px;border:1px solid var(--control-line); border-bottom: 2px solid transparent; border-radius:10px 10px 0 0; color: var(--muted); cursor:pointer; transition: all 0.2s ease; margin-bottom: -1px; background:#fbfbfd;}
    .tab:hover { background: #fff; color: var(--text); }
    .tab.active{background:#fff; color:var(--text); border-bottom-color:var(--accent); box-shadow: var(--shadow);}    
    .tabview{display:none}.tabview.active{display:block}
    .btn{
        width:auto; padding: 10px 16px; font-weight: 600; cursor: pointer; border-radius: 10px;
        background: #ffffff; border: 1px solid var(--control-line); color: var(--text);
        transition: all 0.15s ease; box-shadow: var(--shadow);
    }
    .btn:hover:not(:disabled){background:#fefefe; border-color: var(--accent);}    
    .btn:disabled { opacity: 0.6; cursor: not-allowed;}
    button#start, button#B_run, button#autopilot { background: var(--accent); border-color: var(--accent); color: white; }
    button#start:hover:not(:disabled), button#B_run:hover:not(:disabled), button#autopilot:hover:not(:disabled) { filter: brightness(1.05); }
    button#stop { background: var(--bad); border-color: var(--bad); color: white;}
    button#stop:hover:not(:disabled) { filter: brightness(1.05); }

    /* Compact mode overrides */
    body.compact{font-size:13px}
    body.compact .wrap{max-width:1140px}
    body.compact .grid{gap:10px}
    body.compact .card{padding:10px;border-radius:10px}
    body.compact input, body.compact select, body.compact textarea{padding:8px;border-radius:8px}
    body.compact .pill{padding:5px 10px}
    body.compact .btn{padding:8px 12px;border-radius:8px}
    body.compact label{margin:6px 0 4px;font-size:11px}
    body.compact .tiny{font-size:11px}
    body.compact table th, body.compact table td{padding:6px 8px;font-size:12px}
    body.compact #logLive, body.compact #logBack{height:160px;padding:8px}
    body.compact .tab{padding:8px 12px}
    body.compact #liveStrategyChart{height:280px !important}

    /* Strategy chart sizing */
    .chart-box{
      position: relative;
      width: 100%;
      height: clamp(280px, 40vh, 380px);
      overflow: hidden;
      border-radius: 12px;
    }
    #liveStrategyChart{
      position: absolute; inset: 0;
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    @media (max-width: 768px){
      .chart-box{ height: 300px; }
    }
    /* an to√†n h∆°n n·ªØa: tr√°nh content v∆∞·ª£t khung card */
    .card{ overflow: hidden; }

    /* Collapsible cards (details/summary) */
    .card.collapse{ padding: 0; }
    .card.collapse>summary{ display:flex; align-items:center; gap:8px; padding:12px 14px; border-bottom:1px solid var(--line); cursor:pointer; font-weight:600; background:#fbfbfd; border-radius:12px 12px 0 0 }
    .card.collapse[open]>summary{ border-bottom-color: var(--accent); box-shadow: var(--shadow); }
    .card.collapse>summary::-webkit-details-marker{ display:none }
    .card.collapse>div{ padding:12px 16px }

    /* Tighter overall spacing in Live tab */
    #tab-live .grid{ gap:12px }
    body.compact #tab-live .grid{ gap:8px }

    /* PATCH 3 ‚Äî CSS helpers */
    .fixed-scroll{ max-height:360px; overflow:auto }
    .journal-clip{ max-height:360px; overflow:auto; background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px }
    @media (max-width: 992px){ .fixed-scroll,.journal-clip{ max-height:300px } }
    @media (max-width: 768px){ .fixed-scroll,.journal-clip{ max-height:360px } }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Bybit Browser Bot v7.0 <span class="tiny">‚Äî T·ªëi ∆∞u ho√° ‚Ä¢ Autopilot ‚Ä¢ ALT Hunter</span></h1>
  <div class="tabs">
    <div class="tab active" data-tab="live">‚ö° Live Bot</div>
    <div class="tab" data-tab="back">‚õè Backtester</div>
    <div class="tab" data-tab="radar">üìä Radar</div>
    <div class="tab" data-tab="news">üì∞ News</div>
    <div class="tab" data-tab="help">üß† Autopilot & Help</div>
  </div>

  <!-- LIVE TAB -->
  <section class="tabview active" id="tab-live">
    <div class="grid">
      <div class="card col-4">
        <b>1) API & Security</b>
        <label>API Key</label><input id="apiKey" placeholder="BYBITxxxx" autocomplete="off" spellcheck="false" />
        <label>API Secret</label><input id="apiSecret" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="off" spellcheck="false" />
        <label>Encryption Passphrase</label><input id="passphrase" type="password" placeholder="e.g., batman-2002" autocomplete="new-password" />
        <div class="row" style="margin-top:12px">
          <button id="saveKeys" class="btn">Save</button>
          <button id="loadKeys" class="btn">Load</button>
          <button id="clearKeys" class="btn">Clear</button>
        </div>
        <div class="row" style="margin-top:12px">
          <label class="pill"><input id="useTestnet" type="checkbox" checked> Testnet</label>
          <label class="pill"><input id="simMode" type="checkbox"> SIM mode</label>
          <label class="pill"><input id="autoRun" type="checkbox"> Auto‚Äërun</label>
          <label class="pill" title="Thu nh·ªè UI, gi·∫£m kho·∫£ng tr·ªëng"><input id="uiCompact" type="checkbox"> Compact UI</label>
        </div>
        <div class="tiny" style="margin-top:12px">‚ö†Ô∏è Spot trading only. Secrets are AES‚ÄëGCM encrypted with your passphrase and saved in local storage.</div>
        <div class="tiny warn" id="corsWarn" style="display:none;margin-top:6px">CORS error detected ‚Üí Use Testnet or a private Proxy.</div>
      </div>

      <div class="card col-8">
        <b>2) Strategy & Automation (Live)</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>USDT per Trade</label><input id="orderQuote" type="number" min="5" step="0.1" value="8"/></div>
          <div class="col-3"><label>Candle Timeframe</label><select id="tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-3"><label>Recv Window (ms)</label><input id="recvWindow" type="number" value="5000"/></div>
          <div class="col-3"><label>Proxy (optional)</label><input id="proxy" placeholder="https://your-worker.workers.dev" inputmode="url" spellcheck="false" autocomplete="off" /></div>
          <div class="col-12 row">
            <label class="pill"><input id="autoMode" type="checkbox"> Auto Buy</label>
            <label class="pill"><input id="btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
            <label class="pill"><input id="useTrailing" type="checkbox" checked> Trailing SL</label>
            <label class="pill"><input id="useBreakeven" type="checkbox" checked> Breakeven Lock</label>
            <label class="pill"><input id="useOCOEmu" type="checkbox" checked> Emulated OCO</label>
          </div>
          <div class="col-12 row">
            <label class="pill"><input id="useBalanceSizing" type="checkbox" checked> Use % Balance Sizing</label>
            <div style="width:110px"><label>Risk %</label><input id="riskPct" type="number" step="0.5" value="15"/></div>
            <div style="width:130px"><label>Reserve (USDT)</label><input id="reserveUsd" type="number" step="0.1" value="2"/></div>
            <div style="width:130px"><label>Min / Max (USDT)</label><input id="minQuote" type="number" step="0.1" value="5"/></div>
            <div style="width:110px"><label>&nbsp;</label><input id="maxQuote" type="number" step="0.1" value="25"/></div>
            <div style="width:160px"><label>Account Type</label>
              <select id="balanceAcct"><option value="AUTO" selected>AUTO</option><option value="SPOT">SPOT</option><option value="UNIFIED">UNIFIED</option></select>
            </div>
          </div>
          <div class="col-12"><label>Symbol List (CSV, empty = ALT Hunter)</label><input id="symbolList" placeholder="Leave empty for auto-selection of trending ALTs"/></div>
          <div class="row" style="gap:8px;align-items:flex-end">
            <div style="width:50%"><label>Whitelist (CSV)</label><input id="WL_symbols" placeholder="DOGEUSDT,SUIUSDT"/></div>
            <div style="width:50%"><label>Blacklist (CSV)</label><input id="BL_symbols" placeholder="PEPEUSDT,..."/></div>
          </div>
          <div class="col-3"><label>Min Signal Score (>=)</label><input id="minScore" type="number" value="5"/></div>
          <div class="col-3"><label>Time‚Äëstop (minutes)</label><input id="timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>Max Daily Losses</label><input id="maxLossDay" type="number" value="2"/></div>
          <div class="col-3"><label>Base Scan Interval (s)</label><input id="scanSec" type="number" value="20"/></div>
        </div>
        <div class="grid" style="margin-top:12px">
          <div class="col-12" style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px">
            <div><div class="tiny">Status</div><div id="status" class="ok">Idle</div></div>
            <div><div class="tiny">Watching</div><div id="watching">‚Äî</div></div>
            <div><div class="tiny">Signal</div><div id="signal">‚Äî</div></div>
            <div><div class="tiny">Last Update</div><div id="lastUpdate">‚Äî</div></div>
            <div><div class="tiny">Daily Losses</div><div id="lossStreak">0</div></div>
            <div><div class="tiny">Daily PnL</div><div id="pnlDay">0.00</div></div>
             <div><div class="tiny">USDT free</div><div id="usdtFree">‚Äî</div></div>
          </div>
        </div>
        <div class="row" style="margin-top:12px">
          <button id="start" class="btn" title="B·∫Øt ƒë·∫ßu ch·∫°y bot (Live ho·∫∑c SIM)">‚ñ∂ Start</button>
          <button id="stop" class="btn" title="D·ª´ng to√†n b·ªô ho·∫°t ƒë·ªông giao d·ªãch">‚ñ† Stop</button>
          <button id="resetDay" class="btn" title="Xo√° PnL v√† chu·ªói l·ªó c·ªßa phi√™n hi·ªán t·∫°i">‚ü≤ Reset Session</button>
          <button id="panicSell" class="btn" title="B√°n h·∫øt ngay l·∫≠p t·ª©c (Panic Sell)">‚ö† Panic Sell</button>
          <label class="pill" style="margin-left:auto;"><input id="autoResetStart" type="checkbox" checked> Auto-reset on start</label>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="col-12"><b>Advanced Filters</b></div>
          <div class="col-4"><label>MTF Confirm</label>
            <div class="row"><label class="pill"><input id="CO_mtfEnable" type="checkbox"> Enable</label>
              <div style="width:120px"><select id="CO_mtfTf"><option value="15">15m</option><option value="60">1h</option></select></div>
            </div>
          </div>
          <div class="col-4"><label>Regime Mode</label>
            <select id="CO_regimeMode"><option value="AUTO" selected>AUTO</option><option value="TREND">TREND</option><option value="MEANREV">MEANREV</option><option value="SIDEWAYS">SIDEWAYS</option></select>
          </div>
          <div class="col-4"><label>Time Window (local)</label>
            <div class="row">
              <input id="CO_winStart" type="time" value="00:00" style="width:120px">
              <input id="CO_winEnd" type="time" value="23:59" style="width:120px">
            </div>
          </div>
          <div class="col-4"><label>Cooldown after SL streak</label>
            <div class="row"><div style="width:110px"><input id="CO_slStreak" type="number" value="3" title="S·ªë SL li√™n ti·∫øp"/></div>
            <div style="width:140px"><input id="CO_coolMin" type="number" value="20" title="Cooldown (ph√∫t)"/></div></div>
          </div>
          <div class="col-4"><label>Spread Guard (bps)</label><input id="CO_maxSpreadBps" type="number" value="15" /></div>
          <div class="col-4"><label>Partial TP1</label>
            <div class="row"><label class="pill"><input id="CO_tp1Enable" type="checkbox"> Enable</label>
              <div style="width:120px"><input id="CO_tp1Frac" type="number" step="0.05" value="0.4" title="Fraction 0-1"/></div>
            </div>
          </div>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="col-12"><b>Chart Overlays</b></div>
          <label class="pill"><input id="OV_vwap" type="checkbox"> VWAP</label>
          <label class="pill"><input id="OV_bb" type="checkbox"> Bollinger Bands</label>
          <label class="pill"><input id="OV_vol" type="checkbox"> Volume</label>
        </div>
      </div>

      <div class="card col-12">
        <b>Live Log</b>
        <div id="logLive" role="log" aria-live="polite"></div>
      </div>
      <div class="card col-12">
        <b>Strategy View</b>
        <div class="chart-box" style="margin-top:10px">
          <canvas id="liveStrategyChart"></canvas>
        </div>
      </div>
      <div class="card col-12">
        <b>Journal & Performance (Live)</b>
        <table id="journalLive"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>Result/PnL</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="card col-12">
        <b>Telegram Alerts</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-4"><label>Bot Token</label><input id="tg-token" placeholder="123456:ABC-DEF..." autocomplete="off" spellcheck="false" /></div>
          <div class="col-4"><label>Chat ID</label><input id="tg-chatid" placeholder="-1001234..." autocomplete="off" spellcheck="false" /></div>
          <div class="col-4"><label>Test Message</label><input id="tg-msg" placeholder="Hello from Bybit Bot" autocomplete="off" spellcheck="false" /></div>
        </div>
        <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap">
          <button class="btn" id="btn-tg-validate" title="Ki·ªÉm tra token bot h·ª£p l·ªá">Validate Token</button>
          <button class="btn" id="btn-tg-detect" title="L·∫•y Chat ID t·ª± ƒë·ªông t·ª´ getUpdates (h√£y nh·∫Øn cho bot tr∆∞·ªõc)">Detect Chat ID</button>
          <button class="btn" id="btn-tg-send" title="G·ª≠i tin nh·∫Øn th·ª≠ t·ªõi Chat ID">Send Test</button>
          <label class="pill"><input class="bot-param" id="TG_onTrade" type="checkbox" checked> Notify on Entry/Exit</label>
          <label class="pill"><input class="bot-param" id="TG_onLifecycle" type="checkbox" checked> Notify on Start/Stop</label>
        </div>
        <div class="tiny" style="margin-top:6px; color:var(--muted)">G·ª£i √Ω: 1) B·∫•m Validate Token ‚Üí 2) Nh·∫Øn b·∫•t k·ª≥ cho bot ‚Üí 3) Detect Chat ID ‚Üí 4) Send Test.</div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-radar">
    <div class="grid">
      <div class="card col-12">
        <b>Momentum Radar (Top ALT theo ƒë·ªông l∆∞·ª£ng & thanh kho·∫£n)</b>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <div style="width:140px"><label>Top N</label><input id="R_topN" type="number" value="12" /></div>
          <div style="width:200px"><label>Min Turnover 1h (USDT)</label><input id="R_minTurnover" type="number" value="3000000" /></div>
          <div style="width:160px"><label>Max Price (USDT)</label><input id="R_maxPrice" type="number" value="10" /></div>
          <div style="width:140px"><label>Refresh (min)</label><input id="R_interval" type="number" value="5" /></div>
          <label class="pill"><input id="R_auto" type="checkbox"> Auto refresh</label>
          <button class="btn" id="R_scan" title="Qu√©t l·∫°i th·ªã tr∆∞·ªùng">üîÑ Scan</button>
          <div class="tiny" style="margin-left:auto; color:var(--muted)">M·∫πo: Ch·ªçn coin c√≥ %24h d∆∞∆°ng v√† turnover l·ªõn ‚Üí ƒë√† t·ªët h∆°n.</div>
        </div>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="RA_enable" type="checkbox"> B·∫≠t c·∫£nh b√°o bi·∫øn ƒë·ªông l·∫°</label>
          <div style="width:120px"><label>Lookback (min)</label><input id="RA_retMin" type="number" value="5" /></div>
          <div style="width:140px"><label>Ng∆∞·ª°ng Œî% (abs)</label><input id="RA_retPct" type="number" value="3" /></div>
          <div style="width:140px"><label>Vol spike (√ó)</label><input id="RA_volSpike" type="number" step="0.1" value="2" /></div>
          <div style="width:150px"><label>Cooldown (min)</label><input id="RA_coolMin" type="number" value="30" /></div>
        </div>
      </div>
      <div class="card col-12">
        <div id="radar-list" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px"></div>
      </div>
      <div class="card col-12">
        <b>Daily Market Report</b>
        <div class="row" style="margin-top:8px; gap:10px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="DR_enable" type="checkbox"> B·∫≠t b√°o c√°o t·ª± ƒë·ªông</label>
          <div style="width:160px"><label>Gi·ªù g·ª≠i (HH:MM)</label><input id="DR_time" type="time" value="09:00" /></div>
          <button class="btn" id="DR_send" title="T·∫°o & g·ª≠i b√°o c√°o ngay">üì§ Send Now</button>
          <div class="tiny" style="color:var(--muted)">S·∫Ω g·ª≠i qua Telegram n·∫øu token/chat ID h·ª£p l·ªá.</div>
        </div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-news">
    <div class="grid">
      <div class="card col-12">
        <b>Crypto News</b>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="NW_src_coindesk" type="checkbox" checked> CoinDesk</label>
          <label class="pill"><input id="NW_src_cointele" type="checkbox" checked> Cointelegraph</label>
          <label class="pill"><input id="NW_src_binance" type="checkbox"> Binance Blog</label>
          <div style="width:260px"><label>T·ª´ kho√° (CSV, v√≠ d·ª•: BTC,ETF)</label><input id="NW_keywords" placeholder="" /></div>
          <div style="width:120px"><label>Refresh (min)</label><input id="NW_interval" type="number" value="15" /></div>
          <label class="pill"><input id="NW_auto" type="checkbox"> Auto</label>
          <label class="pill"><input id="NW_forward" type="checkbox"> Forward Telegram</label>
          <button class="btn" id="NW_refresh">üîÑ Refresh now</button>
        </div>
      </div>
      <div class="card col-12">
        <div id="news-list" style="display:grid; grid-template-columns:repeat(2,1fr); gap:10px"></div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-back">
    <div class="grid">
      <div class="card col-5">
        <b>Backtester ‚Äì Data Configuration</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-4"><label>Candle Timeframe</label><select id="B_tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-4"><label>Lookback (candles)</label><input id="B_lookback" type="number" value="1000" /></div>
          <div class="col-4"><label>Top N Coins by Turnover</label><input id="B_topN" type="number" value="12" /></div>
          <div class="col-12"><label>Symbol List (CSV, empty = top N)</label><input id="B_symbolList" placeholder="BTCUSDT,ETHUSDT,SOLUSDT"/></div>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="pill"><input id="B_btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
          <label class="pill"><input id="B_pessimistic" type="checkbox" checked> Pessimistic fills (SL first)</label>
        </div>
      </div>
      <div class="card col-7">
        <b>Backtester ‚Äì Strategy & Fees</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>Min Score</label><input id="B_minScore" type="number" value="5"/></div>
          <div class="col-3"><label>TP = k√óATR</label><input id="B_tpK" type="number" step="0.1" value="1.2"/></div>
          <div class="col-3"><label>SL = k√óATR</label><input id="B_slK" type="number" step="0.1" value="0.8"/></div>
          <div class="col-3"><label>Time‚Äëstop (min)</label><input id="B_timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>USDT/Trade</label><input id="B_quote" type="number" step="0.1" value="8"/></div>
          <div class="col-3"><label>Taker Fee (%)</label><input id="B_feePct" type="number" step="0.01" value="0.10"/></div>
          <div class="col-3"><label>Slippage (bps)</label><input id="B_slipBps" type="number" step="0.1" value="2"/></div>
          <div class="col-3 row"><label class="pill"><input id="B_useBreakeven" type="checkbox" checked> BE Lock</label></div>
          <div class="col-9 row"><label class="pill"><input id="B_useTrailing" type="checkbox" checked> Trailing after TP</label></div>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="B_run" class="btn" title="Ch·∫°y backtest v·ªõi th√¥ng s·ªë hi·ªán t·∫°i">‚ñ∂ Backtest</button>
          <button id="B_grid" class="btn" title="T√¨m TP/SL t·ªëi ∆∞u b·∫±ng Grid Search">‚õè Grid Search</button>
          <button id="autopilot" class="btn" title="T·ªëi ∆∞u th√¥ng s·ªë r·ªìi kh·ªüi ƒë·ªông bot t·ª± ƒë·ªông">üöÄ Autopilot: Optimize ‚Üí Start</button>
        </div>
      </div>
      <div class="card col-12"><div id="logBack" role="log" aria-live="polite"></div></div>
      <div class="card col-12"><div id="B_summary" class="mono"></div></div>
      <div class="card col-12">
        <b>Equity Curve</b>
        <canvas id="pnlChart" style="margin-top: 10px;"></canvas>
      </div>
      <div class="card col-12">
        <b>Journal (Backtest)</b>
        <table id="journalBack"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>PnL($)</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="card col-12">
        <b>Result by Symbol (Backtest)</b>
        <table id="bySymBack"><thead><tr><th>Symbol</th><th>Trades</th><th>Win %</th><th>PnL($)</th><th>Avg R</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-help">
    <div class="card col-12">
      <b>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng & Autopilot</b>
      <ul>
        <li><b>Autopilot (üöÄ):</b> B·∫•m n√∫t "Autopilot: Optimize ‚Üí Start" ·ªü tab Backtester. Bot s·∫Ω:
          <ol>
            <li>Ch·∫°y <b>Grid Search</b> ƒë·ªÉ t√¨m b·ªô TP/SL t·ªëi ∆∞u (k√óATR).</li>
            <li>T·ª± ƒë·ªông <b>sao ch√©p</b> th√¥ng s·ªë t·ªëi ∆∞u sang tab Live.</li>
            <li>N·∫øu b·∫°n ƒë√£ l∆∞u API, bot s·∫Ω <b>h·ªèi passphrase</b> ƒë·ªÉ gi·∫£i m√£ v√† n·∫°p. N·∫øu th·∫•t b·∫°i/kh√¥ng c√≥ API, bot s·∫Ω ch·∫°y ·ªü <b>SIM mode</b>.</li>
            <li>B·∫≠t <b>Auto Buy</b> v√† <b>kh·ªüi ƒë·ªông</b> bot. (N·∫øu kh√¥ng ·ªü SIM, bot k·∫øt n·ªëi WebSocket ri√™ng t∆∞ ƒë·ªÉ ph√°t hi·ªán fill nhanh h∆°n).</li>
          </ol>
        </li>
        <li><b>ALT Hunter:</b> Khi ƒë·ªÉ tr·ªëng danh s√°ch m√£, bot ∆∞u ti√™n c√°c ALT c√≥ thanh kho·∫£n cao, gi√° th·∫•p ph√π h·ª£p v·ªën. Khi BTC y·∫øu, bot ∆∞u ti√™n ALT c√≥ s·ª©c m·∫°nh t∆∞∆°ng ƒë·ªëi t·ªët h∆°n BTC.</li>
        <li><b>Qu√©t th√¥ng minh:</b> T·ª± ƒë·ªông qu√©t nhanh (2‚Äì4s) g·∫ßn th·ªùi ƒëi·ªÉm ch·ªët n·∫øn v√† ch·∫≠m l·∫°i ·ªü gi·ªØa n·∫øn ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng, gi·∫£m t·∫£i API.</li>
        <li><b>B·∫£o v·ªá l·ªách th·ªùi gian (10001):</b> Bot ƒë·ªãnh k·ª≥ ƒë·ªìng b·ªô gi·ªù v·ªõi Bybit v√† t·ª± <b>retry 1 l·∫ßn</b> n·∫øu g·∫∑p l·ªói timestamp.</li>
        <li><b>Reset phi√™n:</b> Tu·ª≥ ch·ªçn "T·ª± reset khi b·∫Øt ƒë·∫ßu" (b·∫≠t m·∫∑c ƒë·ªãnh) s·∫Ω xo√° PnL/chu·ªói l·ªó c·ªßa phi√™n tr∆∞·ªõc m·ªói l·∫ßn Start.</li>
        <li><b>Quy tr√¨nh th·ªß c√¥ng:</b> 1Ô∏è‚É£ Backtest ‚Üí 2Ô∏è‚É£ Tinh ch·ªânh Live ‚Üí 3Ô∏è‚É£ N·∫°p API (n·∫øu trade th·∫≠t) ‚Üí 4Ô∏è‚É£ Start.</li>
        <li><b>Telegram (tu·ª≥ ch·ªçn):</b> B·∫•m <b>Validate Token</b> ƒë·ªÉ ki·ªÉm tra token, g·ª≠i tin nh·∫Øn cho bot r·ªìi b·∫•m <b>Detect Chat ID</b> ƒë·ªÉ ƒëi·ªÅn ID t·ª± ƒë·ªông, sau ƒë√≥ th·ª≠ <b>Send Test</b>.</li>
        <li>‚ö†Ô∏è <b>L∆∞u √Ω:</b> H√£y th·ª≠ ·ªü SIM/Testnet tr∆∞·ªõc. T·ª± ch·ªãu r·ªßi ro khi s·ª≠ d·ª•ng. Kh√¥ng d√πng API c√≥ quy·ªÅn r√∫t ti·ªÅn. N·∫øu g·∫∑p CORS, h√£y d√πng proxy ri√™ng (v√≠ d·ª• Cloudflare Worker).</li>
      </ul>
    </div>
    <div class="card col-12">
      <b>H·ªçc t·ª´ sai l·∫ßm (Post‚Äëmortem)</b>
      <div class="row" style="margin-top:8px; gap:10px; align-items:flex-end; flex-wrap:wrap">
        <div style="width:140px"><label>Lookback trades</label><input id="CO_lookback" type="number" value="30" /></div>
        <label class="pill"><input id="CO_sendTg" type="checkbox" checked> G·ª≠i nh·∫≠n x√©t qua Telegram</label>
        <label class="pill"><input id="CO_autoTune" type="checkbox"> T·ª± ƒëi·ªÅu ch·ªânh sau chu·ªói SL</label>
        <button class="btn" id="CO_analyze" title="Ph√¢n t√≠ch c√°c l·ªánh g·∫ßn ƒë√¢y v√† ƒë∆∞a ra nh·∫≠n x√©t">üìà Ph√¢n t√≠ch</button>
        <div class="tiny" style="color:var(--muted)">G·ª£i √Ω: N·∫øu SL li√™n ti·∫øp, gi·∫£m risk %, tƒÉng minScore ho·∫∑c time‚Äëstop.</div>
      </div>
      <div id="CO_out" class="tiny" style="margin-top:6px; white-space:pre-wrap; color:var(--muted)"></div>
    </div>
  </section>
</div>

<script>
// ================================================================================= //
//                            BYBIT BOT v7.0 SCRIPT START                            //
// ================================================================================= //

const BybitBotApp = {
    // --- App State ---
    state: {
        isRunning: false,
        isStopping: false,
        isInPosition: false,
        currentPosition: {},
        timers: {
            scheduler: null,
            monitor: null,
            simMonitor: null,
        },
        ws: {
            instance: null,
            ping: null,
            watchdog: null,
            backoff: 3000,
        },
        time: {
            serverOffset: 0,
            lastSync: 0,
            netRTT: 300,
            lastTs: 0,
        },
        cooldown: { bySym: {} },
        apiQueue: Promise.resolve(),
        cancelLock: false,
        cancelTimer: null,
    },

    // --- Momentum Radar ---
    radar: {
        timer: null,
        async scan(){
            try{
                const E = BybitBotApp.DOMElements; const api = BybitBotApp.api; const ind = BybitBotApp.utils.indicators; const cfg = BybitBotApp.config;
                const topN = Math.max(3, +E.R_topN.value || 12);
                const minTurn = Math.max(0, +E.R_minTurnover.value || 30_000_000);
                const maxPrice = Math.max(0.01, +E.R_maxPrice.value || 10);
                E['radar-list'].innerHTML = 'ƒêang qu√©t...';
                const t0 = performance.now();
                const tickers = await api.tickers();
                const list = tickers
                    .filter(t => t.symbol.endsWith('USDT'))
                    .filter(t => !BybitBotApp.filters.isPeggedSymbol(t.symbol))
                    .map(t => ({
                        ...t,
                        // x·∫•p x·ªâ turnover 1h t·ª´ 24h: chia 24 (ƒë·ªß nhanh, ch·∫•p nh·∫≠n sai s·ªë)
                        turnover1h: (+t.turnover24h || 0) / 24
                    }))
                    .filter(t => t.turnover1h >= minTurn)
                    .filter(t => +t.lastPrice <= maxPrice)
                    .map(t => ({
                        sym: t.symbol,
                        px: +t.lastPrice,
                        chg: +t.price24hPcnt * 100,
                        turn: +t.turnover1h
                    }))
                    .sort((a,b)=> (b.chg) - (a.chg))
                    .slice(0, topN);

                // Enrich with RSI14 and ATR%
                const tf = String((cfg.values && cfg.values.tf) || '5');
                for (const x of list) {
                    try{
                        const kl = await api.klines(x.sym, tf, 120);
                        const C = kl.map(k=>k.c), H = kl.map(k=>k.h), L = kl.map(k=>k.l);
                        const rsi = ind.rsi(C, 14);
                        const tr = ind.trArr(H, L, C);
                        const atr = ind.median(tr.slice(-14));
                        x.rsi = rsi != null ? +rsi.toFixed(1) : null;
                        x.atrp = C.length ? +((atr / C[C.length-1]) * 100).toFixed(2) : null;
                        // T√≠nh Œî% lookback ƒë·ªÉ ph√°t hi·ªán b·∫•t th∆∞·ªùng
                        const lookMin = Math.max(1, +BybitBotApp.DOMElements.RA_retMin?.value || 5);
                        const n = Math.min(kl.length-1, Math.ceil((lookMin) * (60 / (+tf||5))));
                        if (n >= 1) {
                            const base = kl.at(-(n+1)).c; const last = kl.at(-1).c;
                            x.retN = +(((last-base)/base)*100).toFixed(2);
                        }
                    }catch{ x.rsi = null; x.atrp = null; }
                }
                const dt = (performance.now()-t0).toFixed(0);
                const tfLabel = ({'1':'1m','3':'3m','5':'5m','15':'15m'})[tf] || (tf+'m');
                E['radar-list'].innerHTML = list.map(x => `
                    <div class="card" style="padding:12px">
                      <div style="display:flex;justify-content:space-between;align-items:center">
                        <div style="font-weight:600">${x.sym}</div>
                        <div class="${x.chg>=0?'ok':'bad'}">${x.chg.toFixed(2)}%</div>
                      </div>
                      <div class="tiny" style="margin-top:6px;color:var(--muted)">Gi√°: ${x.px} ‚Ä¢ Turnover1h: ${Math.round(x.turn/1e6)}M</div>
                      <div class="tiny" style="margin-top:4px;color:var(--muted)">RSI14(${tfLabel}): ${x.rsi??'‚Äî'} ‚Ä¢ ATR%: ${x.atrp??'‚Äî'} ‚Ä¢ Œî${BybitBotApp.DOMElements.RA_retMin?.value||5}m: ${x.retN??'‚Äî'}%</div>
                      <div class="row" style="margin-top:8px;gap:6px">
                        <button class="btn" title="Sao ch√©p v√†o danh s√°ch symbol Live" onclick="(function(){ const el=document.getElementById('symbolList'); const s=el.value.trim(); el.value = s? (s+','+'${x.sym}') : '${x.sym}'; el.dispatchEvent(new Event('change')); })()">+ Live</button>
                        <button class="btn" title="Backtest nhanh 1000 n·∫øn" onclick="(function(){ const el=document.getElementById('B_symbolList'); el.value='${x.sym}'; el.dispatchEvent(new Event('change')); document.getElementById('B_run').click(); })()">‚Ü∫ Backtest</button>
                      </div>
                    </div>`).join('');
                BybitBotApp.ui.logLive(`Radar scan: ${list.length} symbols in ${dt}ms`, 'ok');

                // G·ª≠i c·∫£nh b√°o k√®m nh·∫≠n x√©t ng·∫Øn
                if (BybitBotApp.DOMElements.RA_enable?.checked) {
                    const th = Math.abs(+BybitBotApp.DOMElements.RA_retPct.value || 3);
                    const coolMin = Math.max(1, +BybitBotApp.DOMElements.RA_coolMin.value || 30);
                    const abnormal = list.filter(x => x.retN != null && Math.abs(x.retN) >= th);
                    const coachText = BybitBotApp.coaching.analyzeRecentTrades(BybitBotApp.journal?.state?.trades||[]);
                    const coachShort = coachText.split('\n').slice(0,2).join(' ‚Ä¢ ');
                    for (const a of abnormal) {
                        const dir = a.retN>0 ? '‚ñ≤' : '‚ñº';
                        const msg = `[RADAR] ${a.sym} ${dir} ${a.retN}% / ${BybitBotApp.DOMElements.RA_retMin?.value||5}m | RSI14=${a.rsi??'‚Äî'} ATR%=${a.atrp??'‚Äî'}\nNh·∫≠n x√©t: ${coachShort}`;
                        await BybitBotApp.telegram.notify(msg);
                    }
                    // L∆∞u b·∫£n ghi coach report trong ng√†y
                    const dayKey = new Date().toISOString().slice(0,10);
                    const k = `bb_coach_reports_${dayKey}`;
                    try { const hist = JSON.parse(localStorage.getItem(k)||'[]'); hist.push({ ts: Date.now(), msg: coachText }); localStorage.setItem(k, JSON.stringify(hist).slice(0,200000)); } catch {}
                }
            }catch(e){
                (BybitBotApp.DOMElements['radar-list']||{}).innerHTML = `<div class="bad">L·ªói qu√©t: ${e.message}</div>`;
            }
        },
        startAuto(){
            const E = BybitBotApp.DOMElements; const min = Math.max(1, +E.R_interval.value || 5);
            this.stopAuto();
            this.scan();
            this.timer = setInterval(()=> this.scan(), min*60*1000);
            BybitBotApp.ui.logLive(`Radar auto-refresh: ${min} ph√∫t`, 'ok');
        },
        stopAuto(){ if (this.timer) { clearInterval(this.timer); this.timer = null; } }
    },

    // --- News Aggregator ---
    news: {
        timer: null,
        hints: [],
        getHints(){
            const now = Date.now();
            this.hints = (this.hints||[]).filter(h => h.expire > now);
            return Array.from(new Set(this.hints.map(h => h.sym)));
        },
        _parseTickers(s){
            if(!s) return [];
            const txt = s.toUpperCase();
            const out = new Set();
            (txt.match(/\$([A-Z0-9]{2,12})\b/g)||[]).forEach(m=>out.add(m.slice(1)));
            (txt.match(/\b([A-Z0-9]{2,12})USDT\b/g)||[]).forEach(m=>out.add(m.replace(/USDT$/,'')));
            (txt.match(/\b([A-Z0-9]{2,12})\/USDT\b/g)||[]).forEach(m=>out.add(m.split('/')[0]));
            ['USDT','USDC','FDUSD','TUSD','BUSD','USD','UST'].forEach(b=>out.delete(b));
            return [...out];
        },
        _updateHintsFromNews(items){
            const base = Math.max(5, +BybitBotApp.DOMElements.NW_interval?.value || 15);
            const ttlMin = base * 2;
            const expire = Date.now() + ttlMin*60*1000;
            const seen = new Set();
            for (const it of (items||[])){
                const ticks = this._parseTickers(it.title||'');
                for (const tk of ticks){
                    const sym = `${tk}USDT`;
                    if (seen.has(sym)) continue; seen.add(sym);
                    this.hints.push({ sym, expire });
                    BybitBotApp.ui.logLive(`News hint ‚Üí ${sym} (TTL ${ttlMin}m)`, 'ok');
                }
            }
            const uniq = new Map();
            this.hints.forEach(h => { if (h.expire > Date.now() && !uniq.has(h.sym)) uniq.set(h.sym, h); });
            this.hints = [...uniq.values()];
        },
        async fetchSource(url){
            const r = await fetch(url); const text = await r.text();
            const items = [];
            // Try RSS/Atom first
            if (/<rss|<feed/i.test(text)) {
                try{
                    const dom = new DOMParser().parseFromString(text, 'application/xml');
                    dom.querySelectorAll('item, entry').forEach(n => {
                        const title = (n.querySelector('title')?.textContent || '').trim();
                        const link = (n.querySelector('link')?.getAttribute('href') || n.querySelector('link')?.textContent || '').trim();
                        if (title && link) items.push({ title, link });
                    });
                }catch{}
            }
            if (!items.length) {
                // Fallback: naive anchor scrape
                const re = /<a[^>]+href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gi;
                const seen = new Set();
                let m; while((m=re.exec(text)) && items.length<40){
                    const href = m[1]; const title = m[2].replace(/<[^>]+>/g,'').trim();
                    if(!title||seen.has(title)) continue; seen.add(title);
                    items.push({ title, link: href });
                }
            }
            return items;
        },
        async fetchAll(){
            const E = BybitBotApp.DOMElements;
            const srcs = [];
            if (E.NW_src_coindesk?.checked) srcs.push('https://www.coindesk.com/arc/outboundfeeds/rss/?outputType=xml');
            if (E.NW_src_cointele?.checked) srcs.push('https://cointelegraph.com/rss');
            if (E.NW_src_binance?.checked) srcs.push('https://www.binance.com/en/blog/rss');
            const res = await Promise.allSettled(srcs.map(s=> this.fetchSource(s)));
            let items = res.flatMap(x=> x.status==='fulfilled' ? x.value : []);
            // Keyword filter
            const kw = (E.NW_keywords?.value||'').toUpperCase().split(',').map(s=>s.trim()).filter(Boolean);
            if (kw.length) items = items.filter(it => kw.some(k => it.title.toUpperCase().includes(k)));
            // Unique by title
            const seen=new Set(); items = items.filter(it => (it.title && !seen.has(it.title)) && seen.add(it.title));
            return items.slice(0, 20);
        },
        async render(){
            const E = BybitBotApp.DOMElements; E['news-list'].innerHTML = 'ƒêang t·∫£i tin...';
            try{
                const items = await this.fetchAll();
                E['news-list'].innerHTML = items.map(it=>`
                  <div class="card" style="padding:10px">
                    <div style="font-weight:600;">${BybitBotApp.utils.escapeHtml(it.title)}</div>
                    <div class="tiny"><a href="${it.link}" target="_blank">M·ªü li√™n k·∫øt</a></div>
                  </div>`).join('');
                try{ this._updateHintsFromNews(items); }catch{}
                if (BybitBotApp.DOMElements.NW_forward?.checked && items.length){
                    const msg = `[News] ${items.slice(0,3).map(i=>i.title).join(' | ')}`;
                    await BybitBotApp.telegram.notify(msg);
                }
            }catch(e){ E['news-list'].innerHTML = `<div class='bad'>L·ªói t·∫£i tin: ${e.message}</div>`; }
        },
        startAuto(){ const min = Math.max(1, +BybitBotApp.DOMElements.NW_interval?.value||15); this.stopAuto(); this.render(); this.timer = setInterval(()=>this.render(), min*60*1000); },
        stopAuto(){ if (this.timer){ clearInterval(this.timer); this.timer=null; } }
    },

    // --- Daily Market Report ---
    dailyReport: {
        timer: null,
        buildSummary(radarHtml){
            const E = BybitBotApp.DOMElements; const now = new Date();
            const top = Array.from((E['radar-list']||{}).children||[]).slice(0,6).map(el=>{
                const name = el.querySelector('div[style*="font-weight:600"]')?.textContent||'';
                const chg = el.querySelector('.ok,.bad')?.textContent||'';
                return `${name} ${chg}`;
            }).join(', ');
            return `B√°o c√°o ${now.toLocaleDateString()} ${now.toLocaleTimeString()}\nTop: ${top}\n${radarHtml?'' : ''}`;
        },
        async sendNow(){
            try{
                // Ensure radar list exists; do a quick scan if empty
                if (!BybitBotApp.DOMElements['radar-list']?.children?.length) {
                    await BybitBotApp.radar.scan();
                }
                const summary = this.buildSummary();
                const ok = await BybitBotApp.telegram.notify(summary);
                BybitBotApp.ui.logLive(ok? '‚úì ƒê√£ g·ª≠i b√°o c√°o ng√†y qua Telegram' : 'Kh√¥ng g·ª≠i ƒë∆∞·ª£c b√°o c√°o (thi·∫øu token/chatid?)', ok?'ok':'warn');
            }catch(e){ BybitBotApp.ui.logLive('B√°o c√°o l·ªói: '+e.message, 'warn'); }
        },
        start(){
            const E = BybitBotApp.DOMElements; this.stop();
            const hhmm = (E.DR_time?.value||'09:00').split(':');
            const h = Math.max(0, Math.min(23, +hhmm[0]||9));
            const m = Math.max(0, Math.min(59, +hhmm[1]||0));
            const schedule = ()=>{
                const now = new Date();
                const next = new Date(); next.setHours(h, m, 0, 0);
                if (next <= now) next.setDate(next.getDate()+1);
                const ms = next - now;
                this.timer = setTimeout(async ()=>{ try { await BybitBotApp.radar.scan(); await this.sendNow(); } finally { schedule(); } }, ms);
                BybitBotApp.ui.logLive(`Daily report scheduled at ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')} (will send in ${(ms/60000).toFixed(1)} min)`, 'ok');
            };
            schedule();
        },
        stop(){ if (this.timer) { clearTimeout(this.timer); this.timer = null; } }
    },

    // --- Coaching / Post-mortem ---
    coaching: {
        analyzeRecentTrades(trades){
            const out = [];
            if (!trades || trades.length === 0) { out.push('Ch∆∞a c√≥ d·ªØ li·ªáu trade.'); return out.join('\n'); }
            const recent = trades.slice(0, Math.max(5, Math.min(50, +BybitBotApp.DOMElements.CO_lookback?.value||30)));
            const wins = recent.filter(t=> (t.pnl||0) > 0), losses = recent.filter(t=> (t.pnl||0) < 0);
            const winrate = (wins.length/recent.length*100)||0;
            out.push(`T·ªïng ${recent.length} l·ªánh g·∫ßn nh·∫•t ‚Ä¢ Winrate=${winrate.toFixed(1)}%`);
            // chu·ªói SL d√†i nh·∫•t
            let streak=0, maxStreak=0; for (const t of recent){ if ((t.pnl||0)<0) { streak++; maxStreak=Math.max(maxStreak, streak); } else streak=0; }
            if (maxStreak>=3) out.push(`Chu·ªói SL t·ªëi ƒëa: ${maxStreak} ‚Üí c√¢n nh·∫Øc cooldown v√† tƒÉng minScore.`);
            // R:R trung b√¨nh
            const rr = recent.map(t=>{ const baseSl = (t.initialSl ?? (t.sl || t.entry)); const risk=(t.entry - baseSl)*t.qty; return risk>0? (t.pnl||0)/risk: null; }).filter(x=>x!=null);
            if (rr.length) out.push(`R:R trung b√¨nh ‚âà ${(rr.reduce((a,b)=>a+b,0)/rr.length).toFixed(2)}`);
            // theo symbol
            const bySym = {}; for (const t of recent){ const k=t.sym; bySym[k]=bySym[k]||{n:0,pnl:0}; bySym[k].n++; bySym[k].pnl+=(t.pnl||0); }
            const worst = Object.entries(bySym).sort((a,b)=>a[1].pnl-b[1].pnl)[0];
            if (worst && worst[1].pnl < 0) out.push(`Symbol y·∫øu nh·∫•t: ${worst[0]} (PnL ${(worst[1].pnl).toFixed(2)}) ‚Üí c√¢n nh·∫Øc lo·∫°i t·∫°m th·ªùi.`);
            // g·ª£i √Ω h√†nh ƒë·ªông
            if (winrate < 40) out.push('G·ª£i √Ω: tƒÉng minScore ho·∫∑c si·∫øt RR (kTp‚Üë/kSl‚Üë).');
            if (maxStreak >= 3) out.push('G·ª£i √Ω: b·∫≠t cooldown sau chu·ªói SL v√† gi·∫£m risk %.');
            return out.join('\n');
        },
        async run(){
            try{
                const J = BybitBotApp.journal?.state?.trades || [];
                const text = this.analyzeRecentTrades(J);
                const box = BybitBotApp.DOMElements.CO_out; if (box) box.textContent = text;
                if (BybitBotApp.DOMElements.CO_sendTg?.checked) await BybitBotApp.telegram.notify(`[Coach]\n${text}`);
                if (BybitBotApp.DOMElements.CO_autoTune?.checked) {
                    // v√≠ d·ª• t·ª± ƒë·ªông nh·ªè: khi SL streak>=3, tƒÉng minScore +1 trong phi√™n
                    const recent = J.slice(0, +BybitBotApp.DOMElements.CO_lookback?.value||30);
                    let st=0, ms=0; for (const t of recent){ if ((t.pnl||0)<0){ st++; ms=Math.max(ms,st); } else st=0; }
                    if (ms>=3) {
                        const E = BybitBotApp.DOMElements; const old = +E.minScore.value||5; E.minScore.value = old + 1; E.minScore.dispatchEvent(new Event('change'));
                        BybitBotApp.ui.logLive(`Auto-tune: tƒÉng Min Score ${old}‚Üí${old+1} do SL streak`, 'warn');
                    }
                }
            }catch(e){ BybitBotApp.ui.logLive('Coaching error: '+e.message,'warn'); }
        }
    },

    // --- DOM Elements Cache ---
    DOMElements: {},

    // --- Configuration ---
    config: {
        values: {},
        ids: [
            'apiKey', 'apiSecret', 'passphrase', 'useTestnet', 'simMode', 'autoRun',
            'orderQuote', 'tf', 'recvWindow', 'proxy', 'autoMode', 'btcFilter',
            'useTrailing', 'useBreakeven', 'useOCOEmu', 'symbolList', 'minScore',
            'timeStopMin', 'maxLossDay', 'scanSec', 'autoResetStart',
            'useBalanceSizing','riskPct','reserveUsd','minQuote','maxQuote','balanceAcct',
            'WL_symbols','BL_symbols',
            'B_tf', 'B_lookback', 'B_topN', 'B_symbolList', 'B_btcFilter', 'B_pessimistic',
            'B_minScore', 'B_tpK', 'B_slK', 'B_timeStopMin', 'B_quote', 'B_feePct', 'B_slipBps',
            'B_useBreakeven', 'B_useTrailing',
            // Telegram
            'tg-token','tg-chatid','TG_onTrade','TG_onLifecycle','TG_onStatus','TG_statusMin','TG_onRisk','TG_onErrors',
            // Advanced filters
            'CO_mtfEnable','CO_mtfTf','CO_regimeMode','CO_winStart','CO_winEnd','CO_slStreak','CO_coolMin','CO_maxSpreadBps','CO_tp1Enable','CO_tp1Frac'
            , 'OV_vwap','OV_bb','OV_vol','panicSell','uiCompact'
        ],
        
        load() {
            // Load from UI inputs into values object
            this.ids.forEach(id => {
                const el = BybitBotApp.DOMElements[id];
                if (!el) return;
                this.values[id] = el.type === 'checkbox' ? el.checked : (el.type === 'number' ? +el.value : el.value);
            });
        },

        saveToStorage() {
            const cfgToSave = {
                q: this.values.orderQuote, tf: this.values.tf, rw: this.values.recvWindow, p: this.values.proxy,
                am: this.values.autoMode, bf: this.values.btcFilter, ut: this.values.useTrailing,
                ub: this.values.useBreakeven, uo: this.values.useOCOEmu, sl: this.values.symbolList,
                ms: this.values.minScore, ts: this.values.timeStopMin, ml: this.values.maxLossDay,
                ss: this.values.scanSec, ar: this.values.autoRun, sm: this.values.simMode, ars: this.values.autoResetStart,
                bs: this.values.useBalanceSizing, rp: this.values.riskPct, rz: this.values.reserveUsd,
                mn: this.values.minQuote, mx: this.values.maxQuote, ba: this.values.balanceAcct,
                cx: !!this.values.uiCompact,
                // Telegram
                tg: {
                    t: this.values['tg-token'] || '',
                    c: this.values['tg-chatid'] || '',
                    nt: !!this.values['TG_onTrade'],
                    nl: !!this.values['TG_onLifecycle'],
                    ns: !!this.values['TG_onStatus'],
                    sm: +this.values['TG_statusMin'] || 30,
                    nr: !!this.values['TG_onRisk'],
                    ne: !!this.values['TG_onErrors']
                }
            };
            // v7 storage key (gi·ªØ backward-compat khi load)
            localStorage.setItem('bb_bot_config_v7', JSON.stringify(cfgToSave));
        },
        
        loadFromStorage() {
            const j = localStorage.getItem('bb_bot_config_v7') || localStorage.getItem('bb_bot_config_v6');
            if (!j) return;
            const c = JSON.parse(j);
            const { DOMElements } = BybitBotApp;
            DOMElements.orderQuote.value = c.q ?? 8;
            DOMElements.tf.value = c.tf ?? '5';
            DOMElements.recvWindow.value = c.rw ?? 5000;
            DOMElements.proxy.value = c.p ?? '';
            DOMElements.autoMode.checked = !!c.am;
            DOMElements.btcFilter.checked = c.bf !== false;
            DOMElements.useTrailing.checked = c.ut !== false;
            DOMElements.useBreakeven.checked = c.ub !== false;
            DOMElements.useOCOEmu.checked = c.uo !== false;
            DOMElements.symbolList.value = c.sl ?? '';
            DOMElements.minScore.value = c.ms ?? 5;
            DOMElements.timeStopMin.value = c.ts ?? 15;
            DOMElements.maxLossDay.value = c.ml ?? 2;
            DOMElements.scanSec.value = c.ss ?? 20;
            DOMElements.autoRun.checked = !!c.ar;
            DOMElements.simMode.checked = !!c.sm;
            DOMElements.autoResetStart.checked = c.ars !== false;
            if (DOMElements.uiCompact) DOMElements.uiCompact.checked = !!c.cx;

            DOMElements.useBalanceSizing.checked = c.bs !== false;
            DOMElements.riskPct.value   = c.rp ?? 15;
            DOMElements.reserveUsd.value= c.rz ?? 2;
            DOMElements.minQuote.value  = c.mn ?? 5;
            DOMElements.maxQuote.value  = c.mx ?? 25;
            DOMElements.balanceAcct.value = c.ba ?? 'AUTO';
            // Telegram
            if (c.tg) {
                if (DOMElements['tg-token']) DOMElements['tg-token'].value = c.tg.t || '';
                if (DOMElements['tg-chatid']) DOMElements['tg-chatid'].value = c.tg.c || '';
                if (DOMElements['TG_onTrade']) DOMElements['TG_onTrade'].checked = !!c.tg.nt;
                if (DOMElements['TG_onLifecycle']) DOMElements['TG_onLifecycle'].checked = !!c.tg.nl;
                if (DOMElements['TG_onStatus']) DOMElements['TG_onStatus'].checked = !!c.tg.ns;
                if (DOMElements['TG_statusMin']) DOMElements['TG_statusMin'].value = c.tg.sm ?? 30;
                if (DOMElements['TG_onRisk']) DOMElements['TG_onRisk'].checked = c.tg.nr !== false;
                if (DOMElements['TG_onErrors']) DOMElements['TG_onErrors'].checked = !!c.tg.ne;
            }
            
            this.load(); // Reload values from UI after setting them
        },

        async saveApiKeys() {
            const k = BybitBotApp.DOMElements.apiKey.value.trim();
            const s = BybitBotApp.DOMElements.apiSecret.value.trim();
            const p = BybitBotApp.DOMElements.passphrase.value;
            if (!k || !s || !p) return BybitBotApp.ui.logLive('Thi·∫øu API Key, Secret, ho·∫∑c Passphrase', 'error');
            
            const sealed = await BybitBotApp.utils.crypto.seal(p, s);
            localStorage.setItem('bb_bot_key_v7', k);
            localStorage.setItem('bb_bot_sec_v7', JSON.stringify(sealed));
            localStorage.setItem('bb_bot_testnet_v7', BybitBotApp.DOMElements.useTestnet.checked ? '1' : '0');
            BybitBotApp.ui.logLive('ƒê√£ m√£ ho√° & l∆∞u tr·ªØ API.', 'ok');
        },

        async loadApiKeys() {
            try {
                const p = BybitBotApp.DOMElements.passphrase.value;
                if (!p) return BybitBotApp.ui.logLive('Vui l√≤ng nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£.', 'warn');

                const k = localStorage.getItem('bb_bot_key_v7') || localStorage.getItem('bb_bot_key_v6');
                const b = localStorage.getItem('bb_bot_sec_v7') || localStorage.getItem('bb_bot_sec_v6');
                if (!k || !b) return BybitBotApp.ui.logLive('Kh√¥ng t√¨m th·∫•y API ƒë√£ l∆∞u.', 'warn');

                const s = await BybitBotApp.utils.crypto.open(p, JSON.parse(b));
                BybitBotApp.DOMElements.apiKey.value = k;
                BybitBotApp.DOMElements.apiSecret.value = s;
                BybitBotApp.DOMElements.useTestnet.checked = (localStorage.getItem('bb_bot_testnet_v7') || localStorage.getItem('bb_bot_testnet_v6')) === '1';
                BybitBotApp.ui.logLive('ƒê√£ gi·∫£i m√£ v√† n·∫°p API Secret.', 'ok');
                return true;
            } catch (e) {
                BybitBotApp.ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i: ' + e.message, 'error');
                return false;
            }
        },

        clearApiKeys() {
            ['bb_bot_key_v7','bb_bot_sec_v7','bb_bot_testnet_v7','bb_bot_key_v6','bb_bot_sec_v6','bb_bot_testnet_v6'].forEach(k=>localStorage.removeItem(k));
            BybitBotApp.ui.logLive('ƒê√£ xo√° API kh·ªèi tr√¨nh duy·ªát.', 'ok');
        }
    },

    // --- UI Update Module ---
    ui: {
        logLive(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logLive;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
            try{
                if (l==='error' && BybitBotApp.DOMElements['TG_onErrors']?.checked){
                    BybitBotApp.telegram.throttle(`err_${String(m).slice(0,50)}`, 60000, ()=>`[ERROR] ${m}`);
                }
            }catch{}
        },
        logBack(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logBack;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
        },
        updateStatus(text, level = 'ok') {
            const el = BybitBotApp.DOMElements.status;
            el.textContent = text;
            el.className = level;
        },
        updateStats() {
            const { DOMElements, api } = BybitBotApp;
            const { currentPosition } = BybitBotApp.state;
            DOMElements.lastUpdate.textContent = new Date().toLocaleTimeString();
            DOMElements.watching.textContent = currentPosition.watching || '‚Äî';
            DOMElements.signal.textContent = currentPosition.signal || '‚Äî';

            const bc = api.balanceCache;
            if (bc && bc.ts) DOMElements.usdtFree.textContent = (bc.free ?? 0).toFixed(2);
        },
        withinTimeWindow(){
            const s = BybitBotApp.DOMElements.CO_winStart?.value||'00:00';
            const e = BybitBotApp.DOMElements.CO_winEnd?.value||'23:59';
            const now = new Date();
            const cur = now.getHours()*60 + now.getMinutes();
            const toMin = t=>{ const [h,m]=t.split(':').map(x=>+x||0); return h*60+m; };
            const a = toMin(s), b = toMin(e);
            return a<=b ? (cur>=a && cur<=b) : (cur>=a || cur<=b);
        },
        renderJournal(logId, trades) {
            const table = BybitBotApp.DOMElements[logId];
            const body = table.querySelector('tbody');
            body.innerHTML = '';
            trades.slice(0, 200).forEach(r => {
                const pnlClass = r.pnl > 0 ? 'ok' : (r.pnl < 0 ? 'bad' : '');
                const note = BybitBotApp.utils.escapeHtml(r.note || '');
                const row = `
                    <td>${new Date(r.ts).toLocaleString()}</td>
                    <td>${r.sym}</td>
                    <td>${r.entry?.toFixed(6) || '-'}</td>
                    <td>${r.tp?.toFixed(6) || '-'}</td>
                    <td>${(logId === 'journalBack' ? r.initialSl : r.sl)?.toFixed(6) || '-'}</td>
                    <td>${r.exit?.toFixed(6) || '-'}</td>
                    <td class="${pnlClass}">${r.pnl?.toFixed(2) || '-'}</td>
                    <td>${note}</td>`;
                body.innerHTML += `<tr>${row}</tr>`;
            });
        },
        drawLiveStrategy(kl, emaF, emaS, overlay={}) {
            const E = BybitBotApp.DOMElements; if (!E.liveStrategyChart) return;
            const ctx = E.liveStrategyChart.getContext('2d');
            if (this.liveStratInstance) this.liveStratInstance.destroy();
            const labels = kl.map(k=>k.t);
            const price = kl.map(k=>k.c);

            // Gradient fill for price line
            const gradient = ctx.createLinearGradient(0, 0, 0, E.liveStrategyChart.clientHeight || 360);
            gradient.addColorStop(0, 'rgba(10,132,255,0.18)');
            gradient.addColorStop(1, 'rgba(10,132,255,0.00)');

            const ds = [
              { label:'Price', data: price.map((v,i)=>({x:labels[i], y:v})), borderColor:'#0a84ff', backgroundColor:gradient, fill:true, tension:0.25, borderWidth:2, pointRadius:0, order:3 },
              { label:'EMA20', data: emaF.map((v,i)=>({x:labels[i], y:v})), borderColor:'#34c759', tension:0.2, borderWidth:1.6, pointRadius:0, order:2 },
              { label:'EMA50', data: emaS.map((v,i)=>({x:labels[i], y:v})), borderColor:'#ff9f0a', tension:0.2, borderWidth:1.4, pointRadius:0, order:2 }
            ];
            try{
              if (BybitBotApp.DOMElements.OV_vwap?.checked){
                let sumPV=0, sumV=0; const vwap=[]; for(let i=0;i<kl.length;i++){ const p=(kl[i].h+kl[i].l+kl[i].c)/3; const v=kl[i].v||0; sumPV+=p*v; sumV+=v; vwap.push(sumV? sumPV/sumV : kl[i].c); }
                ds.push({ label:'VWAP', data:vwap.map((v,i)=>({x:labels[i], y:v})), borderColor:'#8e8e93', borderWidth:1, pointRadius:0, tension:0.2, order:1 });
              }
              if (BybitBotApp.DOMElements.OV_bb?.checked){
                const period=20; const std=(arr)=>{const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length);};
                const bbU=[], bbL=[]; for(let i=0;i<price.length;i++){ const w=price.slice(Math.max(0,i-period+1), i+1); const m=w.reduce((a,b)=>a+b,0)/w.length; const s=std(w); bbU.push(m+2*s); bbL.push(m-2*s);} 
                ds.push({ label:'BB Upper', data:bbU.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.35)', borderWidth:1, pointRadius:0, tension:0.15, order:1 });
                ds.push({ label:'BB Lower', data:bbL.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.35)', borderWidth:1, pointRadius:0, tension:0.15, order:1 });
              }
              if (BybitBotApp.DOMElements.OV_vol?.checked){
                const vols = kl.map(k=>k.v||0);
                ds.push({ type:'bar', yAxisID:'y2', label:'Volume', data: vols.map((v,i)=>({x:labels[i], y:v})), backgroundColor:'rgba(29,29,31,0.18)', borderWidth:0, order:0 });
              }
            }catch{}
            const tMin = labels[0], tMax = labels[labels.length-1];
            if (overlay.entry){ ds.push({ type:'scatter', label:'Entry', data:[{x: overlay.entry.t||tMax, y: overlay.entry.p}], borderColor:'#34c759', backgroundColor:'#34c759', pointRadius:4, showLine:false, order:4 }); }
            if (overlay.exits && overlay.exits.length){ ds.push({ type:'scatter', label:'Exit', data: overlay.exits.map(e=>({x:e.t||tMax, y:e.p})), borderColor:'#ff3b30', backgroundColor:'#ff3b30', pointRadius:4, showLine:false, order:4 }); }
            if (overlay.tp){ ds.push({ label:'TP', data:[{x:tMin,y:overlay.tp},{x:tMax,y:overlay.tp}], borderColor:'#34c759', borderDash:[6,4], pointRadius:0, order:1 }); }
            if (overlay.sl){ ds.push({ label:'SL', data:[{x:tMin,y:overlay.sl},{x:tMax,y:overlay.sl}], borderColor:'#ff3b30', borderDash:[6,4], pointRadius:0, order:1 }); }

            const crosshair = {
              id: 'xCrosshair',
              afterDatasetsDraw(chart) {
                const active = chart.tooltip?.getActiveElements?.() || [];
                if (!active.length) return;
                const x = active[0].element.x;
                const { ctx, chartArea: { top, bottom } } = chart;
                ctx.save();
                ctx.strokeStyle = 'rgba(10,132,255,0.25)';
                ctx.setLineDash([4,4]);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            };

            this.liveStratInstance = new Chart(ctx, {
              type:'line',
              data:{ datasets: ds },
              options:{
                parsing:false,
                responsive:true,
                maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                scales:{
                  x:{ type:'time', grid:{ color:'rgba(0,0,0,0.06)' }, ticks:{ color:'#6e6e73' } },
                  y:{ grid:{ color:'rgba(0,0,0,0.06)' }, ticks:{ color:'#6e6e73' } },
                  y2:{ display: ds.some(d=>d.yAxisID==='y2'), position:'right', grid:{ drawOnChartArea:false }, ticks:{ color:'#6e6e73' } }
                },
                plugins:{
                  legend:{ display:true, labels:{ usePointStyle:true, color:'#1d1d1f' } },
                  tooltip:{
                    mode:'index', intersect:false,
                    backgroundColor:'rgba(255,255,255,0.95)', titleColor:'#1d1d1f', bodyColor:'#1d1d1f', borderColor:'#d2d2d7', borderWidth:1,
                    callbacks:{
                      label(ctx){
                        const v = ctx.parsed.y;
                        const name = ctx.dataset.label || '';
                        if (ctx.dataset.yAxisID === 'y2') return `${name}: ${Math.round(v)}`;
                        return `${name}: ${(+v).toFixed(6)}`;
                      }
                    }
                  }
                }
              },
              plugins:[crosshair]
            });
        },
        reputationInit(){ BybitBotApp.reputation.load(); }
    },

    // --- Filters ---
    filters: {
        // Lo·∫°i coin neo gi√° fiat (ƒë·∫∑c bi·ªát USD)
        isPeggedSymbol(sym) {
            const base = String(sym || '').toUpperCase().replace(/USDT$/, '');
            const hard = new Set([
              'USDT','USDC','FDUSD','TUSD','BUSD','DAI','USDD','USDP','USDE',
              'FRAX','PYUSD','LUSD','SUSD','MIM','FEI','USDN','GUSD','USDX',
              'USDL','USDS','USDJ','USDB','USDX','EURS','EURT'
            ]);
            if (hard.has(base)) return true;
            if (/(^|[^A-Z])(USD|EUR)([^A-Z]|$)/.test(base)) return true;
            return false;
        }
    },

    // --- Utility Functions ---
    utils: {
        sleep(ms){ return new Promise(res => setTimeout(res, ms)); },
        canonQS(obj = {}) {
            const enc = v => encodeURIComponent(v == null ? '' : v);
            return Object.keys(obj).sort().map(k => `${k}=${enc(obj[k])}`).join('&');
        },
        escapeHtml(v){ const d=document.createElement('div'); d.textContent=String(v??''); return d.innerHTML; },
        crypto: {
            enc: new TextEncoder(),
            dec: new TextDecoder(),
            async kdf(p, s) {
                const baseKey = await crypto.subtle.importKey('raw', this.enc.encode(p), { name: 'PBKDF2' }, false, ['deriveKey']);
                return crypto.subtle.deriveKey({ name: 'PBKDF2', salt: s, iterations: 120000, hash: 'SHA-256' }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
            },
            async seal(p, t) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await this.kdf(p, salt);
                const sealedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, this.enc.encode(t));
                return {
                    iv: btoa(String.fromCharCode(...iv)),
                    s: btoa(String.fromCharCode(...salt)),
                    d: btoa(String.fromCharCode(...new Uint8Array(sealedData)))
                };
            },
            async open(p, b) {
                const iv = Uint8Array.from(atob(b.iv), c => c.charCodeAt(0));
                const salt = Uint8Array.from(atob(b.s), c => c.charCodeAt(0));
                const data = Uint8Array.from(atob(b.d), c => c.charCodeAt(0));
                const key = await this.kdf(p, salt);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, data);
                return this.dec.decode(decrypted);
            },
            async hmac(s, m) {
                const key = await crypto.subtle.importKey('raw', this.enc.encode(s), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const signature = await crypto.subtle.sign('HMAC', key, this.enc.encode(m));
                return Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        },
        indicators: {
            sma(a, n) { if (a.length < n) return null; let s = 0; for (let i = a.length - n; i < a.length; i++) s += a[i]; return s / n; },
            emaSeries(v, p){
                const out = []; if (!v || v.length===0) return out; const k = 2/(p+1);
                let prev = v[0]; out.push(prev);
                for (let i=1;i<v.length;i++){ prev = v[i]*k + prev*(1-k); out.push(prev); }
                return out;
            },
            rsi(v, p = 14) {
                if (v.length <= p) return null;
                let g = 0, l = 0;
                for (let i = 1; i <= p; i++) { const d = v[i] - v[i - 1]; d >= 0 ? g += d : l -= d; }
                let ag = g / p, al = l / p;
                for (let i = p + 1; i < v.length; i++) {
                    const d = v[i] - v[i - 1], G = d > 0 ? d : 0, L = d < 0 ? -d : 0;
                    ag = (ag * (p - 1) + G) / p;
                    al = (al * (p - 1) + L) / p;
                }
                return 100 - 100 / (1 + ag / (al || 1e-12));
            },
            trArr(H, L, C) { const o = []; let pc = C[0]; for (let i = 0; i < H.length; i++) { o.push(Math.max(H[i] - L[i], Math.abs(H[i] - pc), Math.abs(L[i] - pc))); pc = C[i]; } return o; },
            median(a) { const b = [...a].sort((x, y) => x - y), m = Math.floor(b.length / 2); return b.length % 2 ? b[m] : (b[m - 1] + b[m]) / 2; },
        },
        strategy: {
            pullbackScore(kl) {
                const C = kl.map(k => k.c), H = kl.map(k => k.h), L = kl.map(k => k.l);
                const { sma, rsi, trArr, median } = BybitBotApp.utils.indicators;
                const ema20 = sma(C, 20), ema50 = sma(C, 50);
                if (ema20 == null || ema50 == null) return { score: 0 };
                const last = C[C.length - 1], prev = C[C.length - 2], r = rsi(C, 14) || 0;
                let s = 0;
                if (ema20 > ema50) s += 2;
                if (last > ema20) s += 1;
                if (r > 52) s += 1;
                if (prev < ema20 && last > ema20) s += 2;
                const tr = trArr(H, L, C).slice(-30), atr = median(tr);
                return { score: s, atr, last };
            },
            // --- Pump Hunter (1m) ---
            // Tr·∫£ v·ªÅ null n·∫øu ch∆∞a ƒë·∫°t, ho·∫∑c {entry, sl, tp, atr, atrp, score, reasons[]}
            pumpHunterSignal(kl1m, opts = {}) {
                const o = Object.assign({
                    lookMin: 2,
                    retMinPct: 2.8,
                    volSpikeMin: 2.5,
                    tpK: 1.2,
                    slK: 0.6,
                    atrLen: 14
                }, opts);
                if (!kl1m || kl1m.length < 40) return null;
                const ind = BybitBotApp.utils.indicators;
                const C = kl1m.map(k=>k.c), H=kl1m.map(k=>k.h), L=kl1m.map(k=>k.l), V=kl1m.map(k=>k.v||0);
                const n = Math.max(1, o.lookMin);
                const base = C.at(-(n+1)); if (!base) return null;
                const last = C.at(-1);
                const retN = (last/base - 1) * 100;
                const vMean = V.slice(-21,-1).reduce((a,b)=>a+b,0)/Math.max(1, V.slice(-21,-1).length);
                const vSpike = vMean ? (V.at(-1) / vMean) : 0;
                const ema20 = ind.sma(C, 20), ema50 = ind.sma(C, 50);
                let sumPV=0, sumV=0, VW=[];
                for (let i=0;i<kl1m.length;i++){ const p=(H[i]+L[i]+C[i])/3; const v=V[i]; sumPV+=p*v; sumV+=v; VW.push(sumV? sumPV/sumV : C[i]); }
                const pulled  = C.at(-2) < VW.at(-2) || C.at(-2) < ema20;
                const reclaim = C.at(-1) > VW.at(-1) && C.at(-1) > C.at(-2);
                const upTrend = (ema20 && ema50) ? (ema20 > ema50) : (C.at(-1) > C.at(-5));
                const tr = ind.trArr(H, L, C).slice(-(o.atrLen));
                const atr = ind.median(tr) || (last*0.005);
                const atrp = atr / last * 100;
                let score = 0; const reasons=[];
                if (retN >= o.retMinPct){ score+=2; reasons.push(`Impulse ${retN.toFixed(2)}%`); }
                if (vSpike >= o.volSpikeMin){ score+=2; reasons.push(`Vol √ó${vSpike.toFixed(2)}`); }
                if (pulled){ score+=1; reasons.push('Pullback ok'); }
                if (reclaim){ score+=2; reasons.push('Reclaim VWAP'); }
                if (upTrend){ score+=1; reasons.push('Uptrend MAs'); }
                if (atrp > 3.5){ reasons.push('ATR% qu√° l·ªõn'); return null; }
                if (score < 5) return null;
                const entry = last;
                const sl1 = Math.min(L.at(-2), VW.at(-1) - o.slK*atr);
                const tpK = atrp < 0.5 ? Math.max(o.tpK, 1.4) : (atrp > 2.0 ? Math.min(o.tpK, 1.1) : o.tpK);
                const tp1 = entry + tpK*atr;
                const rr = (tp1 - entry) / Math.max(entry - sl1, 1e-9);
                if (rr < 1.2) reasons.push(`RR th·∫•p ${rr.toFixed(2)}`);
                return { entry, sl: sl1, tp: tp1, atr, atrp, score, reasons };
            },
            // --- Pump Hunter PRO (1m) ---
            pumpHunterPro(kl1m, opts={}){
                const o = Object.assign({ lookMin:2, retMinPct:2.8, volSpikeZ:1.8, rngZ:1.2, atrLen:14, tpK:1.2, slK:0.6, maxATRp:3.8 }, opts);
                if (!kl1m || kl1m.length < 70) return null;
                const I = BybitBotApp.utils.indicators, S = BybitBotApp.utils.stats;
                const C=kl1m.map(k=>k.c), H=kl1m.map(k=>k.h), L=kl1m.map(k=>k.l), V=kl1m.map(k=>k.v||0);
                const last=C.at(-1), base=C.at(-(o.lookMin+1)); if(!base) return null;
                const retN=(last/base-1)*100;
                const trArr = I.trArr(H,L,C);
                const volR = S.rolling(V,30).at(-2)||{m:1,s:1};
                const rngR = S.rolling(trArr,30).at(-2)||{m:1,s:1};
                const vZ = S.z(V.at(-1), volR.m, volR.s);
                const rZ = S.z(trArr.at(-1), rngR.m, rngR.s);
                let sumPV=0,sumV=0,VW=[]; for(let i=0;i<C.length;i++){ const p=(H[i]+L[i]+C[i])/3, v=V[i]; sumPV+=p*v; sumV+=v; VW.push(sumV?sumPV/sumV:C[i]); }
                const ema20=I.sma(C,20), ema50=I.sma(C,50);
                const pulled=(C.at(-2)<VW.at(-2)||C.at(-2)<ema20)&&(L.at(-2)<C.at(-2));
                const reclaim=C.at(-1)>VW.at(-1)&&C.at(-1)>C.at(-2);
                const upTrend=(ema20&&ema50)?(ema20>ema50):(C.at(-1)>C.at(-6));
                const atr = I.median(trArr.slice(-o.atrLen)) || (last*0.005);
                const atrp = atr/last*100; if (atrp>o.maxATRp) return null;
                let score=0, why=[];
                if (retN>=o.retMinPct){ score+=2; why.push(`Œî${o.lookMin}m ${retN.toFixed(2)}%`); }
                if (vZ>=o.volSpikeZ){ score+=2; why.push(`Vol z=${vZ.toFixed(2)}`); }
                if (rZ>=o.rngZ){ score+=1; why.push(`Range z=${rZ.toFixed(2)}`); }
                if (pulled){ score+=1; why.push('pullback ok'); }
                if (reclaim){ score+=2; why.push('reclaim VWAP'); }
                if (upTrend){ score+=1; }
                if (score<6) return null;
                const tpK = atrp<0.5?Math.max(o.tpK,1.4):(atrp>2.0?Math.min(o.tpK,1.1):o.tpK);
                const entry=last, sl=Math.min(L.at(-2), VW.at(-1)-o.slK*atr), tp1=entry+tpK*atr, tp2=entry+(tpK+0.5)*atr;
                const rr=(tp1-entry)/Math.max(entry-sl,1e-9);
                return { entry, sl, tp1, tp2, atr, atrp, score, why };
            },
            calcTPSL(e, a, t, s) {
                const p = e + t * a, l = Math.max(e - s * a, 1e-9);
                return { tp: +p.toFixed(8), sl: +l.toFixed(8), rr: +(p - e) / (e - l || 1e-9) };
            }
        },
        precision: {
            __precToStep(x) {
                if (x == null) return null;
                const s = String(x).trim();
                if (s.includes('e-')) return Math.pow(10, -Number(s.split('e-')[1]));
                if (s.includes('.'))  return Number(s);
                const n = Number(s);
                if (!isNaN(n) && Number.isInteger(n) && n >= 0) return Math.pow(10, -n);
                return null;
            },
            __dec(step) {
                const s = String(step);
                return s.includes('e-') ? Number(s.split('e-')[1]) : (s.split('.')[1]?.length || 0);
            },
            stepOf(info) {
                const ls = info?.lotSizeFilter || {};
                return this.__precToStep(ls.qtyStep) ?? this.__precToStep(ls.basePrecision) ?? 1e-8;
            },
            tickOf(info) {
                const pf = info?.priceFilter || {};
                return this.__precToStep(pf.tickSize) ?? this.__precToStep(pf.pricePrecision) ?? 1e-8;
            },
            quoteStepOf(info) {
                const ls = info?.lotSizeFilter || {};
                // N·∫øu kh√¥ng c√≥ quotePrecision, fallback 0.01 ƒë·ªÉ kh√¥ng "decimal too long"
                return this.__precToStep(ls.quotePrecision) ?? 1e-2;
            },
            floorStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.floor(xi / si) * si;
                return ri / scale;
            },
            ceilStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.ceil(xi / si) * si;
                return ri / scale;
            },
            // qty (base)
            fmtQty(q, step) {
                const dec = this.__dec(step);
                const floored = this.floorStep(q, step);
                if (floored < step) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            // amount (quote USDT) cho marketUnit='quoteCoin'
            fmtAmt(a, qstep) {
                const dec = this.__dec(qstep);
                const floored = this.floorStep(a, qstep);
                if (floored < qstep) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            snapUp(p, tick)   { return this.floorStep(+p + +tick, tick); },
            snapDown(p, tick) { return this.floorStep(+p, tick); },
        }
    },
    // --- Stats helpers ---
    stats: {
        mean(a){ return a.length ? a.reduce((s,x)=>s+x,0)/a.length : 0; },
        std(a){ const m=this.mean(a); return a.length ? Math.sqrt(a.reduce((s,x)=>s+(x-m)*(x-m),0)/a.length) : 0; },
        z(x, m, s){ return s ? (x-m)/s : 0; },
        rolling(arr, n){ const out=[]; for(let i=n;i<=arr.length;i++){ const w=arr.slice(i-n,i); out.push({m:this.mean(w), s:this.std(w)}); } return out; }
    },

    // --- Telegram ---
    telegram: {
        _throttle: new Map(), _hb: null,
        getRaw(){ const E = BybitBotApp.DOMElements; return { 
          t:(E['tg-token']?.value||'').trim(), 
          c:(E['tg-chatid']?.value||'').trim(),
          cfg: {
            onTrade: !!E['TG_onTrade']?.checked,
            onLife : !!E['TG_onLifecycle']?.checked,
            onStat : !!E['TG_onStatus']?.checked,
            statMin: Math.max(5, +E['TG_statusMin']?.value || 30),
            onRisk : !!E['TG_onRisk']?.checked,
            onErr  : !!E['TG_onErrors']?.checked
          }
        }; },
        async _send(text){
          try{
            const { t, c } = this.getRaw(); if(!t||!c) return false;
            const r = await fetch(`https://api.telegram.org/bot${t}/sendMessage`,{
              method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ chat_id:c, text, disable_web_page_preview:true })
            });
            const j = await r.json(); return !!j.ok;
          }catch{ return false; }
        },
        async sendTest(){ try{ const ok = await this._send(BybitBotApp.DOMElements['tg-msg']?.value || 'Test'); BybitBotApp.ui.logLive(ok?'‚úì Telegram test sent':'Send failed', ok?'ok':'warn'); }catch(e){ BybitBotApp.ui.logLive('Telegram error: '+e.message,'warn'); } },
        async notify(text){ return this._send(text); },
        async validate(){
            try{
                const { t } = this.getRaw(); if(!t) throw new Error('Missing token');
                const r = await fetch(`https://api.telegram.org/bot${t}/getMe`);
                const j = await r.json(); if(!j.ok) throw new Error(j.description||'Invalid token');
                BybitBotApp.ui.logLive(`‚úì Bot: @${j.result.username}`,'ok');
            }catch(e){ BybitBotApp.ui.logLive('Token invalid: '+e.message,'error'); }
        },
        async detectChatId(){
            try{
                const { t } = this.getRaw(); if(!t) throw new Error('Missing token');
                const r = await fetch(`https://api.telegram.org/bot${t}/getUpdates`);
                const j = await r.json(); if(!j.ok) throw new Error(j.description||'getUpdates failed');
                const upd = (j.result||[]).slice().reverse().find(u=>u.message?.chat?.id);
                if(!upd) throw new Error('No chat found. Send a message to the bot first.');
                const chatId = upd.message.chat.id;
                if (BybitBotApp.DOMElements['tg-chatid']) BybitBotApp.DOMElements['tg-chatid'].value = chatId;
                BybitBotApp.ui.logLive(`‚úì Detected Chat ID: ${chatId}`,'ok');
            }catch(e){ BybitBotApp.ui.logLive('Detect Chat ID failed: '+e.message,'warn'); }
        },
        async throttle(key, ms, buildMsg){
          const last = this._throttle.get(key)||0;
          const now = Date.now(); if (now - last < ms) return false;
          this._throttle.set(key, now);
          const msg = (typeof buildMsg==='function') ? buildMsg() : String(buildMsg||key);
          return this._send(msg);
        },
        startHeartbeat(){
          try{ clearInterval(this._hb); }catch{}
          const { cfg } = this.getRaw(); if(!cfg.onStat) return;
          const min = Math.max(5, cfg.statMin);
          const send = async ()=>{
            const st = BybitBotApp.state, J = BybitBotApp.journal?.state||{pnl:0,loss:0};
            const bc = BybitBotApp.api.balanceCache||{};
            const pos = st.currentPosition||{};
            const lines = [
              `‚è± Heartbeat ‚Ä¢ ${new Date().toLocaleTimeString()}`,
              `Status: ${st.isRunning ? 'RUNNING' : 'IDLE'}`,
              `PnL ng√†y: ${(+J.pnl||0).toFixed(2)}$ | LossStreak: ${J.loss||0}`,
              `USDT free: ${bc.free!=null?bc.free.toFixed(2):'‚Äî'} (${bc.acct||'?'})`,
              pos.sym ? `Pos: ${pos.sym} @ ${(+pos.entry||0).toFixed(6)} | TP ${(+pos.tp||0).toFixed(6)} | SL ${(+pos.sl||0).toFixed(6)}` : 'Pos: ‚Äî',
              st.currentPosition?.watching ? `Watch: ${st.currentPosition.watching}` : ''
            ];
            await this._send(lines.filter(Boolean).join('\n'));
          };
          send();
          this._hb = setInterval(send, min*60*1000);
          BybitBotApp.ui.logLive(`Telegram heartbeat m·ªói ${min} ph√∫t`, 'ok');
        },
        stopHeartbeat(){ try{ clearInterval(this._hb); this._hb=null; }catch{} }
    },

    // --- Bybit API Module ---
    api: {
        balanceCache: { ts: 0, free: 0, acct: 'AUTO' },
        async withApiQueue(fn) {
            const { state } = BybitBotApp;
            const prev = state.apiQueue;
            let release;
            state.apiQueue = new Promise(res => (release = res));
            try { await prev; return await fn(); } finally { release(); }
        },
        
        get proxyList(){
            const raw = (BybitBotApp.DOMElements.proxy?.value||'').split(',').map(s=>s.trim()).filter(Boolean);
            return raw.length ? raw : [''];
        },
        _currentProxyIdx: 0,
        buildUrl(p, q) {
            const { config, utils } = BybitBotApp;
            const baseUrl = config.values.useTestnet ? 'https://api-testnet.bybit.com' : 'https://api.bybit.com';
            const qstr = (typeof q === 'string') ? q : (q && Object.keys(q).length ? utils.canonQS(q) : '');
            const u = baseUrl + p + (qstr ? ('?' + qstr) : '');
            const list = this.proxyList; const px = list[this._currentProxyIdx] || '';
            return px ? (px.replace(/\/$/, '') + '/' + u) : u;
        },

        // Internal: fetch JSON with timeout
        async _fetchJsonWithTimeout(url, options = {}, timeoutMs = 18000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const resp = await fetch(url, { ...options, signal: controller.signal });
                const text = await resp.text();
                let data; try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: text }; }
                return { resp, data };
            } finally { clearTimeout(id); }
        },

        async sign(method, path, qs = {}, body = null) {
            return this.withApiQueue(async () => {
                const { config, ui, utils } = BybitBotApp;
                await this.syncTime();
                const apiKey = config.values.apiKey.trim();
                const apiSecret = config.values.apiSecret.trim();
                if (!apiKey || !apiSecret) throw new Error('Thi·∫øu API');

                const maxTries = 3;
                let rwVal = this.suggestedRecvWindow();
                for (let attemptIdx = 1; attemptIdx <= maxTries; attemptIdx++) {
                    try {
                        const rw = String(rwVal);
                        const ts = this.tsNow();
                        let url, payloadStr = '';
                        if (method === 'GET') {
                            payloadStr = BybitBotApp.utils.canonQS(qs);
                            url = this.buildUrl(path, payloadStr);
                        } else {
                            payloadStr = body ? JSON.stringify(body) : '';
                            url = this.buildUrl(path, '');
                        }
                        const sign = await utils.crypto.hmac(apiSecret, `${ts}${apiKey}${rw}${payloadStr}`);
                        const headers = { 'X-BAPI-API-KEY': apiKey, 'X-BAPI-TIMESTAMP': ts, 'X-BAPI-RECV-WINDOW': rw, 'X-BAPI-SIGN-TYPE': '2', 'X-BAPI-SIGN': sign };
                        if (method === 'POST') headers['Content-Type'] = 'application/json';

                        const { resp, data } = await this._fetchJsonWithTimeout(url, { method, headers, body: (method === 'POST' && payloadStr) ? payloadStr : undefined }, 18000);
                        if (resp.status === 403 && BybitBotApp.DOMElements.corsWarn) { BybitBotApp.DOMElements.corsWarn.style.display = 'block'; this._currentProxyIdx = (this._currentProxyIdx+1)%this.proxyList.length; }
                        if (!resp.ok || data.retCode !== 0) {
                            const ret = data.retCode ?? -1; const msg = data.retMsg || resp.statusText || 'ERR';
                            const err = new Error(`HTTP ${resp.status} ‚Äì ${msg} (${ret})`); err.retCode = ret; err.msg = msg; throw err;
                        }
                        return data.result;
                    } catch (e) {
                        const isTemporal = e.name === 'AbortError' || [429,500,502,503,504].some(c => String(e.message||'').includes(`HTTP ${c}`));
                        const isTimeSkew = [10001,10002,10004].includes(e.retCode) || /recvWindow|timestamp|Signature/i.test(e.msg || '');
                        if (attemptIdx < maxTries && (isTemporal || isTimeSkew)) {
                            if (isTimeSkew) { await this.syncTime(true); rwVal += 5000; }
                            const base = 600 * attemptIdx; const jitter = Math.floor(Math.random()*300);
                            ui.logLive(`Retry ${attemptIdx}/${maxTries-1} for ${path}...`, 'warn');
                            await new Promise(res => setTimeout(res, base + jitter));
                            continue;
                        }
                        throw e;
                    }
                }
            });
        },

        async syncTime(force = false) {
            const { time } = BybitBotApp.state;
            if (!force && Date.now() - time.lastSync < 30000) return;
            try {
                const t0 = Date.now();
                const r = await fetch(this.buildUrl('/v5/market/time'));
                const j = await r.json();
                const t1 = Date.now();
                const srvMs = (j?.result?.timeNano ? Math.floor(Number(j.result.timeNano) / 1e6) : j?.result?.timeSecond ? Number(j.result.timeSecond) * 1000 : Number(j?.result?.time) || Date.parse(r.headers.get('date')) || t1);
                time.netRTT = Math.min(5000, Math.max(50, t1 - t0));
                time.serverOffset = srvMs - ((t0 + t1) / 2);
                time.lastSync = t1;
                BybitBotApp.ui.logLive(`ƒê·ªìng b·ªô th·ªùi gian: Offset=${time.serverOffset.toFixed(0)}ms, RTT=${time.netRTT}ms`, 'ok');
            } catch (e) {
                BybitBotApp.ui.logLive('Kh√¥ng ƒë·ªìng b·ªô ƒë∆∞·ª£c th·ªùi gian', 'warn');
            }
        },
        now() { return Date.now() + BybitBotApp.state.time.serverOffset; },
        nowSec() { return Math.floor(this.now()/1000); },
        tsNow() { const t = this.now(); const { time } = BybitBotApp.state; time.lastTs = t <= time.lastTs ? (time.lastTs + 1) : t; return String(Math.floor(time.lastTs)); },
        suggestedRecvWindow() { const { config } = BybitBotApp; const { netRTT } = BybitBotApp.state.time; const pad = 2 * netRTT + 1500; return Math.max(10000, +config.values.recvWindow || 5000, pad); },
        
        async pub(p, q = {}) {
            const url = this.buildUrl(p, q);
            const tries = 2;
            for (let i=1;i<=tries;i++){
                try {
                const { resp, data } = await this._fetchJsonWithTimeout(url, { method:'GET', headers:{'Accept':'application/json'} }, 15000);
                    if (resp.status === 403 && !BybitBotApp.DOMElements.proxy.value.trim()) { BybitBotApp.DOMElements.corsWarn.style.display = 'block'; }
                // chu·∫©n ho√° l·ªói m·∫°ng
                if (resp.status === 0) throw new Error('Network error');
                return data;
                } catch (e) {
                    if (i < tries) { await new Promise(r=>setTimeout(r, 200 + Math.random()*300)); continue; }
                    throw e;
                }
            }
        },
        async klines(s, i = '5', l = 200) { const j = await this.pub('/v5/market/kline', { category: 'spot', symbol: s, interval: i, limit: l }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list.map(r => ({ t: +r[0], o: +r[1], h: +r[2], l: +r[3], c: +r[4], v: +r[5] })).reverse(); },
        async tickers() { const j = await this.pub('/v5/market/tickers', { category: 'spot' }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list; },
        async recentTrades(symbol, limit=80){
            try{
                const j = await this.pub('/v5/market/recent-trade', { category:'spot', symbol, limit: Math.min(1000, Math.max(10, limit)) });
                if (j.retCode !== 0) throw new Error(j.retMsg||'recent-trade');
                const rows = j.result.list || [];
                const buy = rows.filter(r=> String(r.m).toLowerCase() === 'true').reduce((s,r)=> s + (+r.q || 0), 0);
                const sell= rows.filter(r=> String(r.m).toLowerCase() !== 'true').reduce((s,r)=> s + (+r.q || 0), 0);
                const total = buy + sell; const takerBuyRatio = total? buy/total : 0.5;
                return { takerBuyRatio, n: rows.length };
            }catch{ return { takerBuyRatio: 0.5, n: 0 }; }
        },
        async instruments(s) { const j = await this.pub('/v5/market/instruments-info', { category: 'spot', symbol: s }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list[0]; },
        // Snap 2 l·∫ßn ƒë·ªÉ ƒëo v·∫≠n t·ªëc m·∫•t/c√¢n b·∫±ng s·ªï l·ªánh & spread
        async obDelta(symbol, limit = 30, dtMs = 700) {
          const s1 = await this.orderbook(symbol, limit).catch(()=>null);
          if (!s1) return { imbVel:0, spreadVel:0, midRet:0 };
          await BybitBotApp.utils.sleep(dtMs);
          const s2 = await this.orderbook(symbol, limit).catch(()=>null);
          if (!s2) return { imbVel:0, spreadVel:0, midRet:0 };
          const imbVel    = (s2.imb - s1.imb) / Math.max(0.1, dtMs/1000);
          const spreadVel = (s2.spreadBps - s1.spreadBps) / Math.max(0.1, dtMs/1000);
          const mid1 = (s1.bestBid + s1.bestAsk)/2, mid2 = (s2.bestBid + s2.bestAsk)/2;
          const midRet = (mid2 - mid1) / Math.max(1e-9, mid1);
          return { imbVel, spreadVel, midRet };
        },
        async depthImbalance(sym){
          try{
            const j = await BybitBotApp.api.pub('/v5/market/orderbook', {category:'spot',symbol:sym,limit:25});
            const rows = j?.result?.a||[]; const rowsB = j?.result?.b||[];
            const sum = (rows)=> rows.slice(0,10).reduce((s, r)=> s + (+r[1]||0), 0);
            const A = sum(rows), B = sum(rowsB); if (!A && !B) return 0;
            return (B - A) / (A + B);
          }catch{ return 0; }
        },
        async orderbook(symbol, limit=50){
            const j = await this.pub('/v5/market/orderbook', { category:'spot', symbol, limit });
            if (j.retCode !== 0) throw new Error(j.retMsg||'orderbook error');
            const bids = (j.result?.b||[]).map(([p,q])=>({ p:+p, q:+q, notional:+p*+q }));
            const asks = (j.result?.a||[]).map(([p,q])=>({ p:+p, q:+q, notional:+p*+q }));
            const bestBid = bids[0]?.p || 0, bestAsk = asks[0]?.p || 0;
            const sumN = (arr, n=15) => arr.slice(0,n).reduce((s,x)=> s + (+x.notional||0), 0);
            const bidN = sumN(bids, 15), askN = sumN(asks, 15);
            const depthUSDT = bidN + askN;
            const imb = (bidN - askN) / Math.max(1e-9, bidN + askN);
            const mid = (bestBid && bestAsk) ? (bestBid + bestAsk)/2 : 0;
            const spreadBps = mid ? ((bestAsk - bestBid) / mid) * 10000 : 1e6;
            // keep qb/qa for backward compatibility
            const qb = bids.reduce((s,x)=>s+(+x.q||0),0);
            const qa = asks.reduce((s,x)=>s+(+x.q||0),0);
            return { bids, asks, bestBid, bestAsk, spreadBps, depthUSDT, imb, qb, qa };
        },
        async microSig(symbol){
            const j = await this.pub('/v5/market/orderbook', { category:'spot', symbol, limit: 25 });
            const a = (j?.result?.a||[]).slice(0,10).map(r=>({ p:+r[0], q:+r[1] }));
            const b = (j?.result?.b||[]).slice(0,10).map(r=>({ p:+r[0], q:+r[1] }));
            const vA = a.reduce((s,x)=> s + (+x.q||0), 0), vB = b.reduce((s,x)=> s + (+x.q||0), 0);
            const imb = (vB - vA) / Math.max(vA + vB, 1e-9);
            const bestA = a[0]?.p||0, bestB = b[0]?.p||0;
            const microPrice = (vB*(bestB) + vA*(bestA)) / Math.max(vA+vB, 1e-9);
            const mid = (bestA && bestB) ? (bestA + bestB)/2 : 0;
            const microDrift = mid ? ((microPrice - mid) / mid) : 0;
            let s = 0;
            if (imb > 0.07) s += 1;
            if (microDrift > 0.0005) s += 1;
            if (mid && ((bestA - bestB)/mid*10000) < 10) s += 1;
            return { s, imb, microDrift };
        },
        async estSlipBps(symbol, notional){
            const j = await this.pub('/v5/market/orderbook', { category:'spot', symbol, limit: 50 });
            const asks = (j?.result?.a||[]).map(r=>({ p:+r[0], q:+r[1] }));
            if (!asks.length) return 999;
            let needBase = 0; // base amount we intend to buy
            // approximate desired base from notional at best ask
            const bestAsk = asks[0].p || 0; if (!bestAsk) return 999;
            needBase = notional / bestAsk;
            let filledBase = 0, spent = 0;
            for (const a of asks){
                if (needBase <= 0) break;
                const baseCap = +a.q || 0;
                const takeBase = Math.min(needBase, baseCap);
                spent += takeBase * a.p;
                filledBase += takeBase;
                needBase -= takeBase;
            }
            if (needBase > 1e-12) return 999;
            const avgPx = spent / Math.max(filledBase, 1e-9);
            const bidTop = +(j?.result?.b?.[0]?.[0]||0);
            const mid = (bestAsk && bidTop) ? (bestAsk + bidTop)/2 : bestAsk || bidTop || avgPx;
            return mid ? ((avgPx - mid) / mid) * 10000 : 0;
        },
        async btcOk() { 
             try {
                // Lu√¥n 5m ƒë√∫ng nh∆∞ label
                const k = await this.klines('BTCUSDT', '5', 100);
                const C = k.map(k => k.c);
                const { sma, rsi } = BybitBotApp.utils.indicators;
                return sma(C, 20) > sma(C, 50) && rsi(C, 14) > 48;
             } catch { return true; }
        },
        
        // --- Order Placement (with precision & min rules) ---
        async __norms(symbol) {
            const i = await BybitBotApp.api.instruments(symbol);
            const pr = BybitBotApp.utils.precision;
            const tick = pr.tickOf(i), step = pr.stepOf(i);
            const minQty = +(i?.lotSizeFilter?.minOrderQty ?? 0) || 0;
            const minAmt = +(i?.lotSizeFilter?.minOrderAmt ?? 0) || 0; // quote min for marketUnit=quoteCoin
            const qstep = pr.quoteStepOf(i);
            return { i, pr, tick, step, minQty, minAmt, qstep };
        },
        async buy(symbol, quoteUSDT) {
            const n = await this.__norms(symbol);
            let q = Math.max(+quoteUSDT, n.minAmt || 0);
            // Chu·∫©n ho√° amount theo quotePrecision (qstep) ƒë·ªÉ tr√°nh 170148
            // N·∫øu sau khi floor < minAmt ‚Üí ceil l√™n ƒë√∫ng b·ªôi b∆∞·ªõc
            q = n.pr.floorStep(q, n.qstep);
            if (q < n.minAmt) q = n.pr.ceilStep(n.minAmt, n.qstep);
            const qtyStr = n.pr.fmtAmt(q, n.qstep);
            if (+qtyStr <= 0) throw new Error('Quote amount <= 0 sau khi l√†m tr√≤n');
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Buy', orderType: 'Market',
                marketUnit: 'quoteCoin', qty: qtyStr,
                orderLinkId: `buy_${symbol}_${Date.now()}`
            });
        },
        async sell(symbol, baseQty) {
            const n = await this.__norms(symbol);
            const qty = n.pr.fmtQty(baseQty, n.step);
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Sell', orderType: 'Market',
                marketUnit: 'baseCoin', qty, timeInForce: 'IOC',
                orderLinkId: `sell_${symbol}_${Date.now()}`
            });
        },
        async tp(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapUp(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            // Pre-check: if quote value is below min amount, fallback to EMU OCO to avoid 170140
            if ((+qty) * (+trig) < (n.minAmt || 0)) {
                return { emu: true, type: 'tp', price: trig, qty };
            }
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 1,              // ‚Üë kh·ªõp khi gi√° tƒÉng v∆∞·ª£t
                    triggerBy: 'LastPrice',
                    triggerPrice: String(trig.toFixed(8)),
                    qty,
                    orderLinkId: `tp_${symbol}_${Date.now()}`
                });
            } catch (e) {
                // Fallback sang OCO gi·∫£ l·∫≠p n·∫øu s√†n t·ª´ ch·ªëi StopOrder
                BybitBotApp.ui.logLive(`TP spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'tp', price: trig, qty };
            }
        },
        async sl(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapDown(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            // Pre-check: if quote value is below min amount, fallback to EMU OCO to avoid 170140
            if ((+qty) * (+trig) < (n.minAmt || 0)) {
                return { emu: true, type: 'sl', price: trig, qty };
            }
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 2,              // ‚Üì kh·ªõp khi gi√° gi·∫£m xuy√™n th·ªßng
                    triggerBy: 'LastPrice',
                    triggerPrice: String(trig.toFixed(8)),
                    qty,
                    orderLinkId: `sl_${symbol}_${Date.now()}`
                });
            } catch (e) {
                BybitBotApp.ui.logLive(`SL spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'sl', price: trig, qty };
            }
        },
        realtimeOrders: async (s) => await BybitBotApp.api.sign('GET', '/v5/order/realtime', { category: 'spot', symbol: s }),
        async cancelAll(symbol) {
            const { state, ui } = BybitBotApp;
            if (state.cancelLock || state.isStopping) return;
            state.cancelLock = true;
            clearTimeout(state.cancelTimer);
            try { await this.syncTime(true); await this.sign('POST', '/v5/order/cancel-all', {}, { category: 'spot', symbol }); } 
            catch (e) { ui.logLive('Hu·ª∑ l·ªánh th·∫•t b·∫°i: ' + e.message, 'warn'); } 
            finally { state.cancelTimer = setTimeout(() => { state.cancelLock = false; }, 800); }
        },
        async usdtFreeBalance(force=false) {
            const { config } = BybitBotApp;
            const now = Date.now();
            // cache 10s
            if (!force && now - this.balanceCache.ts < 10_000 && this.balanceCache.free >= 0) {
              return this.balanceCache;
            }
            const pref = (config.values.balanceAcct || 'AUTO').toUpperCase();
            const tryOrder = pref === 'AUTO' ? ['SPOT','UNIFIED'] : [pref];

            for (const acct of tryOrder) {
              try {
                const r = await BybitBotApp.api.sign('GET', '/v5/account/wallet-balance', { accountType: acct, coin: 'USDT' });
                const list = r?.list?.[0]?.coin || [];
                const usdt = list.find(c => c.coin === 'USDT');
                if (!usdt) continue;

                let free = 0;
                if (acct === 'SPOT' && usdt.free != null) {
                  free = +usdt.free;
                } else {
                  const wb = +usdt.walletBalance || 0;
                  const locked = +usdt.locked || 0;
                  free = Math.max(wb - locked, 0);
                }
                this.balanceCache = { ts: now, free: +free.toFixed(4), acct };
                return this.balanceCache;
              } catch (e) { /* continue to next account type */ }
            }
            throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c s·ªë d∆∞ USDT.');
          }
    },

    // --- OCO Emulation Module ---
    oco: {
      timer: null,
      async watch(symbol, baseQty, tpPrice, slPrice) {
        clearInterval(this.timer);
        this.timer = setInterval(async () => {
          try {
            const t = await BybitBotApp.api.pub('/v5/market/tickers', { category: 'spot', symbol });
            if (t.retCode !== 0) return;
            const last = +t.result.list[0].lastPrice;
            if (tpPrice && last >= tpPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] TakeProfit @ ${last} ‚Üí SELL`, 'ok');
              await BybitBotApp.api.sell(symbol, baseQty);
            } else if (slPrice && last <= slPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] StopLoss @ ${last} ‚Üí SELL`, 'warn');
              await BybitBotApp.api.sell(symbol, baseQty);
            }
          } catch {}
        }, 1500);
      },
      stop(){ clearInterval(this.timer); }
    },

    // --- WebSocket Module ---
    ws: {
        async connect() {
            try {
                if (BybitBotApp.state.ws.instance) { try { BybitBotApp.state.ws.instance.close() } catch {} }
                const { config, ui, api } = BybitBotApp;
                config.load(); // Ensure latest API keys are used
                const { apiKey, apiSecret } = config.values;
                if (!apiKey || !apiSecret) return ui.logLive('WS private: thi·∫øu API', 'warn');

                const url = config.values.useTestnet ? 'wss://stream-testnet.bybit.com/v5/private' : 'wss://stream.bybit.com/v5/private';
                
                const makeArgs = async () => {
                    // Per Bybit v5: expires is client-generated timestamp (ms). Keep ms precision.
                    const expires = BybitBotApp.api.now() + 10_000; // 10s grace
                    const expiresStr = String(Math.floor(expires));
                    const sig = await BybitBotApp.utils.crypto.hmac(apiSecret, `GET/realtime${expiresStr}`);
                    return [apiKey, expiresStr, sig];
                };

                const ws = new WebSocket(url);
                BybitBotApp.state.ws.instance = ws;
                let lastPong = Date.now();

                ws.onopen = async () => {
                    ws.send(JSON.stringify({ op: 'auth', args: await makeArgs() }));
                    clearInterval(BybitBotApp.state.ws.ping);
                    BybitBotApp.state.ws.ping = setInterval(() => { try { ws.send(JSON.stringify({ op: 'ping' })); } catch {} }, 15000);
                    clearInterval(BybitBotApp.state.ws.watchdog);
                    BybitBotApp.state.ws.watchdog = setInterval(() => { if (Date.now() - lastPong > 45000) { ui.logLive('WS private: heartbeat timeout ‚Üí reconnect', 'warn'); try { ws.close(); } catch {} } }, 10000);
                };

                ws.onmessage = async ev => {
                    let msg; try { msg = JSON.parse(ev.data); } catch { return; }
                    if (msg.op === 'pong' || msg.ret_msg === 'pong') { lastPong = Date.now(); return; }
                    if (msg.op === 'auth') {
                        if (msg.success) {
                            BybitBotApp.state.ws.backoff = 3000;
                            ui.logLive('WS private: auth OK', 'ok');
                            ws.send(JSON.stringify({ op: 'subscribe', args: ['order'] }));
                            return;
                        }
                        ui.logLive(`WS private: auth failed (${msg.ret_msg})`, 'error');
                        try { ws.close(); } catch {}
                        // G·ª£i √Ω s·ª≠a l·ªói API
                        ui.logLive('Ki·ªÉm tra l·∫°i API Key/Secret v√† Testnet/Real, sau ƒë√≥ Load API v√† Start l·∫°i.', 'warn');
                        return;
                    }
                    if (msg.topic === 'order') {
                        const { state, liveBot } = BybitBotApp;
                        const ds = msg.data || [];
                        const filledSell = ds.find(o => o.symbol === state.currentPosition.sym && o.side === 'Sell' && (o.orderStatus === 'Filled' || o.orderStatus === 'PartiallyFilled'));
                        if (filledSell) {
                            liveBot.handlePositionExit(filledSell.avgPrice, 'WS Fill');
                        }
                    }
                };
                
                const cleanup = () => {
                    clearInterval(BybitBotApp.state.ws.ping); BybitBotApp.state.ws.ping = null;
                    clearInterval(BybitBotApp.state.ws.watchdog); BybitBotApp.state.ws.watchdog = null;
                };

                ws.onclose = () => {
                    cleanup();
                    ui.logLive('WS private: closed', 'warn');
                    const { state, config } = BybitBotApp;
                    if (state.isRunning && !config.values.simMode) {
                        const d = Math.min(state.ws.backoff, 30000);
                        setTimeout(() => { state.ws.backoff = Math.min(state.ws.backoff * 1.7, 30000); this.connect(); }, d);
                    }
                };
                ws.onerror = () => { cleanup(); ui.logLive('WS private error', 'warn'); };

            } catch (e) {
                BybitBotApp.ui.logLive('M·ªü WS private l·ªói: ' + e.message, 'warn');
            }
        },
        disconnect() {
            const { state } = BybitBotApp;
            clearInterval(state.ws.ping); state.ws.ping = null;
            clearInterval(state.ws.watchdog); state.ws.watchdog = null;
            if (state.ws.instance) { try { state.ws.instance.close() } catch {}; state.ws.instance = null; }
        }
    },

    // --- Journal Module ---
    journal: {
        state: { date: '', loss: 0, pnl: 0, trades: [] },
        today: () => new Date().toISOString().slice(0, 10),
        load() {
            const j = localStorage.getItem('bb_journal_v6');
            this.state = j ? JSON.parse(j) : { date: this.today(), loss: 0, pnl: 0, trades: [] };
            if (this.state.date !== this.today()) this.reset();
            this.updateUI();
        },
        save() {
            localStorage.setItem('bb_journal_v6', JSON.stringify(this.state));
        },
        push(trade) {
            this.state.trades.unshift(trade);
            if (trade.pnl !== undefined) this.state.pnl += trade.pnl;
            if (trade.pnl < 0) this.state.loss += 1;
            else if (trade.pnl > 0) this.state.loss = 0;
            this.save();
            this.updateUI();
        },
        reset() {
            this.state = { date: this.today(), loss: 0, pnl: 0, trades: [] };
            this.save();
            this.updateUI();
            BybitBotApp.ui.logLive('ƒê√£ reset phi√™n giao d·ªãch.', 'ok');
        },
        updateUI() {
            const { DOMElements, ui } = BybitBotApp;
            DOMElements.lossStreak.textContent = this.state.loss;
            DOMElements.pnlDay.textContent = this.state.pnl.toFixed(2);
            ui.renderJournal('journalLive', this.state.trades);
        }
    },

    // --- Live Trading Bot ---
    liveBot: {
        async computeOrderQtyLive(symbol, fixedQuote) {
          const { api, utils, config } = BybitBotApp;
          const info = await api.instruments(symbol);
          const ls = info.lotSizeFilter || {};
          const minOrderAmt = +ls.minOrderAmt || 5;
          const step   = utils.precision.stepOf(info);
          const qstep  = utils.precision.quoteStepOf(info);

          // L·∫•y gi√° hi·ªán t·∫°i
          const kl = await api.klines(symbol, config.values.tf, 2);
          const price = kl[kl.length - 1].c;

          // --- NEW: quote theo balance v·ªõi early-exit khi thi·∫øu ti·ªÅn ---
          let quote = fixedQuote;
          let capByFree = Infinity;
          if (config.values.useBalanceSizing) {
            try {
                const { free, acct } = await api.usdtFreeBalance(false);
                const pct   = Math.max(0, Math.min(+config.values.riskPct || 0, 100)) / 100;
                const minQ  = Math.max(+config.values.minQuote || 5, minOrderAmt);
                const maxQ  = Math.max(+config.values.maxQuote || minQ, minQ);
                const rz    = Math.max(+config.values.reserveUsd || 0, 0);

                capByFree = Math.max(0, free - rz);
                quote = Math.min(Math.max(free * pct, minQ), maxQ, capByFree);
                if (!isFinite(quote) || quote <= 0) quote = minQ;

                BybitBotApp.ui.logLive(`[Sizing] acct=${acct} free=${free.toFixed(2)} ‚Üí quote=${quote.toFixed(2)} USDT`);

                // Early-exit: ti·ªÅn kh·∫£ d·ª•ng < min order
                if (capByFree + 1e-9 < minOrderAmt) {
                  BybitBotApp.ui.logLive(`B·ªè qua: USDT free (${capByFree.toFixed(2)}) < min order (${minOrderAmt}).`, 'warn');
                  return { qty: 0, step, finalQuote: 0 };
                }
            } catch(e) {
                BybitBotApp.ui.logLive(`L·ªói sizing: ${e.message}. D√πng quote c·ªë ƒë·ªãnh.`, 'warn');
                quote = fixedQuote;
            }
          }

          // ƒê·ªïi ra s·ªë l∆∞·ª£ng base, √©p minQty & step
          let qty = utils.precision.floorStep(quote / price, step);
          const minQty = +(ls.minOrderQty || 0);
          if (minQty && qty < minQty) {
            const times = Math.ceil(minQty / step);
            qty = +(times * step).toFixed(8);
          }
          
          let finalQuote = qty * price;
          // R√†ng amount theo quote step ƒë·ªÉ kh√¥ng b·ªã "decimal too long"
          finalQuote = utils.precision.floorStep(finalQuote, qstep);
          // Clamp theo free balance ƒë·ªÉ kh·ªèi 170131
          try {
            const { free } = await BybitBotApp.api.usdtFreeBalance(false);
            const headroom = 0.2;
            const maxSpend = Math.max(0, free - headroom);
            if (finalQuote > maxSpend) finalQuote = BybitBotApp.utils.precision.floorStep(maxSpend, qstep);
          } catch {}
          // Early-exit: kh√¥ng c·ªë n√¢ng v∆∞·ª£t s·ªë d∆∞/min order
          if (finalQuote + 1e-9 < minOrderAmt) {
              BybitBotApp.ui.logLive(`B·ªè qua: finalQuote ${finalQuote.toFixed(2)} < min order ${minOrderAmt}.`, 'warn');
              return { qty: 0, step, finalQuote: 0 };
          }
          return { qty, step, finalQuote };
        },

        async start() {
            const { state, config, api, ui, liveBot, ws } = BybitBotApp;
            if (state.isRunning) return;
            config.load(); // Load latest UI settings
            if (config.values.autoResetStart) BybitBotApp.journal.reset();

            if (!config.values.simMode) {
                const apiKey = BybitBotApp.DOMElements.apiKey.value.trim();
                const apiSecret = BybitBotApp.DOMElements.apiSecret.value.trim();
                if (!apiKey || !apiSecret) return ui.logLive('Thi·∫øu API Key/Secret. Vui l√≤ng n·∫°p API tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.', 'error');
            }

            state.isRunning = true;
            state.isStopping = false;
            await api.syncTime(true);

            if (!config.values.simMode) {
                ws.connect();
            }
            
            ui.updateStatus('ƒêang ch·∫°y...');
            liveBot.scheduler();
            ui.logLive('Bot ƒë√£ b·∫Øt ƒë·∫ßu.', 'ok');
            if (BybitBotApp.config.values['TG_onLifecycle']) { BybitBotApp.telegram.notify('‚ñ∂Ô∏è Bot started'); }
        },

        async stop() {
            const { state, ui, liveBot, ws, oco } = BybitBotApp;
            if (!state.isRunning) return;
            state.isStopping = true;
            state.isRunning = false;
            clearTimeout(state.timers.scheduler);
            if (state.isInPosition) await liveBot.gracefulExit();
            
            ws.disconnect();
            oco.stop(); // Ensure OCO watcher is stopped as well
            
            ui.updateStatus('ƒê√£ d·ª´ng', 'warn');
            ui.logLive('Bot ƒë√£ d·ª´ng.', 'warn');
            if (BybitBotApp.config.values['TG_onLifecycle']) { BybitBotApp.telegram.notify('‚ñ† Bot stopped'); }
            state.isStopping = false;
        },
        
        async gracefulExit() {
            const { state, api, ui, liveBot, ws, oco } = BybitBotApp;
            clearTimeout(state.timers.monitor);
            clearTimeout(state.timers.simMonitor);
            oco.stop();
            
            state.isInPosition = false;
            ui.updateStatus('Nh√†n r·ªói');
            if (state.currentPosition.sym && !BybitBotApp.config.values.simMode) {
                await api.cancelAll(state.currentPosition.sym);
            }
            state.currentPosition = {};
            ws.disconnect();
        },
        
        handlePositionExit(exitPrice, note = '') {
            const { state, journal, ui } = BybitBotApp;
            const baseQty = state.currentPosition.sellQty ?? state.currentPosition.qty;
            const pnl = (exitPrice - state.currentPosition.entry) * baseQty;
            ui.logLive(`‚úÖ ${note}: L·ªánh kh·ªõp @ ${exitPrice} ‚Üí PnL: ${pnl.toFixed(2)}$`, pnl > 0 ? 'ok' : 'bad');
            try{ BybitBotApp.adapt.push({ ts: Date.now(), took: 1, pnl }); }catch{}
            journal.push({
                ts: Date.now(),
                ...state.currentPosition,
                exit: +exitPrice,
                pnl,
                note
            });
            if (BybitBotApp.config.values['TG_onTrade']) {
                BybitBotApp.telegram.notify(`EXIT ${state.currentPosition.sym} @ ${exitPrice} | PnL ${pnl.toFixed(2)}$`);
            }
            // Reputation bump
            try{
                const r = Math.sign(pnl) * Math.min(2, Math.max(1, Math.abs(pnl)/1.5));
                BybitBotApp.reputation.bump(state.currentPosition.sym, r);
            }catch{}
            try {
                if (pnl < 0) {
                    const mins = Math.min(40, Math.max(20, Math.round(Math.abs(pnl))));
                    BybitBotApp.state.cooldown.bySym[state.currentPosition.sym] = Date.now() + mins*60*1000;
                    BybitBotApp.ui.logLive(`Cooldown ${state.currentPosition.sym} ~ ${mins} ph√∫t`, 'warn');
                }
            } catch {}
            this.gracefulExit();
        },

        async step() {
            const { state, config, api, ui, journal, utils } = BybitBotApp;
            ui.updateStats(); // Update time
            if (journal.state.loss >= config.values.maxLossDay) return ui.updateStatus('T·∫°m d·ª´ng (Max Loss)', 'warn');
            if (state.isInPosition) return;
            if (!BybitBotApp.ui.withinTimeWindow()) return ui.updateStatus('Ngo√†i khung gi·ªù giao d·ªãch', 'warn');

            // BTC circuit-breaker
            if (BybitBotApp.risk?.paused?.() || (await BybitBotApp.risk?.btcBreaker?.())) return;

            // Kill-switch nh·ªè v·ªën
            try{
                const pnl = BybitBotApp.journal?.state?.pnl ?? 0;
                if (pnl >= 1) { BybitBotApp.ui.updateStatus('ƒê·∫°t target ng√†y +$1', 'ok'); return; }
                if (pnl <= -2){ BybitBotApp.ui.updateStatus('Ch·∫°m ng∆∞·ª°ng l·ªó ‚àí$2', 'warn'); return; }
            }catch{}

            // Candle-phase gating: ƒë·ª£i n·ª≠a sau n·∫øn
            try{
                const n = BybitBotApp.api.now();
                const tfMs = ({'1':60,'3':180,'5':300,'15':900}[BybitBotApp.config.values.tf]||300)*1000;
                const dist = (Math.ceil(n/tfMs)*tfMs) - n;
                if (dist > tfMs*0.5 && dist < tfMs*0.9) { BybitBotApp.ui.updateStatus('ƒê·ª£i n·ª≠a sau n·∫øn', 'warn'); return; }
            }catch{}
            
            try {
                // Find best symbol
                const symbols = config.values.symbolList.trim() ? config.values.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean) : await this.getUniverseLiveAlt();
                state.currentPosition.watching = symbols.slice(0, 6).join(',') + (symbols.length > 6 ? ' ...' : '');
                
                const btcOk = config.values.btcFilter ? await api.btcOk() : true;
                // Adaptive co-gi√£n
                const S = BybitBotApp.adapt.stats();
                let dynMin = config.values.minScore;
                let spreadCapDyn = +BybitBotApp.DOMElements.CO_maxSpreadBps.value || 15;
                if (S.F < 0.5 && S.P >= 1.2) { dynMin = Math.max(3, dynMin - 1); spreadCapDyn = Math.min(30, spreadCapDyn + 5); }
                if (S.F > 4 || (S.P > 0 && S.P < 1.1)) { dynMin = Math.min(9, dynMin + 1); spreadCapDyn = Math.max(8, spreadCapDyn - 5); }
                BybitBotApp.state.currentPosition._minScoreApplied = dynMin;
                BybitBotApp.state.currentPosition._spreadCapApplied = spreadCapDyn;
                if (!btcOk) { dynMin += 1; if (BybitBotApp.DOMElements['TG_onRisk']?.checked) BybitBotApp.telegram.throttle('breaker_btc', 120000, ()=>`[BREAKER] BTC y·∫øu ‚Üí n√¢ng MinScore l√™n ${dynMin}`); }

                let best = null;
                const viewSamples = [];
                // --- Phase 1: qu√©t nhanh b·∫±ng v2 ---
                let coarse = [];
                for (const sym of symbols) {
                  if (BybitBotApp.filters?.isPeggedSymbol?.(sym)) continue;
                  try {
                    const sc = await BybitBotApp.utils.pumpScoreV2(sym);
                    coarse.push({ sym, s: sc.score, parts: sc.parts });
                  } catch {}
                }
                coarse.sort((a,b)=> b.s - a.s);
                if (!coarse.length || !config.values.autoMode) return;

                // --- Phase 2: refine topK b·∫±ng v3 ---
                const topK = coarse.slice(0, Math.min(5, Math.max(3, Math.floor(coarse.length*0.2))));
                for (const c of topK) {
                  try {
                    const sc3 = await BybitBotApp.utils.pumpScoreV3(c.sym);
                    const total = sc3.score;
                    if (!best || total > best.meta.score) best = { sym: c.sym, meta: { score: total, parts: sc3.parts } };
                  } catch {}
                }
                state.currentPosition.signal = best ? `${best.sym} ‚Ä¢ PumpScoreV3 ${best.meta.score.toFixed(1)}` : '‚Äî';
                // Per-symbol cooldown guard
                const cd = BybitBotApp.state.cooldown.bySym[best?.sym];
                if (cd && cd > Date.now()){
                    const mins = Math.ceil((cd - Date.now())/60000);
                    ui.logLive(`Cooldown ${best.sym} c√≤n ${mins}p`, 'warn');
                    return;
                }
                // Draw strategy view for top-watching symbol (fallback n·∫øu ch∆∞a c√≥ symbol: BTCUSDT)
                if (viewSamples.length){ const v = viewSamples[0];
                  const C = v.kl.map(k=>k.c);
                  const emaF = utils.indicators.emaSeries(C, 20);
                  const emaS = utils.indicators.emaSeries(C, 50);
                  ui.drawLiveStrategy(v.kl, emaF, emaS, {});
                }
                else {
                  try{
                    const sym = 'BTCUSDT'; const kl = await api.klines(sym, config.values.tf, 200);
                    const C = kl.map(k=>k.c); const ema20 = utils.indicators.emaSeries(C,20); const ema50 = utils.indicators.emaSeries(C,50);
                    ui.drawLiveStrategy(kl, ema20, ema50, {});
                  }catch{}
                }
                ui.updateStats();
                
                if (!best || !config.values.autoMode || best.meta.score < dynMin) { BybitBotApp.adapt.push({ ts: Date.now(), took: 0 }); return; }

                // MTF confirmation
                if (BybitBotApp.DOMElements.CO_mtfEnable?.checked) {
                    try{
                        const tfHi = String(BybitBotApp.DOMElements.CO_mtfTf.value||'15');
                        const klHi = await api.klines(best.sym, tfHi, 60);
                        const C2 = klHi.map(k=>k.c); const ema20 = utils.indicators.sma(C2,20), ema50 = utils.indicators.sma(C2,50);
                        const rhi = utils.indicators.rsi(C2,14)||0;
                        const trendOk = (ema20!=null && ema50!=null) ? (ema20>ema50) : (rhi>50);
                        if (!trendOk) return ui.logLive(`MTF t·ª´ ch·ªëi ${best.sym} (${tfHi})`, 'warn');
                    }catch{}
                }

                // Regime-based presets (AUTO)
                if ((BybitBotApp.DOMElements.CO_regimeMode?.value||'AUTO')==='AUTO'){
                    try{
                        const klRef = await api.klines('BTCUSDT', String(config.values.tf||'5'), 120);
                        const Cb = klRef.map(k=>k.c); const ema20b = utils.indicators.sma(Cb,20), ema50b=utils.indicators.sma(Cb,50);
                        const trb = utils.indicators.trArr(klRef.map(k=>k.h), klRef.map(k=>k.l), Cb); const atrb = utils.indicators.median(trb.slice(-14));
                        const atrp = Cb.length ? atrb/Cb.at(-1) : 0;
                        let mode = 'SIDEWAYS'; if (ema20b>ema50b) mode='TREND'; if (atrp>0.02 && ema20b<ema50b) mode='MEANREV';
                        // apply light preset
                        const E = BybitBotApp.DOMElements; if (mode==='TREND'){ E.B_tpK.value=1.5; E.B_slK.value=0.9; } else if (mode==='MEANREV'){ E.B_tpK.value=1.2; E.B_slK.value=0.8; } else { E.B_tpK.value=1.3; E.B_slK.value=0.9; }
                        E.B_tpK.dispatchEvent(new Event('change')); E.B_slK.dispatchEvent(new Event('change'));
                    }catch{}
                }
                
                // --- Budget guard: skip n·∫øu free < minAmt ---
                try {
                    const info = await BybitBotApp.api.instruments(best.sym);
                    const minAmt = +(info?.lotSizeFilter?.minOrderAmt || 5);
                    const { free } = await BybitBotApp.api.usdtFreeBalance(false);
                    if (free < (minAmt + 0.2)) {
                        BybitBotApp.ui.logLive(`B·ªè qua ${best.sym}: free ${free.toFixed(2)} < min ${minAmt}`, 'warn');
                        return;
                    }
                } catch {}

                // --- TrashGuard tr∆∞·ªõc khi v√†o l·ªánh ---
                try{
                    const tg = await BybitBotApp.filters.assess(best.sym);
                    const tagStr = tg.tags.join(',');
                    if (!tg.ok){
                        ui.logLive(`B·ªè ${best.sym}: coin r√°c r·ªßi ro (${tagStr}) depth=${Math.round(tg.depthUSDT/1000)}k spread=${tg.spreadBps.toFixed(1)}bps`, 'warn');
                        return;
                    } else if (tg.sizeMul < 1){
                        ui.logLive(`Gi·∫£m size ${best.sym}: x${tg.sizeMul.toFixed(2)} (${tagStr||'ok'})`, 'warn');
                        best.sizeMul = tg.sizeMul;
                    }
                    const maxBps = BybitBotApp.state.currentPosition._spreadCapApplied || Math.min(+BybitBotApp.DOMElements.CO_maxSpreadBps?.value||15, 12);
                    if (tg.spreadBps > maxBps) { ui.logLive(`Spread guard: ${best.sym} ${tg.spreadBps.toFixed(1)}bps > ${maxBps}`, 'warn'); return; }
                }catch(e){ ui.logLive('TrashGuard l·ªói: '+e.message, 'warn'); }

                // --- Pump PRO gate (1m + MTF + OB) ---
                let usePro=false, sig=null;
                try{
                    const kl1 = await BybitBotApp.api.klines(best.sym,'1',80);
                    sig = BybitBotApp.utils.strategy.pumpHunterPro(kl1,{ tpK: BybitBotApp.config.values.B_tpK, slK: 0.6 });
                    if (sig){
                        try{
                            const kl3 = await BybitBotApp.api.klines(best.sym,'3',60);
                            const C3=kl3.map(k=>k.c), ema20_3=BybitBotApp.utils.indicators.sma(C3,20), ema50_3=BybitBotApp.utils.indicators.sma(C3,50);
                            if (!(ema20_3 && ema50_3 && ema20_3 > ema50_3)) sig=null;
                        }catch{}
                    }
                    if (sig){
                        const cmp = async (sym)=>{ const k=await BybitBotApp.api.klines(sym,'1',12); return (k.at(-1).c - k.at(-12).c)/k.at(-12).c*100; };
                        try{
                            const [rBTC, rSOL, rNEAR, rAVAX] = await Promise.allSettled(['BTCUSDT','SOLUSDT','NEARUSDT','AVAXUSDT'].map(cmp));
                            const val = (x)=> x.status==='fulfilled' ? x.value : 0;
                            const peer = (val(rSOL)+val(rNEAR)+val(rAVAX))/3;
                            const coin = (kl1.at(-1).c - kl1.at(-12).c)/kl1.at(-12).c*100;
                            if ((coin - val(rBTC)) < 0.8 || (coin - peer) < 0.5) sig=null;
                        }catch{}
                    }
                    if (sig){
                        try{ const ob = await BybitBotApp.api.orderbook(best.sym, 40); if (ob.imb < 0.05) sig=null; }catch{}
                    }
                    usePro = !!sig;
                }catch{ usePro=false; }

                if (!usePro){
                    BybitBotApp.ui.logLive(`B·ªè ${best.sym}: ch∆∞a ƒë·∫°t Pump-PRO`, 'warn');
                    return;
                }

                const tpsl = { tp: sig.tp1, sl: sig.sl, rr: (sig.tp1 - sig.entry)/Math.max(sig.entry - sig.sl,1e-9) };
                BybitBotApp.ui.logLive(`[Pump-PRO] ${best.sym} ‚Ä¢ ${sig.why.join(' | ')}`, 'ok');
                if (tpsl.rr < 1.2) return ui.logLive(`B·ªè qua ${best.sym}: R:R ${tpsl.rr.toFixed(2)}<1.2`, 'warn');
                
                // Spread/slippage guard (approx using last price & tick size)
                try{
                    const t = await api.pub('/v5/market/tickers', { category:'spot', symbol: best.sym });
                    if (t?.result?.list?.length){ const s = t.result.list[0]; const bid = +s.bid1Price||best.meta.last; const ask = +s.ask1Price||best.meta.last; const spreadBps = (ask-bid)/((ask+bid)/2)*10000; const maxBps = BybitBotApp.state.currentPosition._spreadCapApplied || (+BybitBotApp.DOMElements.CO_maxSpreadBps?.value||15); if (spreadBps>maxBps) return ui.logLive(`Spread guard: ${best.sym} ${spreadBps.toFixed(1)}bps > ${maxBps}`, 'warn'); }
                }catch{}

                // Microstructure score boost & imbalance gate
                try{
                    const ms = await BybitBotApp.api.microSig(best.sym);
                    best.meta.score = (best.meta.score||0) + (ms?.s||0);
                    if (ms.imb < 0.03) return BybitBotApp.ui.logLive('Imbalance y·∫øu ‚Üí b·ªè', 'warn');
                }catch{}

                // Microstructure quick score
                async function microSig(sym){
                  const j = await BybitBotApp.api.pub('/v5/market/orderbook', {category:'spot',symbol:sym,limit:25});
                  const a = (j?.result?.a||[]).slice(0,10).map(r=>({p:+r[0],q:+r[1]}));
                  const b = (j?.result?.b||[]).slice(0,10).map(r=>({p:+r[0],q:+r[1]}));
                  const vA = a.reduce((s,x)=>s+x.q,0), vB = b.reduce((s,x)=>s+x.q,0);
                  const imb = (vB - vA) / Math.max(vA+vB,1e-9);
                  const bestA = a[0]?.p||0, bestB = b[0]?.p||0;
                  const microPrice = (vB*bestA + vA*bestB)/Math.max(vA+vB,1e-9);
                  const mid = (bestA+bestB)/2;
                  const microDrift = (microPrice-mid)/Math.max(mid,1e-9);
                  let s = 0; if (imb > 0.07) s += 1; if (microDrift > 0.0005) s += 1; if (bestA && bestB && ((bestA-bestB)/mid*10000) < 10) s += 1;
                  return { s, imb, microDrift };
                }
                try{
                  const ms = await microSig(best.sym);
                  best.meta.score = (best.meta.score||0) + ms.s;
                  if (ms.imb < 0.03) return BybitBotApp.ui.logLive('Imbalance y·∫øu ‚Üí b·ªè', 'warn');
                }catch{}

                // Depth imbalance check
                try{
                  const imb = await BybitBotApp.api.depthImbalance(best.sym);
                  if (imb < 0.05) { BybitBotApp.ui.logLive(`Imbalance th·∫•p (${(imb*100).toFixed(1)}%) ‚Üí b·ªè qua`, 'warn'); return; }
                }catch{}

                // Calculate quantity
                // TrashGuard ƒë√£ tr·∫£ sizeMul; si·∫øt th√™m theo vi m√¥ n·∫øu c√≥
                let sizeMul = (best.sizeMul || 1);
                try {
                  const od = best.meta?.parts?.od;
                  if (od) {
                    if (od.spreadVel > 4) sizeMul *= 0.8;
                    if (od.imbVel < -0.05) sizeMul *= 0.85;
                  }
                } catch {}
                let { qty, step, finalQuote } = await this.computeOrderQtyLive(best.sym, config.values.orderQuote);
                finalQuote = finalQuote * Math.max(0.2, Math.min(1, sizeMul));
                if (qty <= 0 || finalQuote <= 0) {
                    ui.logLive('Skip trade: kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán kh·ªëi l∆∞·ª£ng/t·ªëi thi·ªÉu.', 'warn');
                    state.isInPosition = false;
                    return;
                }

                // Slippage guard (depth-aware) for small notional
                try{
                    const slip = await BybitBotApp.api.estSlipBps(best.sym, finalQuote);
                    if (slip > 18) return BybitBotApp.ui.logLive(`Slippage ${slip.toFixed(1)}bps > 18 ‚Üí b·ªè`, 'warn');
                }catch{}

                state.isInPosition = true;
                state.currentPosition = { sym: best.sym, entry: sig.entry, tp: tpsl.tp, sl: tpsl.sl, ts: Date.now(), qty, quote: finalQuote, atr: sig.atr || best.meta.atr || best.meta.last * 0.005 };
                
                if (config.values.simMode) {
                    ui.updateStatus('[SIM] Trong v·ªã th·∫ø');
                    ui.logLive(`[SIM] BUY ${best.sym} @${best.meta.last.toFixed(6)} | TP=${tpsl.tp.toFixed(6)} SL=${tpsl.sl.toFixed(6)}`, 'ok');
                    this.simMonitor();
                    return;
                }
                
                ui.updateStatus('ƒêang mua...');
                let buyOrder;
                try {
                    buyOrder = await api.buy(best.sym, finalQuote);
                } catch (e) {
                    if (/Insufficient balance|170131/.test(String(e.message))) {
                        ui.logLive('Skip: kh√¥ng ƒë·ªß USDT cho min order. ƒêi·ªÅu ch·ªânh c·∫•u h√¨nh ho·∫∑c n·∫°p th√™m.', 'warn');
                        state.isInPosition = false;
                        return;
                    }
                    throw e;
                }
                ui.logLive(`ƒê√£ ƒë·∫∑t l·ªánh BUY ${best.sym} (id=${buyOrder.orderId})`, 'ok');
                ui.updateStatus('Trong v·ªã th·∫ø');
                await api.cancelAll(best.sym);
                if (BybitBotApp.config.values['TG_onTrade']) {
                    BybitBotApp.telegram.notify(`BUY ${best.sym} ~ ${finalQuote.toFixed(2)} USDT`);
                }
                // update overlay
                try{
                    const kl = await api.klines(best.sym, config.values.tf, 200);
                    const C = kl.map(k=>k.c); const ema20 = utils.indicators.emaSeries(C,20); const ema50 = utils.indicators.emaSeries(C,50);
                    ui.drawLiveStrategy(kl, ema20, ema50, { entry: { t: Date.now(), p: sig.entry }, tp: tpsl.tp, sl: tpsl.sl });
                }catch{}
                
                // Quick symbol validity check after BUY (1x)
                try {
                    await BybitBotApp.api.klines(state.currentPosition.sym, '1', 2);
                } catch (e) {
                    BybitBotApp.ui.logLive(`Symbol kh√¥ng h·ª£p l·ªá sau BUY (${state.currentPosition.sym}). ƒêang tho√°t l·ªánh...`, 'warn');
                    try {
                        const qtyExit = state.currentPosition.sellQty || state.currentPosition.qty;
                        await BybitBotApp.api.sell(state.currentPosition.sym, qtyExit);
                    } catch {}
                    BybitBotApp.liveBot.handlePositionExit(state.currentPosition.entry, 'Invalid symbol fallback');
                    return;
                }

                // Get filled quantity and place OCO
                let filledQty = 0;
                try {
                    // Wait briefly and poll a few times for execution info
                    for (let k=0;k<3;k++){
                        await new Promise(r=>setTimeout(r, 400 + Math.random()*250));
                        const orders = await api.realtimeOrders(best.sym);
                        const exec = orders?.list?.find(o => o.orderId === buyOrder.orderId);
                        filledQty = +(exec?.cumExecQty || 0);
                        if (filledQty > 0) break;
                    }
                } catch (e) {}
                
                let sellQty = filledQty > 0 ? filledQty : qty;
                sellQty = utils.precision.floorStep(sellQty * 0.98, step);
                const info = await api.instruments(best.sym);
                state.currentPosition.sellQty = +utils.precision.fmtQty(sellQty, utils.precision.stepOf(info));
                // set Pump-PRO extras
                state.currentPosition.tp2 = sig?.tp2;
                state.currentPosition.chandelierK = 2.5;
                state.currentPosition.highest = Math.max(state.currentPosition.entry, sig?.entry || state.currentPosition.entry);
                
                if (config.values.useOCOEmu) {
                    const tpOrder = await api.tp(best.sym, state.currentPosition.sellQty, tpsl.tp);
                    const slOrder = await api.sl(best.sym, state.currentPosition.sellQty, tpsl.sl);
                    if (tpOrder.emu || slOrder.emu) {
                        ui.logLive(`K√≠ch ho·∫°t OCO gi·∫£ l·∫≠p cho ${best.sym}`, 'warn');
                        // Only watch for the side that failed. If TP failed, tpPrice is its trigger. If SL failed, slPrice is its trigger.
                        // If both succeed, tpPrice and slPrice will be null.
                        BybitBotApp.oco.watch(
                            best.sym,
                            state.currentPosition.sellQty,
                            tpOrder.emu ? tpOrder.price : null,
                            slOrder.emu ? slOrder.price : null
                        );
                    } else {
                        ui.logLive(`ƒê√£ ƒë·∫∑t OCO tr√™n s√†n v·ªõi qty=${state.currentPosition.sellQty}`, 'ok');
                    }
                }
                this.monitor();
            } catch (e) {
                ui.logLive('L·ªói trong chu tr√¨nh: ' + (e.message || e), 'error');
                state.isInPosition = false;
            }
        },

        monitor() {
            const { state, config, api, ui, ws, utils } = BybitBotApp;
            // If using reliable WS, no need for REST polling
            if (ws.instance && ws.instance.readyState === WebSocket.OPEN && config.values.useOCOEmu) return;

            clearInterval(state.timers.monitor);
            const startTime = Date.now();
            state.timers.monitor = setInterval(async () => {
                try {
                    // Guard ch·ªëng symbol r·ªóng / ƒë√£ tho√°t l·ªánh
                    if (!state.isInPosition || !state.currentPosition?.sym) {
                        clearInterval(state.timers.monitor);
                        return;
                    }
                    const sym = String(state.currentPosition.sym || '').trim();
                    if (!sym) {
                        ui.logLive('Monitor: symbol tr·ªëng ‚Üí d·ª´ng polling.', 'warn');
                        clearInterval(state.timers.monitor);
                        return;
                    }
                    const { currentPosition } = state;
                    const kl = await api.klines(sym, '1', 2);
                    const px = kl[kl.length - 1].c;

                    // Dynamic time-stop based on impulse strength
                    const impulse = Math.abs((state.currentPosition.tp || 0) - state.currentPosition.entry) / Math.max(state.currentPosition.atr||1e-9);
                    const tsMin = Math.max(6, Math.min(14, 6 + (impulse>1.4 ? 4 : 0) + (impulse>1.8 ? 2 : 0)));
                    if (Date.now() - startTime > tsMin * 60 * 1000) {
                        ui.logLive('Time-stop, ƒëang tho√°t l·ªánh...', 'warn');
                        const qtyExit = currentPosition.sellQty || currentPosition.qty;
                        try { await api.sell(sym, qtyExit); } catch (e) { ui.logLive('L·ªói Market SELL: ' + e.message, 'warn'); }
                        this.handlePositionExit(px, 'Time-stop');
                        return;
                    }

                    let newSl = currentPosition.sl, needsUpdate = false, isTrailing = false;
                    if (config.values.useBreakeven && !currentPosition.beLocked && px >= currentPosition.entry + 0.6 * currentPosition.atr) {
                        newSl = Math.max(currentPosition.sl, currentPosition.entry - 0.1 * currentPosition.atr);
                        if (newSl > currentPosition.sl) { currentPosition.beLocked = true; ui.logLive(`BE-lock: d·ªùi SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); if (BybitBotApp.DOMElements['TG_onTrade']?.checked) BybitBotApp.telegram.notify(`[BE] ${currentPosition.sym} SL‚Üí ${newSl.toFixed(6)}`); needsUpdate = true; }
                    }
                    if (config.values.useTrailing && px >= currentPosition.tp) {
                        // Chandelier trailing if TP1 done or price beyond TP1
                        const k = currentPosition.chandelierK || 2.5;
                        const highest = currentPosition.highest = Math.max(currentPosition.highest||px, px);
                        const trail = highest - k * (currentPosition.atr || 0);
                        newSl = Math.max(newSl, trail);
                        if (newSl > currentPosition.sl) { ui.logLive(`Chandelier SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); if (BybitBotApp.DOMElements['TG_onTrade']?.checked) BybitBotApp.telegram.throttle(`trail_${currentPosition.sym}`, 15000, ()=>`[TRAIL] ${currentPosition.sym} SL‚Üí ${newSl.toFixed(6)}`); needsUpdate = true; isTrailing = true; }
                    }

                    // Partial TP1
                    if (BybitBotApp.DOMElements.CO_tp1Enable?.checked && !currentPosition.tp1Done && px >= currentPosition.tp) {
                        const frac = Math.min(0.9, Math.max(0.1, +BybitBotApp.DOMElements.CO_tp1Frac?.value || 0.4));
                        const sellQty = (currentPosition.sellQty || currentPosition.qty) * frac;
                        try { await api.sell(sym, sellQty); } catch {}
                        currentPosition.sellQty = (currentPosition.sellQty || currentPosition.qty) * (1-frac);
                        currentPosition.tp1Done = true; ui.logLive(`[TP1] Ch·ªët ${Math.round(frac*100)}% t·∫°i ${px}`, 'ok'); if (BybitBotApp.DOMElements['TG_onTrade']?.checked) BybitBotApp.telegram.notify(`[TP1] ${currentPosition.sym} ch·ªët ${Math.round(frac*100)}% @ ~${px.toFixed(6)}`);
                        // Move SL to BE
                        newSl = Math.max(newSl, currentPosition.entry);
                        needsUpdate = true;
                    }

                    // Exhaustion: vol z-score xu·ªëng v√† gi√° ph·∫≥ng ‚Üí ch·ªët lu√¥n ph·∫ßn c√≤n l·∫°i
                    try{
                        const kl1x = await BybitBotApp.api.klines(state.currentPosition.sym,'1',35);
                        const V = kl1x.map(k=>k.v||0), C = kl1x.map(k=>k.c);
                        const R = BybitBotApp.utils.stats.rolling(V, 20).at(-1);
                        const vZ = BybitBotApp.utils.stats.z(V.at(-1), R.m, R.s);
                        const flat = Math.abs(C.at(-1) - C.at(-6)) / (C.at(-6)||1) < 0.0025;
                        if ((state.currentPosition.tp1Done || C.at(-1) >= state.currentPosition.tp) && vZ < -0.3 && flat){
                            const qtyExit = state.currentPosition.sellQty || state.currentPosition.qty;
                            await BybitBotApp.api.sell(state.currentPosition.sym, qtyExit);
                            return BybitBotApp.liveBot.handlePositionExit(C.at(-1), 'Exhaustion');
                        }
                    }catch{}

                    // Orderbook flip v·ªÅ phe b√°n r√µ r·ªát ‚Üí tho√°t
                    try{
                        const ob = await BybitBotApp.api.orderbook(state.currentPosition.sym, 50);
                        if ((state.currentPosition.tp1Done || true) && ob.imb < -0.05){
                            const kl2 = await BybitBotApp.api.klines(state.currentPosition.sym,'1',2);
                            const px2 = kl2.at(-1).c;
                            const qtyExit = state.currentPosition.sellQty || state.currentPosition.qty;
                            await BybitBotApp.api.sell(state.currentPosition.sym, qtyExit);
                            return BybitBotApp.liveBot.handlePositionExit(px2, 'OB flip');
                        }
                    }catch{}

                    // TP2 ladder: exit all
                    if (currentPosition.tp2 && px >= currentPosition.tp2){
                        try { await api.sell(sym, currentPosition.sellQty || currentPosition.qty); } catch {}
                        return BybitBotApp.liveBot.handlePositionExit(px, 'TP2 hit');
                    }

                    // Flip m·∫°nh: v·ª´a CUSUM down ho·∫∑c imbVel √¢m nhanh ‚Üí tho√°t
                    try{
                        const od = await BybitBotApp.api.obDelta(state.currentPosition.sym, 30, 800);
                        const k1 = await BybitBotApp.api.klines(state.currentPosition.sym,'1',20);
                        const cus = BybitBotApp.utils.cusumJump(k1.map(k=>k.c), 0.0022, 0.0050);
                        if (cus.down || od.imbVel < -0.12){
                            const px3 = k1.at(-1).c;
                            const q3 = state.currentPosition.sellQty || state.currentPosition.qty;
                            await BybitBotApp.api.sell(state.currentPosition.sym, q3);
                            return BybitBotApp.liveBot.handlePositionExit(px3, 'Flip m·∫°nh');
                        }
                    }catch{}

                    if (needsUpdate && config.values.useOCOEmu) {
                        state.currentPosition.sl = newSl;
                        if (isTrailing) state.currentPosition.tp *= 1.05;
                        await api.cancelAll(sym);
                        const qtyToUse = currentPosition.sellQty || currentPosition.qty;
                        await api.tp(sym, qtyToUse, state.currentPosition.tp);
                        await api.sl(sym, qtyToUse, state.currentPosition.sl);
                        // refresh overlay lines
                        try{
                          const kl = await api.klines(sym, BybitBotApp.config.values.tf, 120);
                          const C = kl.map(k=>k.c); const ema20 = BybitBotApp.utils.indicators.emaSeries(C,20); const ema50 = BybitBotApp.utils.indicators.emaSeries(C,50);
                          BybitBotApp.ui.drawLiveStrategy(kl, ema20, ema50, { tp: state.currentPosition.tp, sl: state.currentPosition.sl });
                        }catch{}
                    }
                } catch (e) {
                    const sym = state.currentPosition?.sym || '‚àÖ';
                    ui.logLive(`L·ªói theo d√µi l·ªánh @ ${sym}: ${e.message}`, 'warn');
                    if (/requested symbol is invalid/i.test(String(e.message))) {
                        clearInterval(state.timers.monitor);
                    }
                }
            }, 8000); // Poll less frequently
        },

        simMonitor() {
            const { state, config, ui } = BybitBotApp;
            clearInterval(state.timers.simMonitor);
            const tS = config.values.timeStopMin * 60 * 1000;
            const st = Date.now();
            let p = state.currentPosition.entry;
            state.timers.simMonitor = setInterval(() => {
                const { currentPosition } = state;
                const d = (Math.random() - .48) * currentPosition.atr * .2;
                p += d;
                const checkExit = (e, n) => {
                    this.handlePositionExit(e, 'SIM ' + n);
                };
                if (p >= currentPosition.tp) return checkExit(currentPosition.tp, 'TP hit');
                if (p <= currentPosition.sl) return checkExit(currentPosition.sl, 'SL hit');
                if (Date.now() - st > tS) return checkExit(p, 'Time-stop');
                if (config.values.useBreakeven && !currentPosition.beLocked && p >= currentPosition.entry + .6 * currentPosition.atr) {
                    currentPosition.sl = Math.max(currentPosition.sl, currentPosition.entry - .1 * currentPosition.atr);
                    currentPosition.beLocked = true;
                    ui.logLive('[SIM] BE Lock: SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
                if (config.values.useTrailing && p > currentPosition.tp) {
                    currentPosition.sl = Math.max(currentPosition.sl, p - .6 * currentPosition.atr);
                    ui.logLive('[SIM] Trailing SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
            }, 1500);
        },
        
        async getUniverseLiveAlt() {
            const { api, config } = BybitBotApp;
            // Mix News hints into universe if available
            try{
                const newsSyms = BybitBotApp.news?.getHints?.() || [];
                if (newsSyms.length){
                    const list = await api.tickers();
                    const EX = new Set(['BTCUSDT','ETHUSDT','USDCUSDT','FDUSDUSDT','TUSDUSDT']);
                    let cands = list
                      .filter(x => x.symbol.endsWith('USDT') && !EX.has(x.symbol))
                      .filter(x => +x.turnover24h > 50_000_000)
                      .filter(x => +x.lastPrice < 10)
                      .map(x => x.symbol);
                    return Array.from(new Set([ ...newsSyms, ...cands ])).slice(0, 30);
                }
            }catch{}
            const list = await api.tickers();
            const EX = new Set(['BTCUSDT', 'ETHUSDT', 'USDCUSDT', 'FDUSDUSDT', 'TUSDUSDT']);
            let cands = list
                .filter(x => x.symbol.endsWith('USDT') && !EX.has(x.symbol))
                .filter(x => !BybitBotApp.filters.isPeggedSymbol(x.symbol))
                .filter(x => +x.turnover24h > 30_000_000)
                .filter(x => +x.lastPrice < 1.5);

            const out = [];
            try{
                const { free } = await api.usdtFreeBalance(false);
                for (const it of cands.slice(0, 120)) {
                    try {
                        const info = await api.instruments(it.symbol);
                        const minAmt = +(info?.lotSizeFilter?.minOrderAmt || 5);
                        if (minAmt <= 5 && minAmt <= (free - 0.2)) out.push(it.symbol);
                        if (out.length >= 30) break;
                    } catch {}
                }
            }catch{}
            // Apply WL/BL and reputation ordering
            let pool = out.length ? out : cands.slice(0, 30).map(x => x.symbol);
            const WL = (BybitBotApp.DOMElements.WL_symbols?.value||'').toUpperCase().split(',').map(s=>s.trim()).filter(Boolean);
            const BL = new Set((BybitBotApp.DOMElements.BL_symbols?.value||'').toUpperCase().split(',').map(s=>s.trim()).filter(Boolean));
            pool = pool.filter(s => !BL.has(s));
            if (WL.length) { const wled = WL.filter(s => pool.includes(s)); pool = Array.from(new Set([...wled, ...pool])); }
            if (BybitBotApp.reputation?.map) pool.sort((a,b)=> (BybitBotApp.reputation.map[b]||0)-(BybitBotApp.reputation.map[a]||0));
            return pool.slice(0, 30);
        },
        
        async scheduler() {
            const { state } = BybitBotApp;
            if (!state.isRunning) return;
            await this.step();
            const delay = this.nextCandleDelayMs();
            state.timers.scheduler = setTimeout(() => this.scheduler(), delay);
        },
        
        nextCandleDelayMs() {
            const n = BybitBotApp.api.now();
            const tfSec = { '1': 60, '3': 180, '5': 300, '15': 900 }[BybitBotApp.config.values.tf] || 300;
            const tfMs = tfSec * 1000;
            const delta = (Math.ceil(n / tfMs) * tfMs) - n;
            let wait = BybitBotApp.config.values.scanSec * 1000;
            if (delta < 12000) wait = Math.min(wait, 4000);
            if (delta < 5000) wait = Math.min(wait, 2000);
            return Math.max(1500, wait);
        }
    },

    // --- Backtester Module ---
    backtester: {
        pnlChartInstance: null,

        async run(isGridSearch = false, gridParams = null) {
            const { config, ui, api, DOMElements } = BybitBotApp;
            config.load();

            ui.logBack('B·∫Øt ƒë·∫ßu Backtest...', 'ok');
            DOMElements.B_run.disabled = true;
            DOMElements.B_grid.disabled = true;
            DOMElements.autopilot.disabled = true;
            DOMElements.logBack.innerHTML = '';
            DOMElements.journalBack.querySelector('tbody').innerHTML = '';
            DOMElements.bySymBack.querySelector('tbody').innerHTML = '';
            DOMElements.B_summary.textContent = 'ƒêang ch·∫°y...';

            try {
                const params = gridParams || {
                    tf: String(config.values.B_tf), lookback: config.values.B_lookback, topN: config.values.B_topN,
                    symbolList: config.values.B_symbolList, btcFilter: config.values.B_btcFilter,
                    pessimistic: config.values.B_pessimistic, minScore: config.values.B_minScore,
                    tpK: config.values.B_tpK, slK: config.values.B_slK,
                    timeStopMin: config.values.B_timeStopMin, quote: config.values.B_quote,
                    feePct: config.values.B_feePct, slipBps: config.values.B_slipBps,
                    useBreakeven: config.values.B_useBreakeven, useTrailing: config.values.B_useTrailing
                };

                let symbols;
                if (params.symbolList.trim()) {
                    symbols = params.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean);
                } else {
                    ui.logBack(`ƒêang t√¨m ${params.topN} coin c√≥ volume cao nh·∫•t...`);
                    const tickers = await api.tickers();
                    symbols = tickers
                        .filter(t => t.symbol.endsWith('USDT'))
                        .filter(t => !/BTC|ETH/.test(t.symbol))
                        .filter(t => !BybitBotApp.filters.isPeggedSymbol(t.symbol))
                        .sort((a, b) => +b.turnover24h - +a.turnover24h)
                        .slice(0, params.topN)
                        .map(t => t.symbol);
                }
                ui.logBack(`Backtest tr√™n c√°c symbols: ${symbols.join(', ')}`);

                let btcData = null;
                if (params.btcFilter) {
                    ui.logBack('ƒêang t·∫£i d·ªØ li·ªáu BTC filter...');
                    btcData = await api.klines('BTCUSDT', '5', Math.max(200, params.lookback));
                }

                const allTrades = [];
                for (const sym of symbols) {
                    ui.logBack(`ƒêang x·ª≠ l√Ω ${sym}...`);
                    try {
                        const klines = await api.klines(sym, params.tf, params.lookback);
                        const trades = this.runSymbol(sym, klines, params, btcData);
                        allTrades.push(...trades);
                    } catch (e) {
                        ui.logBack(`L·ªói khi x·ª≠ l√Ω ${sym}: ${e.message}`, 'error');
                    }
                }

                allTrades.sort((a, b) => a.ts - b.ts);
                
                if (isGridSearch) {
                    const totalPnl = allTrades.reduce((sum, t) => sum + t.pnl, 0);
                    return { pnl: totalPnl, trades: allTrades.length };
                }

                this.generateReport(allTrades, params);

            } catch (e) {
                ui.logBack(`Backtest th·∫•t b·∫°i: ${e.message}`, 'error');
                DOMElements.B_summary.textContent = `L·ªói: ${e.message}`;
            } finally {
                DOMElements.B_run.disabled = false;
                DOMElements.B_grid.disabled = false;
                DOMElements.autopilot.disabled = false;
            }
        },

        runSymbol(symbol, klines, params, btcData) {
            const trades = [];
            let inPosition = false;
            let currentTrade = {};
            const { strategy, indicators } = BybitBotApp.utils;
            const tfMs = (params.tf || 5) * 60 * 1000;

            const isBtcOk = (timestamp) => {
                if (!params.btcFilter || !btcData) return true;
                const btcCandleIndex = btcData.findIndex(k => k.t >= timestamp);
                if (btcCandleIndex < 50) return false;
                const btcSlice = btcData.slice(0, btcCandleIndex + 1);
                const C = btcSlice.map(k => k.c);
                return indicators.sma(C, 20) > indicators.sma(C, 50) && indicators.rsi(C, 14) > 48;
            };

            for (let i = 50; i < klines.length; i++) {
                const currentCandle = klines[i];
                const historicalSlice = klines.slice(0, i + 1);

                if (inPosition) {
                    let exitPrice = null, exitNote = '';
                    const slHit = currentCandle.l <= currentTrade.sl, tpHit = currentCandle.h >= currentTrade.tp;
                    if (slHit && tpHit && params.pessimistic) { exitPrice = currentTrade.sl; exitNote = 'SL Hit (Pessimistic)'; }
                    else if (slHit) { exitPrice = currentTrade.sl; exitNote = 'SL Hit'; }
                    else if (tpHit) { exitPrice = currentTrade.tp; exitNote = 'TP Hit'; }

                    if (!exitPrice && (currentCandle.t - currentTrade.ts) / tfMs > params.timeStopMin / params.tf) {
                        exitPrice = currentCandle.c; exitNote = 'Time-stop';
                    }

                    if (!exitPrice) {
                        if (params.useBreakeven && !currentTrade.beLocked && currentCandle.h >= currentTrade.entry + 0.6 * currentTrade.atr) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentTrade.entry); currentTrade.beLocked = true;
                        }
                        if (params.useTrailing && currentCandle.h >= currentTrade.tp) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentCandle.c - 0.6 * currentTrade.atr);
                            currentTrade.tp = currentCandle.c + (currentTrade.initialTp - currentTrade.entry);
                        }
                    }

                    if (exitPrice) {
                        inPosition = false;
                        currentTrade.exit = exitPrice; currentTrade.note = exitNote;
                        const slip = params.slipBps / 10000, fee = params.feePct / 100;
                        const entryCost = currentTrade.qty * currentTrade.entry * (1 + fee + slip);
                        const exitValue = currentTrade.qty * currentTrade.exit * (1 - fee - slip);
                        currentTrade.pnl = exitValue - entryCost;
                        trades.push(currentTrade);
                    }
                }

                if (!inPosition) {
                    const signal = strategy.pullbackScore(historicalSlice);
                    if (signal.score >= params.minScore && isBtcOk(currentCandle.t)) {
                        const entryPrice = currentCandle.c;
                        const tpsl = strategy.calcTPSL(entryPrice, signal.atr, params.tpK, params.slK);
                        if (tpsl.rr >= 1.2) {
                            inPosition = true;
                            currentTrade = {
                                ts: currentCandle.t, sym: symbol, entry: entryPrice, tp: tpsl.tp, sl: tpsl.sl,
                                initialSl: tpsl.sl, initialTp: tpsl.tp, atr: signal.atr, qty: params.quote / entryPrice, beLocked: false,
                            };
                        }
                    }
                }
            }
            return trades;
        },

        generateReport(trades, params) {
            const { ui, DOMElements } = BybitBotApp;
            ui.renderJournal('journalBack', [...trades].reverse());

            if (trades.length === 0) {
                DOMElements.B_summary.textContent = 'Kh√¥ng c√≥ trade n√†o ƒë∆∞·ª£c th·ª±c hi·ªán.';
                this.drawPnlChart([]);
                return;
            }
            
            const bySymbol = {};
            trades.forEach(t => {
                if (!bySymbol[t.sym]) bySymbol[t.sym] = { trades: 0, wins: 0, pnl: 0, sumR: 0 };
                bySymbol[t.sym].trades++; bySymbol[t.sym].pnl += t.pnl;
                const initialRisk = (t.entry - t.initialSl) * t.qty;
                bySymbol[t.sym].sumR += initialRisk > 0 ? t.pnl / initialRisk : 0;
                if (t.pnl > 0) bySymbol[t.sym].wins++;
            });

            const bySymBody = DOMElements.bySymBack.querySelector('tbody'); bySymBody.innerHTML = '';
            Object.entries(bySymbol).forEach(([sym, data]) => {
                bySymBody.innerHTML += `<tr><td>${sym}</td><td>${data.trades}</td><td>${(data.wins/data.trades*100).toFixed(1)}%</td><td class="${data.pnl>0?'ok':'bad'}">${data.pnl.toFixed(2)}</td><td>${(data.sumR/data.trades).toFixed(2)}</td></tr>`;
            });

            const totalPnl = trades.reduce((s, t) => s + t.pnl, 0), wins = trades.filter(t=>t.pnl>0).length, losses = trades.length - wins;
            const grossP = trades.filter(t=>t.pnl>0).reduce((s,t)=>s+t.pnl,0), grossL = Math.abs(trades.filter(t=>t.pnl<0).reduce((s,t)=>s+t.pnl,0));
            
            let equity=[1000], maxEquity=1000, maxDD=0;
            [...trades].sort((a,b)=>a.ts-b.ts).forEach(t => {
                const newEquity = equity[equity.length - 1] + t.pnl;
                equity.push(newEquity); maxEquity = Math.max(maxEquity, newEquity);
                maxDD = Math.max(maxDD, (maxEquity - newEquity) / maxEquity);
            });

            DOMElements.B_summary.textContent = `
K·∫øt qu·∫£ Backtest
----------------------------------
T·ªïng PnL      : ${totalPnl.toFixed(2)} USDT
T·ªïng s·ªë Trades : ${trades.length}
T·ª∑ l·ªá th·∫Øng   : ${trades.length>0?(wins/trades.length*100).toFixed(1):0}% (${wins} W / ${losses} L)
Profit Factor : ${grossL>0?(grossP/grossL).toFixed(2):'‚àû'}
Max Drawdown  : ${(maxDD * 100).toFixed(2)}%`;

            this.drawPnlChart(trades);
        },

        drawPnlChart(trades) {
            if (this.pnlChartInstance) this.pnlChartInstance.destroy();
            const { DOMElements } = BybitBotApp;
            const ctx = DOMElements.pnlChart.getContext('2d');
            let cumulativePnl = 0;
            const equityData = [...trades].sort((a, b) => a.ts - b.ts).map(trade => ({ x: trade.ts, y: cumulativePnl += trade.pnl }));
            this.pnlChartInstance = new Chart(ctx, {
                type: 'line', data: { datasets: [{ label: 'Equity Curve (USDT)', data: equityData, borderColor: '#58a6ff', backgroundColor: 'rgba(88,166,255,0.1)', borderWidth: 2, pointRadius: 0, fill: true }] },
                options: { scales: { x: { type: 'time', time: { unit: 'day' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { grid: { color: 'rgba(255,255,255,0.1)' } } }, plugins: { legend: { display: false } } }
            });
        },

        drawLiveStrategy(kl, emaF, emaS, overlay={}) {
            const E = BybitBotApp.DOMElements; if (!E.liveStrategyChart) return;
            const ctx = E.liveStrategyChart.getContext('2d');
            if (this.liveStratInstance) this.liveStratInstance.destroy();
            const labels = kl.map(k=>k.t);
            const price = kl.map(k=>k.c);
            const ds = [
              { label:'Price', data: price.map((v,i)=>({x:labels[i], y:v})), borderColor:'#0a84ff', pointRadius:0 },
              { label:'EMA20', data: emaF.map((v,i)=>({x:labels[i], y:v})), borderColor:'#34c759', pointRadius:0 },
              { label:'EMA50', data: emaS.map((v,i)=>({x:labels[i], y:v})), borderColor:'#ff9f0a', pointRadius:0 }
            ];
            // overlays
            try{
              if (BybitBotApp.DOMElements.OV_vwap?.checked){
                let sumPV=0, sumV=0; const vwap=[]; for(let i=0;i<kl.length;i++){ const p=(kl[i].h+kl[i].l+kl[i].c)/3; const v=kl[i].v||0; sumPV+=p*v; sumV+=v; vwap.push(sumV? sumPV/sumV : kl[i].c); }
                ds.push({ label:'VWAP', data:vwap.map((v,i)=>({x:labels[i], y:v})), borderColor:'#8e8e93', pointRadius:0 });
              }
              if (BybitBotApp.DOMElements.OV_bb?.checked){
                const period=20; const std=(arr)=>{const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length);};
                const bbU=[], bbL=[]; for(let i=0;i<price.length;i++){ const w=price.slice(Math.max(0,i-period+1), i+1); const m=w.reduce((a,b)=>a+b,0)/w.length; const s=std(w); bbU.push(m+2*s); bbL.push(m-2*s);} 
                ds.push({ label:'BB Upper', data:bbU.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.4)', pointRadius:0 });
                ds.push({ label:'BB Lower', data:bbL.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.4)', pointRadius:0 });
              }
            }catch{}
            const tMin = labels[0], tMax = labels[labels.length-1];
            if (overlay.entry){
              ds.push({ type:'scatter', label:'Entry', data:[{x: overlay.entry.t||tMax, y: overlay.entry.p}], borderColor:'#34c759', backgroundColor:'#34c759', pointRadius:4, showLine:false });
            }
            if (overlay.exits && overlay.exits.length){
              ds.push({ type:'scatter', label:'Exit', data: overlay.exits.map(e=>({x:e.t||tMax, y:e.p})), borderColor:'#ff3b30', backgroundColor:'#ff3b30', pointRadius:4, showLine:false });
            }
            if (overlay.tp){
              ds.push({ label:'TP', data:[{x:tMin,y:overlay.tp},{x:tMax,y:overlay.tp}], borderColor:'#34c759', borderDash:[6,4], pointRadius:0 });
            }
            if (overlay.sl){
              ds.push({ label:'SL', data:[{x:tMin,y:overlay.sl},{x:tMax,y:overlay.sl}], borderColor:'#ff3b30', borderDash:[6,4], pointRadius:0 });
            }
            this.liveStratInstance = new Chart(ctx, { type:'line', data:{ datasets: ds }, options:{ parsing:false, scales:{ x:{ type:'time'}, y:{} }, plugins:{ legend:{ display:true } } } });
        },

        async gridSearch() {
            const { ui, config, DOMElements } = BybitBotApp;
            ui.logBack('B·∫Øt ƒë·∫ßu Grid Search...', 'ok');
            DOMElements.B_run.disabled = true; DOMElements.B_grid.disabled = true; DOMElements.autopilot.disabled = true;

            const tpRange = [1.0, 1.2, 1.5, 2.0], slRange = [0.6, 0.8, 1.0, 1.2];
            let bestParams = null, bestPnl = -Infinity;
            const totalCombos = tpRange.length * slRange.length;

            for (const [i, tpK] of tpRange.entries()) {
                for (const [j, slK] of slRange.entries()) {
                    const count = i * slRange.length + j + 1;
                    ui.logBack(`[${count}/${totalCombos}] Testing TP=${tpK}, SL=${slK}...`);
                    config.load();
                    const backtestParams = {
                        ...Object.keys(config.values).filter(k=>k.startsWith('B_')).reduce((o,k)=>(o[k.slice(2)]=config.values[k],o),{}),
                        tf: String(config.values.B_tf), tpK: tpK, slK: slK, lookback: 300 // Use shorter lookback for speed
                    };
                    const result = await this.run(true, backtestParams);
                    ui.logBack(`‚Üí PnL: ${result.pnl.toFixed(2)} USDT, Trades: ${result.trades}`);
                    if (result.pnl > bestPnl) { bestPnl = result.pnl; bestParams = { tpK, slK }; }
                }
            }

            if (bestParams) {
                ui.logBack(`Grid Search ho√†n t·∫•t! T·ªët nh·∫•t: TP=${bestParams.tpK}, SL=${bestParams.slK} v·ªõi PnL ${bestPnl.toFixed(2)} USDT`, 'ok');
                DOMElements.B_tpK.value = bestParams.tpK; DOMElements.B_slK.value = bestParams.slK;
                DOMElements.B_tpK.dispatchEvent(new Event('change')); DOMElements.B_slK.dispatchEvent(new Event('change'));
            } else { ui.logBack('Grid Search kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£.', 'warn'); }
            
            DOMElements.B_run.disabled = false; DOMElements.B_grid.disabled = false; DOMElements.autopilot.disabled = false;
            return bestParams;
        },

        async runAutopilot() {
            const { DOMElements, ui, config, liveBot } = BybitBotApp;
            ui.logBack('üöÄ B·∫Øt ƒë·∫ßu Autopilot...', 'ok');
            document.querySelector('.tab[data-tab="back"]').click();

            const bestParams = await this.gridSearch();
            if (!bestParams) { ui.logLive('Autopilot d·ª´ng: kh√¥ng t√¨m ƒë∆∞·ª£c th√¥ng s·ªë t·ªëi ∆∞u.', 'error'); return; }

            ui.logLive('ƒê√£ t·ªëi ∆∞u th√¥ng s·ªë, ƒëang kh·ªüi ƒë·ªông live bot...', 'ok');
            config.load();

            const passphrase = prompt("Nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£ API keys cho Autopilot. B·ªè tr·ªëng ƒë·ªÉ ch·∫°y ·ªü ch·∫ø ƒë·ªô SIM mode.");
            DOMElements.simMode.checked = true;
            if (passphrase) {
                DOMElements.passphrase.value = passphrase;
                if (await config.loadApiKeys()) {
                    DOMElements.simMode.checked = false;
                    ui.logLive('API keys ƒë√£ n·∫°p. Ch·∫°y ch·∫ø ƒë·ªô REAL.', 'ok');
                } else ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'warn');
            } else ui.logLive('Kh√¥ng c√≥ passphrase. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'ok');

            DOMElements.autoMode.checked = true;
            [DOMElements.autoMode, DOMElements.simMode].forEach(el => el.dispatchEvent(new Event('change')));
            
            document.querySelector('.tab[data-tab="live"]').click();
            liveBot.start();
            ui.logLive('üöÄ Autopilot ƒë√£ kh·ªüi ƒë·ªông!', 'ok');
        }
    },

    // --- App Initialization ---
    init() {
        // Cache all DOM elements
        this.DOMElements = {};
        const allIds = [
            ...this.config.ids, 'status', 'watching', 'signal', 'lastUpdate', 'lossStreak', 'pnlDay',
            'logLive', 'journalLive', 'logBack', 'B_summary', 'pnlChart', 'journalBack', 'bySymBack', 'liveStrategyChart',
            'start', 'stop', 'resetDay', 'saveKeys', 'loadKeys', 'clearKeys', 'btn-tg-send', 'tg-msg',
            'B_run', 'B_grid', 'autopilot', 'corsWarn', 'tab-live', 'tab-back', 'tab-help', 'usdtFree',
            // Radar
            'tab-radar','radar-list','R_scan','R_topN','R_minTurnover','R_maxPrice','R_interval','R_auto',
            'RA_enable','RA_retMin','RA_retPct','RA_volSpike','RA_coolMin',
            // Daily report
            'DR_enable','DR_time','DR_send',
            // News
            'tab-news','news-list','NW_refresh','NW_src_coindesk','NW_src_cointele','NW_src_binance','NW_keywords','NW_interval','NW_auto','NW_forward'
        ];
        allIds.forEach(id => this.DOMElements[id] = document.getElementById(id));

        // Setup UI
        const tabs = [...document.querySelectorAll('.tab')];
        const views = { live: this.DOMElements['tab-live'], back: this.DOMElements['tab-back'], help: this.DOMElements['tab-help'] };
        tabs.forEach(t => t.onclick = () => {
            tabs.forEach(x => x.classList.remove('active'));
            t.classList.add('active');
            Object.values(views).forEach(v => v.classList.remove('active'));
            (views[t.dataset.tab] || this.DOMElements[`tab-${t.dataset.tab}`])?.classList.add('active');
        });

        // Load config and journal
        this.config.loadFromStorage();
        this.config.reputationInit?.();
        this.journal.load();
        // Apply compact mode on load
        try{ if (this.DOMElements.uiCompact?.checked) document.body.classList.add('compact'); }catch{}
        
        // Attach event listeners
        this.config.ids.forEach(id => {
            const el = this.DOMElements[id];
            if (el) el.addEventListener('change', () => {
                this.config.load();
                this.config.saveToStorage();
                if (id === 'uiCompact') {
                    if (el.checked) document.body.classList.add('compact');
                    else document.body.classList.remove('compact');
                }
            });
        });
        
        this.DOMElements.saveKeys.onclick = () => this.config.saveApiKeys();
        this.DOMElements.loadKeys.onclick = () => this.config.loadApiKeys();
        this.DOMElements.clearKeys.onclick = () => this.config.clearApiKeys();
        this.DOMElements.resetDay.onclick = () => this.journal.reset();
        
        this.DOMElements.start.onclick = () => this.liveBot.start();
        this.DOMElements.stop.onclick = () => this.liveBot.stop();
        
        // Attach backtester listeners
        this.DOMElements.B_run.onclick = () => this.backtester.run();
        this.DOMElements.B_grid.onclick = () => this.backtester.gridSearch();
        this.DOMElements.autopilot.onclick = () => this.backtester.runAutopilot();

        // Radar auto toggle
        const rAuto = this.DOMElements.R_auto; if (rAuto) {
            rAuto.addEventListener('change', ()=>{
                if (rAuto.checked) BybitBotApp.radar.startAuto(); else BybitBotApp.radar.stopAuto();
            });
        }

        // Daily report controls
        if (this.DOMElements.DR_send) this.DOMElements.DR_send.onclick = () => this.dailyReport.sendNow();
        const drEnable = this.DOMElements.DR_enable; if (drEnable) {
            drEnable.addEventListener('change', ()=>{
                if (drEnable.checked) this.dailyReport.start(); else this.dailyReport.stop();
            });
        }

        // Coaching actions
        const coBtn = this.DOMElements.CO_analyze; if (coBtn) coBtn.onclick = () => this.coaching.run();

        // News
        if (this.DOMElements.NW_refresh) this.DOMElements.NW_refresh.onclick = () => this.news.render();
        const nwAuto = this.DOMElements.NW_auto; if (nwAuto){ nwAuto.addEventListener('change', ()=>{ if (nwAuto.checked) this.news.startAuto(); else this.news.stopAuto(); }); }

        // Sanitize symbol list input
        const symEl = this.DOMElements.symbolList;
        if (symEl) symEl.addEventListener('change', () => {
            const clean = symEl.value
                .toUpperCase()
                .replace(/[^\w,]/g, ',')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean)
                .join(',');
            if (clean !== symEl.value) symEl.value = clean;
            this.config.load();
            this.config.saveToStorage();
        });

        // Panic Sell button & hotkey (Shift+P)
        if (this.DOMElements.panicSell) this.DOMElements.panicSell.onclick = async () => {
            try{
                const { state, api, ui } = BybitBotApp; const pos = state.currentPosition; if (!state.isInPosition || !pos?.sym) return;
                ui.logLive('Panic Sell initiated...', 'warn');
                const qtyExit = pos.sellQty || pos.qty;
                await api.sell(pos.sym, qtyExit);
                let exitPx = pos.entry;
                try {
                    const t = await api.pub('/v5/market/tickers', { category: 'spot', symbol: pos.sym });
                    if (t?.retCode === 0) exitPx = +t.result.list[0].lastPrice || exitPx;
                } catch {}
                BybitBotApp.liveBot.handlePositionExit(exitPx, 'Panic Sell');
            }catch(e){ BybitBotApp.ui.logLive('Panic Sell error: '+e.message, 'error'); }
        };
        window.addEventListener('keydown', (ev)=>{ if (ev.shiftKey && (ev.key==='P' || ev.key==='p')) this.DOMElements.panicSell?.click(); });
        
        if (this.config.values.autoRun) {
            this.liveBot.start();
        }
        if (this.DOMElements['btn-tg-send']) this.DOMElements['btn-tg-send'].onclick = () => this.telegram.sendTest();
        const vBtn = document.getElementById('btn-tg-validate'); if (vBtn) vBtn.onclick = () => this.telegram.validate();
        const dBtn = document.getElementById('btn-tg-detect'); if (dBtn) dBtn.onclick = () => this.telegram.detectChatId();
        const sHB = ()=>{ const E=BybitBotApp.DOMElements; if (E['TG_onStatus']?.checked) BybitBotApp.telegram.startHeartbeat(); else BybitBotApp.telegram.stopHeartbeat(); };
        ;['TG_onStatus','TG_statusMin'].forEach(id=>{ const el = BybitBotApp.DOMElements[id]; if (el) el.addEventListener('change', sHB); });
        sHB();
    },

    // --- Reputation store ---
    reputation: {
        map: {},
        load(){ try{ this.map = JSON.parse(localStorage.getItem('bb_sym_rep')||'{}'); }catch{ this.map = {}; } },
        save(){ try{ localStorage.setItem('bb_sym_rep', JSON.stringify(this.map)); }catch{} },
        bump(sym, delta){ this.map[sym] = (this.map[sym]||0) + delta; this.save(); }
    },

    // --- Adaptive telemetry (rolling 90m) ---
    adapt: {
        win: [],
        push(e){ this.win.push({ ...e }); const t = Date.now() - 90*60*1000; this.win = this.win.filter(x => x.ts >= t); },
        stats(){
            const W = this.win.slice(); if (!W.length) return { F:0, H:0, P:0 };
            const took = W.filter(x=>x.took).length;
            const tSpan = (W.at(-1).ts - (W[0]?.ts||W.at(-1).ts)) / 3600000;
            const F = took / Math.max(tSpan || 0, 0.25);
            const H = took ? (W.filter(x=>x.took && (x.pnl||0) > 0).length / took) : 0;
            const pSum = W.filter(x=>x.took).reduce((s,x)=> s + Math.max(0, x.pnl||0), 0);
            const lSum = Math.abs(W.filter(x=>x.took).reduce((s,x)=> s + Math.min(0, x.pnl||0), 0));
            const P = lSum > 0 ? (pSum / lSum) : 0;
            return { F, H, P };
        }
    },
};

// --- Start the application ---
window.addEventListener('DOMContentLoaded', () => BybitBotApp.init());

// Runtime UI reorganizer for Live tab
(function(){
function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded',fn); }
ready(function(){
const live = document.getElementById('tab-live');
if(!live) return;
const grid = live.querySelector(':scope > .grid');
if(!grid) return;

// 1) Move Strategy View card to the top and wrap canvas
const stratCard = Array.from(grid.children).find(el => el.querySelector('b')?.textContent?.trim() === 'Strategy View');
if (stratCard) {
  grid.insertBefore(stratCard, grid.firstElementChild);
  const canvas = stratCard.querySelector('#liveStrategyChart');
  if (canvas && !(canvas.parentElement && canvas.parentElement.classList && canvas.parentElement.classList.contains('chart-box'))){
    const box = document.createElement('div'); box.className='chart-box'; box.style.marginTop='10px';
    canvas.parentElement.insertBefore(box, canvas); box.appendChild(canvas);
  }
}

// 2) Collapse API & Strategy cards
const targets = Array.from(grid.children).filter(card => {
  const t = card.querySelector('b')?.textContent?.trim() || '';
  return t.startsWith('2) Strategy') || t.startsWith('1) API');
});
targets.forEach(card => {
  const titleEl = card.querySelector('b'); if(!titleEl) return;
  const title = titleEl.textContent.trim();
  const details = document.createElement('details');
  details.className = 'card col-12 collapse';
  const sum = document.createElement('summary'); sum.textContent = title; details.appendChild(sum);
  const body = document.createElement('div');
  titleEl.remove();
  while(card.firstChild){ body.appendChild(card.firstChild); }
  details.appendChild(body);
  grid.replaceChild(details, card);
});

// 3) Auto-apply compact UI
try{
  const uiCompact = document.getElementById('uiCompact');
  if (uiCompact && !uiCompact.checked){ uiCompact.checked = true; uiCompact.dispatchEvent(new Event('change')); }
}catch{}

// 4) Ensure chart resizes when switching back to Live tab
try{
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(t => t.addEventListener('click', () => {
    if (t.dataset.tab === 'live') {
      try { BybitBotApp.ui.liveStratInstance?.resize(); } catch {}
    }
  }));
}catch{}
});
})();

// PATCH 3 ‚Äî Layout: 3-up row and merge Telegram into API card
(function(){
function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded',fn); }
ready(function(){
  const live = document.getElementById('tab-live'); if(!live) return;
  const grid = live.querySelector(':scope > .grid'); if(!grid) return;

  const findCardByTitle = (txt) => Array.from(grid.children).find(el => el.querySelector('b')?.textContent?.trim() === txt);
  const strat = findCardByTitle('Strategy View');
  const log   = findCardByTitle('Live Log');
  const jour  = findCardByTitle('Journal & Performance (Live)');
  const setCol = (el, span) => { if (!el) return; ['col-3','col-4','col-5','col-6','col-7','col-8','col-12'].forEach(c=>el.classList.remove(c)); el.classList.add('col-'+span); };

  setCol(strat, 6); setCol(log, 3); setCol(jour, 3);
  if (strat) grid.insertBefore(strat, grid.firstElementChild);
  if (log)   grid.insertBefore(log, strat?.nextElementSibling || grid.firstElementChild);
  if (jour)  grid.insertBefore(jour, log?.nextElementSibling || strat?.nextElementSibling || grid.firstElementChild);

  try{
    const logBox = document.getElementById('logLive');
    if (logBox){ logBox.style.height = 'auto'; logBox.classList.add('fixed-scroll'); }
  }catch{}

  try{
    const jourCard = jour; const table = document.getElementById('journalLive');
    if (jourCard && table){ let wrap = jourCard.querySelector('.journal-clip'); if (!wrap){ wrap = document.createElement('div'); wrap.className = 'journal-clip'; table.parentElement.insertBefore(wrap, table); wrap.appendChild(table); } }
  }catch{}

  const teleCard = findCardByTitle('Telegram Alerts');
  const apiDetails = Array.from(grid.children).find(el => el.matches('details.card.collapse') && el.querySelector('summary')?.textContent?.trim().startsWith('1) API'));
  if (teleCard && apiDetails){
    const body = apiDetails.querySelector('div');
    const teleTitle = teleCard.querySelector('b');
    const teleContent = document.createElement('div');
    const frag = document.createDocumentFragment();
    Array.from(teleCard.childNodes).forEach(n => { if (n !== teleTitle) frag.appendChild(n); });
    teleContent.appendChild(frag);
    const sep = document.createElement('hr'); sep.style.margin = '12px 0';
    const h = document.createElement('div'); h.style.fontWeight = '600'; h.style.margin = '4px 0 8px'; h.textContent = 'Telegram Alerts';
    body.appendChild(sep); body.appendChild(h); body.appendChild(teleContent);
    teleCard.remove();
  }
});
})();

</script>
</body>
</html>

