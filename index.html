<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <title>Bybit Browser Bot v7.0 (UI Polish) ‚Äî Autopilot ‚Ä¢ ALT Hunter</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    /* macOS-inspired light palette */
    :root{
      --bg:#f5f5f7;              /* macOS window background */
      --card:#ffffff;            /* surfaces */
      --line:#d2d2d7;            /* separators */
      --text:#1d1d1f;            /* primary */
      --muted:#6e6e73;           /* secondary */
      --ok:#34c759;              /* system green */
      --bad:#ff3b30;             /* system red */
      --warn:#ff9f0a;            /* system orange */
      --accent:#0a84ff;          /* system blue */
      --shadow:0 1px 3px rgba(0,0,0,0.06), 0 6px 16px rgba(0,0,0,0.06);
      --card-bg:linear-gradient(180deg, #ffffff 0%, #fafafa 100%);
      --control:#ffffff;
      --control-line:#d2d2d7;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{max-width:1280px;margin:24px auto;padding:0 20px}
    h1{margin:0 0 12px;font-size:24px; font-weight: 500;}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px}
    .card{background:var(--card-bg);border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:var(--shadow)}
    .col-3{grid-column:span 3}.col-4{grid-column:span 4}.col-5{grid-column:span 5}.col-6{grid-column:span 6}.col-7{grid-column:span 7}.col-8{grid-column:span 8}.col-12{grid-column:span 12}
    @media (max-width: 992px) { .col-3, .col-4, .col-5 { grid-column: span 6; } }
    @media (max-width: 768px) { .col-3, .col-4, .col-5, .col-6, .col-7, .col-8 { grid-column: span 12; } }
    label{display:block;color:var(--muted);font-size:12px;margin:8px 0 6px; font-weight: 600;}
    input,select,textarea{width:100%;background:var(--control);border:1px solid var(--control-line);color:var(--text);border-radius:10px;padding:10px; transition: border-color 0.15s ease, box-shadow 0.15s ease;}
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 4px rgba(10,132,255,0.16);}
    input[type="checkbox"]{width:auto; accent-color: var(--accent);}    
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 12px;border-radius:999px;background:var(--control);border:1px solid var(--control-line);color:var(--text); cursor:pointer; font-size: 13px; box-shadow: var(--shadow);}
    .tiny{font-size:12px;color:var(--muted); opacity: 0.9;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--ok)}.bad{color:var(--bad)}.warn{color:var(--warn)}
    #logLive,#logBack{height:220px;overflow:auto;background:#fff;border:1px solid var(--line);border-radius:10px;padding:12px;white-space:pre-wrap; font-size: 13px; line-height: 1.6; box-shadow: var(--shadow);}
    table{width:100%;border-collapse:collapse;margin-top:8px;} th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left; font-size: 13px;} th {color: var(--muted); font-weight: 500;}
    .tabs{display:flex;gap:8px;margin:16px 0; border-bottom: 1px solid var(--line);}    
    .tab{padding:10px 16px;border:1px solid var(--control-line); border-bottom: 2px solid transparent; border-radius:10px 10px 0 0; color: var(--muted); cursor:pointer; transition: all 0.2s ease; margin-bottom: -1px; background:#fbfbfd;}
    .tab:hover { background: #fff; color: var(--text); }
    .tab.active{background:#fff; color:var(--text); border-bottom-color:var(--accent); box-shadow: var(--shadow);}    
    .tabview{display:none}.tabview.active{display:block}
    .btn{
        width:auto; padding: 10px 16px; font-weight: 600; cursor: pointer; border-radius: 10px;
        background: #ffffff; border: 1px solid var(--control-line); color: var(--text);
        transition: all 0.15s ease; box-shadow: var(--shadow);
    }
    .btn:hover:not(:disabled){background:#fefefe; border-color: var(--accent);}    
    .btn:disabled { opacity: 0.6; cursor: not-allowed;}
    button#start, button#B_run, button#autopilot { background: var(--accent); border-color: var(--accent); color: white; }
    button#start:hover:not(:disabled), button#B_run:hover:not(:disabled), button#autopilot:hover:not(:disabled) { filter: brightness(1.05); }
    button#stop { background: var(--bad); border-color: var(--bad); color: white;}
    button#stop:hover:not(:disabled) { filter: brightness(1.05); }

    /* Compact mode overrides */
    body.compact{font-size:13px}
    body.compact .wrap{max-width:1140px}
    body.compact .grid{gap:10px}
    body.compact .card{padding:10px;border-radius:10px}
    body.compact input, body.compact select, body.compact textarea{padding:8px;border-radius:8px}
    body.compact .pill{padding:5px 10px}
    body.compact .btn{padding:8px 12px;border-radius:8px}
    body.compact label{margin:6px 0 4px;font-size:11px}
    body.compact .tiny{font-size:11px}
    body.compact table th, body.compact table td{padding:6px 8px;font-size:12px}
    body.compact #logLive, body.compact #logBack{height:160px;padding:8px}
    body.compact .tab{padding:8px 12px}
    body.compact #liveStrategyChart{height:280px !important}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Bybit Browser Bot v7.0 <span class="tiny">‚Äî T·ªëi ∆∞u ho√° ‚Ä¢ Autopilot ‚Ä¢ ALT Hunter</span></h1>
  <div class="tabs">
    <div class="tab active" data-tab="live">‚ö° Live Bot</div>
    <div class="tab" data-tab="back">‚õè Backtester</div>
    <div class="tab" data-tab="radar">üìä Radar</div>
    <div class="tab" data-tab="news">üì∞ News</div>
    <div class="tab" data-tab="help">üß† Autopilot & Help</div>
  </div>

  <!-- LIVE TAB -->
  <section class="tabview active" id="tab-live">
    <div class="grid">
      <div class="card col-4">
        <b>1) API & Security</b>
        <label>API Key</label><input id="apiKey" placeholder="BYBITxxxx" autocomplete="off" spellcheck="false" />
        <label>API Secret</label><input id="apiSecret" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="off" spellcheck="false" />
        <label>Encryption Passphrase</label><input id="passphrase" type="password" placeholder="e.g., batman-2002" autocomplete="new-password" />
        <div class="row" style="margin-top:12px">
          <button id="saveKeys" class="btn">Save</button>
          <button id="loadKeys" class="btn">Load</button>
          <button id="clearKeys" class="btn">Clear</button>
        </div>
        <div class="row" style="margin-top:12px">
          <label class="pill"><input id="useTestnet" type="checkbox" checked> Testnet</label>
          <label class="pill"><input id="simMode" type="checkbox"> SIM mode</label>
          <label class="pill"><input id="autoRun" type="checkbox"> Auto‚Äërun</label>
          <label class="pill" title="Thu nh·ªè UI, gi·∫£m kho·∫£ng tr·ªëng"><input id="uiCompact" type="checkbox"> Compact UI</label>
        </div>
        <div class="tiny" style="margin-top:12px">‚ö†Ô∏è Spot trading only. Secrets are AES‚ÄëGCM encrypted with your passphrase and saved in local storage.</div>
        <div class="tiny warn" id="corsWarn" style="display:none;margin-top:6px">CORS error detected ‚Üí Use Testnet or a private Proxy.</div>
      </div>

      <div class="card col-8">
        <b>2) Strategy & Automation (Live)</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>USDT per Trade</label><input id="orderQuote" type="number" min="5" step="0.1" value="8"/></div>
          <div class="col-3"><label>Candle Timeframe</label><select id="tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-3"><label>Recv Window (ms)</label><input id="recvWindow" type="number" value="5000"/></div>
          <div class="col-3"><label>Proxy (optional)</label><input id="proxy" placeholder="https://your-worker.workers.dev" inputmode="url" spellcheck="false" autocomplete="off" /></div>
          <div class="col-12 row">
            <label class="pill"><input id="autoMode" type="checkbox"> Auto Buy</label>
            <label class="pill"><input id="btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
            <label class="pill"><input id="useTrailing" type="checkbox" checked> Trailing SL</label>
            <label class="pill"><input id="useBreakeven" type="checkbox" checked> Breakeven Lock</label>
            <label class="pill"><input id="useOCOEmu" type="checkbox" checked> Emulated OCO</label>
          </div>
          <div class="col-12 row">
            <label class="pill"><input id="useBalanceSizing" type="checkbox" checked> Use % Balance Sizing</label>
            <div style="width:110px"><label>Risk %</label><input id="riskPct" type="number" step="0.5" value="15"/></div>
            <div style="width:130px"><label>Reserve (USDT)</label><input id="reserveUsd" type="number" step="0.1" value="2"/></div>
            <div style="width:130px"><label>Min / Max (USDT)</label><input id="minQuote" type="number" step="0.1" value="5"/></div>
            <div style="width:110px"><label>&nbsp;</label><input id="maxQuote" type="number" step="0.1" value="25"/></div>
            <div style="width:160px"><label>Account Type</label>
              <select id="balanceAcct"><option value="AUTO" selected>AUTO</option><option value="SPOT">SPOT</option><option value="UNIFIED">UNIFIED</option></select>
            </div>
          </div>
          <div class="col-12"><label>Symbol List (CSV, empty = ALT Hunter)</label><input id="symbolList" placeholder="Leave empty for auto-selection of trending ALTs"/></div>
          <div class="col-3"><label>Min Signal Score (>=)</label><input id="minScore" type="number" value="5"/></div>
          <div class="col-3"><label>Time‚Äëstop (minutes)</label><input id="timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>Max Daily Losses</label><input id="maxLossDay" type="number" value="2"/></div>
          <div class="col-3"><label>Base Scan Interval (s)</label><input id="scanSec" type="number" value="20"/></div>
        </div>
        <div class="grid" style="margin-top:12px">
          <div class="col-12" style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px">
            <div><div class="tiny">Status</div><div id="status" class="ok">Idle</div></div>
            <div><div class="tiny">Watching</div><div id="watching">‚Äî</div></div>
            <div><div class="tiny">Signal</div><div id="signal">‚Äî</div></div>
            <div><div class="tiny">Last Update</div><div id="lastUpdate">‚Äî</div></div>
            <div><div class="tiny">Daily Losses</div><div id="lossStreak">0</div></div>
            <div><div class="tiny">Daily PnL</div><div id="pnlDay">0.00</div></div>
             <div><div class="tiny">USDT free</div><div id="usdtFree">‚Äî</div></div>
          </div>
        </div>
        <div class="row" style="margin-top:12px">
          <button id="start" class="btn" title="B·∫Øt ƒë·∫ßu ch·∫°y bot (Live ho·∫∑c SIM)">‚ñ∂ Start</button>
          <button id="stop" class="btn" title="D·ª´ng to√†n b·ªô ho·∫°t ƒë·ªông giao d·ªãch">‚ñ† Stop</button>
          <button id="resetDay" class="btn" title="Xo√° PnL v√† chu·ªói l·ªó c·ªßa phi√™n hi·ªán t·∫°i">‚ü≤ Reset Session</button>
          <button id="panicSell" class="btn" title="B√°n h·∫øt ngay l·∫≠p t·ª©c (Panic Sell)">‚ö† Panic Sell</button>
          <label class="pill" style="margin-left:auto;"><input id="autoResetStart" type="checkbox" checked> Auto-reset on start</label>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="col-12"><b>Advanced Filters</b></div>
          <div class="col-4"><label>MTF Confirm</label>
            <div class="row"><label class="pill"><input id="CO_mtfEnable" type="checkbox"> Enable</label>
              <div style="width:120px"><select id="CO_mtfTf"><option value="15">15m</option><option value="60">1h</option></select></div>
            </div>
          </div>
          <div class="col-4"><label>Regime Mode</label>
            <select id="CO_regimeMode"><option value="AUTO" selected>AUTO</option><option value="TREND">TREND</option><option value="MEANREV">MEANREV</option><option value="SIDEWAYS">SIDEWAYS</option></select>
          </div>
          <div class="col-4"><label>Time Window (local)</label>
            <div class="row">
              <input id="CO_winStart" type="time" value="00:00" style="width:120px">
              <input id="CO_winEnd" type="time" value="23:59" style="width:120px">
            </div>
          </div>
          <div class="col-4"><label>Cooldown after SL streak</label>
            <div class="row"><div style="width:110px"><input id="CO_slStreak" type="number" value="3" title="S·ªë SL li√™n ti·∫øp"/></div>
            <div style="width:140px"><input id="CO_coolMin" type="number" value="20" title="Cooldown (ph√∫t)"/></div></div>
          </div>
          <div class="col-4"><label>Spread Guard (bps)</label><input id="CO_maxSpreadBps" type="number" value="15" /></div>
          <div class="col-4"><label>Partial TP1</label>
            <div class="row"><label class="pill"><input id="CO_tp1Enable" type="checkbox"> Enable</label>
              <div style="width:120px"><input id="CO_tp1Frac" type="number" step="0.05" value="0.4" title="Fraction 0-1"/></div>
            </div>
          </div>
        </div>
        <div class="grid" style="margin-top:10px">
          <div class="col-12"><b>Chart Overlays</b></div>
          <label class="pill"><input id="OV_vwap" type="checkbox"> VWAP</label>
          <label class="pill"><input id="OV_bb" type="checkbox"> Bollinger Bands</label>
          <label class="pill"><input id="OV_vol" type="checkbox"> Volume</label>
        </div>
      </div>

      <div class="card col-12">
        <b>Live Log</b>
        <div id="logLive" role="log" aria-live="polite"></div>
      </div>
      <div class="card col-12">
        <b>Strategy View</b>
        <canvas id="liveStrategyChart" style="margin-top:10px; height:360px"></canvas>
      </div>
      <div class="card col-12">
        <b>Journal & Performance (Live)</b>
        <table id="journalLive"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>Result/PnL</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="card col-12">
        <b>Telegram Alerts</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-4"><label>Bot Token</label><input id="tg-token" placeholder="123456:ABC-DEF..." autocomplete="off" spellcheck="false" /></div>
          <div class="col-4"><label>Chat ID</label><input id="tg-chatid" placeholder="-1001234..." autocomplete="off" spellcheck="false" /></div>
          <div class="col-4"><label>Test Message</label><input id="tg-msg" placeholder="Hello from Bybit Bot" autocomplete="off" spellcheck="false" /></div>
        </div>
        <div class="row" style="margin-top:8px; gap:8px; flex-wrap:wrap">
          <button class="btn" id="btn-tg-validate" title="Ki·ªÉm tra token bot h·ª£p l·ªá">Validate Token</button>
          <button class="btn" id="btn-tg-detect" title="L·∫•y Chat ID t·ª± ƒë·ªông t·ª´ getUpdates (h√£y nh·∫Øn cho bot tr∆∞·ªõc)">Detect Chat ID</button>
          <button class="btn" id="btn-tg-send" title="G·ª≠i tin nh·∫Øn th·ª≠ t·ªõi Chat ID">Send Test</button>
          <label class="pill"><input class="bot-param" id="TG_onTrade" type="checkbox" checked> Notify on Entry/Exit</label>
          <label class="pill"><input class="bot-param" id="TG_onLifecycle" type="checkbox" checked> Notify on Start/Stop</label>
        </div>
        <div class="tiny" style="margin-top:6px; color:var(--muted)">G·ª£i √Ω: 1) B·∫•m Validate Token ‚Üí 2) Nh·∫Øn b·∫•t k·ª≥ cho bot ‚Üí 3) Detect Chat ID ‚Üí 4) Send Test.</div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-radar">
    <div class="grid">
      <div class="card col-12">
        <b>Momentum Radar (Top ALT theo ƒë·ªông l∆∞·ª£ng & thanh kho·∫£n)</b>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <div style="width:140px"><label>Top N</label><input id="R_topN" type="number" value="12" /></div>
          <div style="width:200px"><label>Min Turnover 1h (USDT)</label><input id="R_minTurnover" type="number" value="3000000" /></div>
          <div style="width:160px"><label>Max Price (USDT)</label><input id="R_maxPrice" type="number" value="10" /></div>
          <div style="width:140px"><label>Refresh (min)</label><input id="R_interval" type="number" value="5" /></div>
          <label class="pill"><input id="R_auto" type="checkbox"> Auto refresh</label>
          <button class="btn" id="R_scan" title="Qu√©t l·∫°i th·ªã tr∆∞·ªùng">üîÑ Scan</button>
          <div class="tiny" style="margin-left:auto; color:var(--muted)">M·∫πo: Ch·ªçn coin c√≥ %24h d∆∞∆°ng v√† turnover l·ªõn ‚Üí ƒë√† t·ªët h∆°n.</div>
        </div>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="RA_enable" type="checkbox"> B·∫≠t c·∫£nh b√°o bi·∫øn ƒë·ªông l·∫°</label>
          <div style="width:120px"><label>Lookback (min)</label><input id="RA_retMin" type="number" value="5" /></div>
          <div style="width:140px"><label>Ng∆∞·ª°ng Œî% (abs)</label><input id="RA_retPct" type="number" value="3" /></div>
          <div style="width:140px"><label>Vol spike (√ó)</label><input id="RA_volSpike" type="number" step="0.1" value="2" /></div>
          <div style="width:150px"><label>Cooldown (min)</label><input id="RA_coolMin" type="number" value="30" /></div>
        </div>
      </div>
      <div class="card col-12">
        <div id="radar-list" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px"></div>
      </div>
      <div class="card col-12">
        <b>Daily Market Report</b>
        <div class="row" style="margin-top:8px; gap:10px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="DR_enable" type="checkbox"> B·∫≠t b√°o c√°o t·ª± ƒë·ªông</label>
          <div style="width:160px"><label>Gi·ªù g·ª≠i (HH:MM)</label><input id="DR_time" type="time" value="09:00" /></div>
          <button class="btn" id="DR_send" title="T·∫°o & g·ª≠i b√°o c√°o ngay">üì§ Send Now</button>
          <div class="tiny" style="color:var(--muted)">S·∫Ω g·ª≠i qua Telegram n·∫øu token/chat ID h·ª£p l·ªá.</div>
        </div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-news">
    <div class="grid">
      <div class="card col-12">
        <b>Crypto News</b>
        <div class="row" style="margin-top:8px; gap:8px; align-items:flex-end; flex-wrap:wrap">
          <label class="pill"><input id="NW_src_coindesk" type="checkbox" checked> CoinDesk</label>
          <label class="pill"><input id="NW_src_cointele" type="checkbox" checked> Cointelegraph</label>
          <label class="pill"><input id="NW_src_binance" type="checkbox"> Binance Blog</label>
          <div style="width:260px"><label>T·ª´ kho√° (CSV, v√≠ d·ª•: BTC,ETF)</label><input id="NW_keywords" placeholder="" /></div>
          <div style="width:120px"><label>Refresh (min)</label><input id="NW_interval" type="number" value="15" /></div>
          <label class="pill"><input id="NW_auto" type="checkbox"> Auto</label>
          <label class="pill"><input id="NW_forward" type="checkbox"> Forward Telegram</label>
          <button class="btn" id="NW_refresh">üîÑ Refresh now</button>
        </div>
      </div>
      <div class="card col-12">
        <div id="news-list" style="display:grid; grid-template-columns:repeat(2,1fr); gap:10px"></div>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-back">
    <div class="grid">
      <div class="card col-5">
        <b>Backtester ‚Äì Data Configuration</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-4"><label>Candle Timeframe</label><select id="B_tf"><option value="1">1m</option><option value="3">3m</option><option value="5" selected>5m</option><option value="15">15m</option></select></div>
          <div class="col-4"><label>Lookback (candles)</label><input id="B_lookback" type="number" value="1000" /></div>
          <div class="col-4"><label>Top N Coins by Turnover</label><input id="B_topN" type="number" value="12" /></div>
          <div class="col-12"><label>Symbol List (CSV, empty = top N)</label><input id="B_symbolList" placeholder="BTCUSDT,ETHUSDT,SOLUSDT"/></div>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="pill"><input id="B_btcFilter" type="checkbox" checked> BTC 5m Uptrend Filter</label>
          <label class="pill"><input id="B_pessimistic" type="checkbox" checked> Pessimistic fills (SL first)</label>
        </div>
      </div>
      <div class="card col-7">
        <b>Backtester ‚Äì Strategy & Fees</b>
        <div class="grid" style="margin-top:6px">
          <div class="col-3"><label>Min Score</label><input id="B_minScore" type="number" value="5"/></div>
          <div class="col-3"><label>TP = k√óATR</label><input id="B_tpK" type="number" step="0.1" value="1.2"/></div>
          <div class="col-3"><label>SL = k√óATR</label><input id="B_slK" type="number" step="0.1" value="0.8"/></div>
          <div class="col-3"><label>Time‚Äëstop (min)</label><input id="B_timeStopMin" type="number" value="15"/></div>
          <div class="col-3"><label>USDT/Trade</label><input id="B_quote" type="number" step="0.1" value="8"/></div>
          <div class="col-3"><label>Taker Fee (%)</label><input id="B_feePct" type="number" step="0.01" value="0.10"/></div>
          <div class="col-3"><label>Slippage (bps)</label><input id="B_slipBps" type="number" step="0.1" value="2"/></div>
          <div class="col-3 row"><label class="pill"><input id="B_useBreakeven" type="checkbox" checked> BE Lock</label></div>
          <div class="col-9 row"><label class="pill"><input id="B_useTrailing" type="checkbox" checked> Trailing after TP</label></div>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="B_run" class="btn" title="Ch·∫°y backtest v·ªõi th√¥ng s·ªë hi·ªán t·∫°i">‚ñ∂ Backtest</button>
          <button id="B_grid" class="btn" title="T√¨m TP/SL t·ªëi ∆∞u b·∫±ng Grid Search">‚õè Grid Search</button>
          <button id="autopilot" class="btn" title="T·ªëi ∆∞u th√¥ng s·ªë r·ªìi kh·ªüi ƒë·ªông bot t·ª± ƒë·ªông">üöÄ Autopilot: Optimize ‚Üí Start</button>
        </div>
      </div>
      <div class="card col-12"><div id="logBack" role="log" aria-live="polite"></div></div>
      <div class="card col-12"><div id="B_summary" class="mono"></div></div>
      <div class="card col-12">
        <b>Equity Curve</b>
        <canvas id="pnlChart" style="margin-top: 10px;"></canvas>
      </div>
      <div class="card col-12">
        <b>Journal (Backtest)</b>
        <table id="journalBack"><thead><tr><th>Time</th><th>Symbol</th><th>Entry</th><th>TP</th><th>SL</th><th>Exit</th><th>PnL($)</th><th>Notes</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="card col-12">
        <b>Result by Symbol (Backtest)</b>
        <table id="bySymBack"><thead><tr><th>Symbol</th><th>Trades</th><th>Win %</th><th>PnL($)</th><th>Avg R</th></tr></thead><tbody></tbody></table>
      </div>
    </div>
  </section>

  <section class="tabview" id="tab-help">
    <div class="card col-12">
      <b>H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng & Autopilot</b>
      <ul>
        <li><b>Autopilot (üöÄ):</b> B·∫•m n√∫t "Autopilot: Optimize ‚Üí Start" ·ªü tab Backtester. Bot s·∫Ω:
          <ol>
            <li>Ch·∫°y <b>Grid Search</b> ƒë·ªÉ t√¨m b·ªô TP/SL t·ªëi ∆∞u (k√óATR).</li>
            <li>T·ª± ƒë·ªông <b>sao ch√©p</b> th√¥ng s·ªë t·ªëi ∆∞u sang tab Live.</li>
            <li>N·∫øu b·∫°n ƒë√£ l∆∞u API, bot s·∫Ω <b>h·ªèi passphrase</b> ƒë·ªÉ gi·∫£i m√£ v√† n·∫°p. N·∫øu th·∫•t b·∫°i/kh√¥ng c√≥ API, bot s·∫Ω ch·∫°y ·ªü <b>SIM mode</b>.</li>
            <li>B·∫≠t <b>Auto Buy</b> v√† <b>kh·ªüi ƒë·ªông</b> bot. (N·∫øu kh√¥ng ·ªü SIM, bot k·∫øt n·ªëi WebSocket ri√™ng t∆∞ ƒë·ªÉ ph√°t hi·ªán fill nhanh h∆°n).</li>
          </ol>
        </li>
        <li><b>ALT Hunter:</b> Khi ƒë·ªÉ tr·ªëng danh s√°ch m√£, bot ∆∞u ti√™n c√°c ALT c√≥ thanh kho·∫£n cao, gi√° th·∫•p ph√π h·ª£p v·ªën. Khi BTC y·∫øu, bot ∆∞u ti√™n ALT c√≥ s·ª©c m·∫°nh t∆∞∆°ng ƒë·ªëi t·ªët h∆°n BTC.</li>
        <li><b>Qu√©t th√¥ng minh:</b> T·ª± ƒë·ªông qu√©t nhanh (2‚Äì4s) g·∫ßn th·ªùi ƒëi·ªÉm ch·ªët n·∫øn v√† ch·∫≠m l·∫°i ·ªü gi·ªØa n·∫øn ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng, gi·∫£m t·∫£i API.</li>
        <li><b>B·∫£o v·ªá l·ªách th·ªùi gian (10001):</b> Bot ƒë·ªãnh k·ª≥ ƒë·ªìng b·ªô gi·ªù v·ªõi Bybit v√† t·ª± <b>retry 1 l·∫ßn</b> n·∫øu g·∫∑p l·ªói timestamp.</li>
        <li><b>Reset phi√™n:</b> Tu·ª≥ ch·ªçn "T·ª± reset khi b·∫Øt ƒë·∫ßu" (b·∫≠t m·∫∑c ƒë·ªãnh) s·∫Ω xo√° PnL/chu·ªói l·ªó c·ªßa phi√™n tr∆∞·ªõc m·ªói l·∫ßn Start.</li>
        <li><b>Quy tr√¨nh th·ªß c√¥ng:</b> 1Ô∏è‚É£ Backtest ‚Üí 2Ô∏è‚É£ Tinh ch·ªânh Live ‚Üí 3Ô∏è‚É£ N·∫°p API (n·∫øu trade th·∫≠t) ‚Üí 4Ô∏è‚É£ Start.</li>
        <li><b>Telegram (tu·ª≥ ch·ªçn):</b> B·∫•m <b>Validate Token</b> ƒë·ªÉ ki·ªÉm tra token, g·ª≠i tin nh·∫Øn cho bot r·ªìi b·∫•m <b>Detect Chat ID</b> ƒë·ªÉ ƒëi·ªÅn ID t·ª± ƒë·ªông, sau ƒë√≥ th·ª≠ <b>Send Test</b>.</li>
        <li>‚ö†Ô∏è <b>L∆∞u √Ω:</b> H√£y th·ª≠ ·ªü SIM/Testnet tr∆∞·ªõc. T·ª± ch·ªãu r·ªßi ro khi s·ª≠ d·ª•ng. Kh√¥ng d√πng API c√≥ quy·ªÅn r√∫t ti·ªÅn. N·∫øu g·∫∑p CORS, h√£y d√πng proxy ri√™ng (v√≠ d·ª• Cloudflare Worker).</li>
      </ul>
    </div>
    <div class="card col-12">
      <b>H·ªçc t·ª´ sai l·∫ßm (Post‚Äëmortem)</b>
      <div class="row" style="margin-top:8px; gap:10px; align-items:flex-end; flex-wrap:wrap">
        <div style="width:140px"><label>Lookback trades</label><input id="CO_lookback" type="number" value="30" /></div>
        <label class="pill"><input id="CO_sendTg" type="checkbox" checked> G·ª≠i nh·∫≠n x√©t qua Telegram</label>
        <label class="pill"><input id="CO_autoTune" type="checkbox"> T·ª± ƒëi·ªÅu ch·ªânh sau chu·ªói SL</label>
        <button class="btn" id="CO_analyze" title="Ph√¢n t√≠ch c√°c l·ªánh g·∫ßn ƒë√¢y v√† ƒë∆∞a ra nh·∫≠n x√©t">üìà Ph√¢n t√≠ch</button>
        <div class="tiny" style="color:var(--muted)">G·ª£i √Ω: N·∫øu SL li√™n ti·∫øp, gi·∫£m risk %, tƒÉng minScore ho·∫∑c time‚Äëstop.</div>
      </div>
      <div id="CO_out" class="tiny" style="margin-top:6px; white-space:pre-wrap; color:var(--muted)"></div>
    </div>
  </section>
</div>

<script>
// ================================================================================= //
//                            BYBIT BOT v7.0 SCRIPT START                            //
// ================================================================================= //

const BybitBotApp = {
    // --- App State ---
    state: {
        isRunning: false,
        isStopping: false,
        isInPosition: false,
        currentPosition: {},
        timers: {
            scheduler: null,
            monitor: null,
            simMonitor: null,
        },
        ws: {
            instance: null,
            ping: null,
            watchdog: null,
            backoff: 3000,
        },
        time: {
            serverOffset: 0,
            lastSync: 0,
            netRTT: 300,
            lastTs: 0,
        },
        apiQueue: Promise.resolve(),
        cancelLock: false,
        cancelTimer: null,
    },

    // --- Momentum Radar ---
    radar: {
        timer: null,
        async scan(){
            try{
                const E = BybitBotApp.DOMElements; const api = BybitBotApp.api; const ind = BybitBotApp.utils.indicators; const cfg = BybitBotApp.config;
                const topN = Math.max(3, +E.R_topN.value || 12);
                const minTurn = Math.max(0, +E.R_minTurnover.value || 30_000_000);
                const maxPrice = Math.max(0.01, +E.R_maxPrice.value || 10);
                E['radar-list'].innerHTML = 'ƒêang qu√©t...';
                const t0 = performance.now();
                const tickers = await api.tickers();
                const list = tickers
                    .filter(t => t.symbol.endsWith('USDT'))
                    .map(t => ({
                        ...t,
                        // x·∫•p x·ªâ turnover 1h t·ª´ 24h: chia 24 (ƒë·ªß nhanh, ch·∫•p nh·∫≠n sai s·ªë)
                        turnover1h: (+t.turnover24h || 0) / 24
                    }))
                    .filter(t => t.turnover1h >= minTurn)
                    .filter(t => +t.lastPrice <= maxPrice)
                    .map(t => ({
                        sym: t.symbol,
                        px: +t.lastPrice,
                        chg: +t.price24hPcnt * 100,
                        turn: +t.turnover1h
                    }))
                    .sort((a,b)=> (b.chg) - (a.chg))
                    .slice(0, topN);

                // Enrich with RSI14 and ATR%
                const tf = String((cfg.values && cfg.values.tf) || '5');
                for (const x of list) {
                    try{
                        const kl = await api.klines(x.sym, tf, 120);
                        const C = kl.map(k=>k.c), H = kl.map(k=>k.h), L = kl.map(k=>k.l);
                        const rsi = ind.rsi(C, 14);
                        const tr = ind.trArr(H, L, C);
                        const atr = ind.median(tr.slice(-14));
                        x.rsi = rsi != null ? +rsi.toFixed(1) : null;
                        x.atrp = C.length ? +((atr / C[C.length-1]) * 100).toFixed(2) : null;
                        // T√≠nh Œî% lookback ƒë·ªÉ ph√°t hi·ªán b·∫•t th∆∞·ªùng
                        const lookMin = Math.max(1, +BybitBotApp.DOMElements.RA_retMin?.value || 5);
                        const n = Math.min(kl.length-1, Math.ceil((lookMin) * (60 / (+tf||5))));
                        if (n >= 1) {
                            const base = kl.at(-(n+1)).c; const last = kl.at(-1).c;
                            x.retN = +(((last-base)/base)*100).toFixed(2);
                        }
                    }catch{ x.rsi = null; x.atrp = null; }
                }
                const dt = (performance.now()-t0).toFixed(0);
                const tfLabel = ({'1':'1m','3':'3m','5':'5m','15':'15m'})[tf] || (tf+'m');
                E['radar-list'].innerHTML = list.map(x => `
                    <div class="card" style="padding:12px">
                      <div style="display:flex;justify-content:space-between;align-items:center">
                        <div style="font-weight:600">${x.sym}</div>
                        <div class="${x.chg>=0?'ok':'bad'}">${x.chg.toFixed(2)}%</div>
                      </div>
                      <div class="tiny" style="margin-top:6px;color:var(--muted)">Gi√°: ${x.px} ‚Ä¢ Turnover1h: ${Math.round(x.turn/1e6)}M</div>
                      <div class="tiny" style="margin-top:4px;color:var(--muted)">RSI14(${tfLabel}): ${x.rsi??'‚Äî'} ‚Ä¢ ATR%: ${x.atrp??'‚Äî'} ‚Ä¢ Œî${BybitBotApp.DOMElements.RA_retMin?.value||5}m: ${x.retN??'‚Äî'}%</div>
                      <div class="row" style="margin-top:8px;gap:6px">
                        <button class="btn" title="Sao ch√©p v√†o danh s√°ch symbol Live" onclick="(function(){ const el=document.getElementById('symbolList'); const s=el.value.trim(); el.value = s? (s+','+'${x.sym}') : '${x.sym}'; el.dispatchEvent(new Event('change')); })()">+ Live</button>
                        <button class="btn" title="Backtest nhanh 1000 n·∫øn" onclick="(function(){ const el=document.getElementById('B_symbolList'); el.value='${x.sym}'; el.dispatchEvent(new Event('change')); document.getElementById('B_run').click(); })()">‚Ü∫ Backtest</button>
                      </div>
                    </div>`).join('');
                BybitBotApp.ui.logLive(`Radar scan: ${list.length} symbols in ${dt}ms`, 'ok');

                // G·ª≠i c·∫£nh b√°o k√®m nh·∫≠n x√©t ng·∫Øn
                if (BybitBotApp.DOMElements.RA_enable?.checked) {
                    const th = Math.abs(+BybitBotApp.DOMElements.RA_retPct.value || 3);
                    const coolMin = Math.max(1, +BybitBotApp.DOMElements.RA_coolMin.value || 30);
                    const abnormal = list.filter(x => x.retN != null && Math.abs(x.retN) >= th);
                    const coachText = BybitBotApp.coaching.analyzeRecentTrades(BybitBotApp.journal?.state?.trades||[]);
                    const coachShort = coachText.split('\n').slice(0,2).join(' ‚Ä¢ ');
                    for (const a of abnormal) {
                        const dir = a.retN>0 ? '‚ñ≤' : '‚ñº';
                        const msg = `[RADAR] ${a.sym} ${dir} ${a.retN}% / ${BybitBotApp.DOMElements.RA_retMin?.value||5}m | RSI14=${a.rsi??'‚Äî'} ATR%=${a.atrp??'‚Äî'}\nNh·∫≠n x√©t: ${coachShort}`;
                        await BybitBotApp.telegram.notify(msg);
                    }
                    // L∆∞u b·∫£n ghi coach report trong ng√†y
                    const dayKey = new Date().toISOString().slice(0,10);
                    const k = `bb_coach_reports_${dayKey}`;
                    try { const hist = JSON.parse(localStorage.getItem(k)||'[]'); hist.push({ ts: Date.now(), msg: coachText }); localStorage.setItem(k, JSON.stringify(hist).slice(0,200000)); } catch {}
                }
            }catch(e){
                (BybitBotApp.DOMElements['radar-list']||{}).innerHTML = `<div class="bad">L·ªói qu√©t: ${e.message}</div>`;
            }
        },
        startAuto(){
            const E = BybitBotApp.DOMElements; const min = Math.max(1, +E.R_interval.value || 5);
            this.stopAuto();
            this.scan();
            this.timer = setInterval(()=> this.scan(), min*60*1000);
            BybitBotApp.ui.logLive(`Radar auto-refresh: ${min} ph√∫t`, 'ok');
        },
        stopAuto(){ if (this.timer) { clearInterval(this.timer); this.timer = null; } }
    },

    // --- News Aggregator ---
    news: {
        timer: null,
        async fetchSource(url){
            const r = await fetch(url); const text = await r.text();
            // simple title extraction fallback
            const items = [];
            const re = /<a[^>]+href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gi;
            let m; const seen=new Set();
            while((m=re.exec(text)) && items.length<30){ const href=m[1]; const title = m[2].replace(/<[^>]+>/g,'').trim(); if(!title||seen.has(title)) continue; seen.add(title); items.push({title, link: href}); }
            return items;
        },
        async fetchAll(){
            const E = BybitBotApp.DOMElements;
            const tasks = [];
            if (E.NW_src_coindesk?.checked) tasks.push(this.fetchSource('https://www.coindesk.com/'));
            if (E.NW_src_cointele?.checked) tasks.push(this.fetchSource('https://cointelegraph.com/'));
            if (E.NW_src_binance?.checked) tasks.push(this.fetchSource('https://www.binance.com/en/blog'));
            const res = await Promise.allSettled(tasks);
            let items = res.flatMap(x=> x.status==='fulfilled' ? x.value : []);
            // filter by keywords if provided
            const kw = (E.NW_keywords?.value||'').toUpperCase().split(',').map(s=>s.trim()).filter(Boolean);
            if (kw.length) items = items.filter(it => kw.some(k=> it.title.toUpperCase().includes(k)));
            // unique by title
            const uniq=[]; const seen=new Set(); for(const it of items){ if(!seen.has(it.title)){ seen.add(it.title); uniq.push(it);} }
            return uniq.slice(0,20);
        },
        async render(){
            const E = BybitBotApp.DOMElements; E['news-list'].innerHTML = 'ƒêang t·∫£i tin...';
            try{
                const items = await this.fetchAll();
                E['news-list'].innerHTML = items.map(it=>`
                  <div class="card" style="padding:10px">
                    <div style="font-weight:600;">${BybitBotApp.utils.escapeHtml(it.title)}</div>
                    <div class="tiny"><a href="${it.link}" target="_blank">M·ªü li√™n k·∫øt</a></div>
                  </div>`).join('');
                if (BybitBotApp.DOMElements.NW_forward?.checked && items.length){
                    const msg = `[News] ${items.slice(0,3).map(i=>i.title).join(' | ')}`;
                    await BybitBotApp.telegram.notify(msg);
                }
            }catch(e){ E['news-list'].innerHTML = `<div class='bad'>L·ªói t·∫£i tin: ${e.message}</div>`; }
        },
        startAuto(){ const min = Math.max(1, +BybitBotApp.DOMElements.NW_interval?.value||15); this.stopAuto(); this.render(); this.timer = setInterval(()=>this.render(), min*60*1000); },
        stopAuto(){ if (this.timer){ clearInterval(this.timer); this.timer=null; } }
    },

    // --- Daily Market Report ---
    dailyReport: {
        timer: null,
        buildSummary(radarHtml){
            const E = BybitBotApp.DOMElements; const now = new Date();
            const top = Array.from((E['radar-list']||{}).children||[]).slice(0,6).map(el=>{
                const name = el.querySelector('div[style*="font-weight:600"]')?.textContent||'';
                const chg = el.querySelector('.ok,.bad')?.textContent||'';
                return `${name} ${chg}`;
            }).join(', ');
            return `B√°o c√°o ${now.toLocaleDateString()} ${now.toLocaleTimeString()}\nTop: ${top}\n${radarHtml?'' : ''}`;
        },
        async sendNow(){
            try{
                // Ensure radar list exists; do a quick scan if empty
                if (!BybitBotApp.DOMElements['radar-list']?.children?.length) {
                    await BybitBotApp.radar.scan();
                }
                const summary = this.buildSummary();
                const ok = await BybitBotApp.telegram.notify(summary);
                BybitBotApp.ui.logLive(ok? '‚úì ƒê√£ g·ª≠i b√°o c√°o ng√†y qua Telegram' : 'Kh√¥ng g·ª≠i ƒë∆∞·ª£c b√°o c√°o (thi·∫øu token/chatid?)', ok?'ok':'warn');
            }catch(e){ BybitBotApp.ui.logLive('B√°o c√°o l·ªói: '+e.message, 'warn'); }
        },
        start(){
            const E = BybitBotApp.DOMElements; this.stop();
            const hhmm = (E.DR_time?.value||'09:00').split(':');
            const h = Math.max(0, Math.min(23, +hhmm[0]||9));
            const m = Math.max(0, Math.min(59, +hhmm[1]||0));
            const schedule = ()=>{
                const now = new Date();
                const next = new Date(); next.setHours(h, m, 0, 0);
                if (next <= now) next.setDate(next.getDate()+1);
                const ms = next - now;
                this.timer = setTimeout(async ()=>{ try { await BybitBotApp.radar.scan(); await this.sendNow(); } finally { schedule(); } }, ms);
                BybitBotApp.ui.logLive(`Daily report scheduled at ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')} (will send in ${(ms/60000).toFixed(1)} min)`, 'ok');
            };
            schedule();
        },
        stop(){ if (this.timer) { clearTimeout(this.timer); this.timer = null; } }
    },

    // --- Coaching / Post-mortem ---
    coaching: {
        analyzeRecentTrades(trades){
            const out = [];
            if (!trades || trades.length === 0) { out.push('Ch∆∞a c√≥ d·ªØ li·ªáu trade.'); return out.join('\n'); }
            const recent = trades.slice(0, Math.max(5, Math.min(50, +BybitBotApp.DOMElements.CO_lookback?.value||30)));
            const wins = recent.filter(t=> (t.pnl||0) > 0), losses = recent.filter(t=> (t.pnl||0) < 0);
            const winrate = (wins.length/recent.length*100)||0;
            out.push(`T·ªïng ${recent.length} l·ªánh g·∫ßn nh·∫•t ‚Ä¢ Winrate=${winrate.toFixed(1)}%`);
            // chu·ªói SL d√†i nh·∫•t
            let streak=0, maxStreak=0; for (const t of recent){ if ((t.pnl||0)<0) { streak++; maxStreak=Math.max(maxStreak, streak); } else streak=0; }
            if (maxStreak>=3) out.push(`Chu·ªói SL t·ªëi ƒëa: ${maxStreak} ‚Üí c√¢n nh·∫Øc cooldown v√† tƒÉng minScore.`);
            // R:R trung b√¨nh
            const rr = recent.map(t=>{ const baseSl = (t.initialSl ?? (t.sl || t.entry)); const risk=(t.entry - baseSl)*t.qty; return risk>0? (t.pnl||0)/risk: null; }).filter(x=>x!=null);
            if (rr.length) out.push(`R:R trung b√¨nh ‚âà ${(rr.reduce((a,b)=>a+b,0)/rr.length).toFixed(2)}`);
            // theo symbol
            const bySym = {}; for (const t of recent){ const k=t.sym; bySym[k]=bySym[k]||{n:0,pnl:0}; bySym[k].n++; bySym[k].pnl+=(t.pnl||0); }
            const worst = Object.entries(bySym).sort((a,b)=>a[1].pnl-b[1].pnl)[0];
            if (worst && worst[1].pnl < 0) out.push(`Symbol y·∫øu nh·∫•t: ${worst[0]} (PnL ${(worst[1].pnl).toFixed(2)}) ‚Üí c√¢n nh·∫Øc lo·∫°i t·∫°m th·ªùi.`);
            // g·ª£i √Ω h√†nh ƒë·ªông
            if (winrate < 40) out.push('G·ª£i √Ω: tƒÉng minScore ho·∫∑c si·∫øt RR (kTp‚Üë/kSl‚Üë).');
            if (maxStreak >= 3) out.push('G·ª£i √Ω: b·∫≠t cooldown sau chu·ªói SL v√† gi·∫£m risk %.');
            return out.join('\n');
        },
        async run(){
            try{
                const J = BybitBotApp.journal?.state?.trades || [];
                const text = this.analyzeRecentTrades(J);
                const box = BybitBotApp.DOMElements.CO_out; if (box) box.textContent = text;
                if (BybitBotApp.DOMElements.CO_sendTg?.checked) await BybitBotApp.telegram.notify(`[Coach]\n${text}`);
                if (BybitBotApp.DOMElements.CO_autoTune?.checked) {
                    // v√≠ d·ª• t·ª± ƒë·ªông nh·ªè: khi SL streak>=3, tƒÉng minScore +1 trong phi√™n
                    const recent = J.slice(0, +BybitBotApp.DOMElements.CO_lookback?.value||30);
                    let st=0, ms=0; for (const t of recent){ if ((t.pnl||0)<0){ st++; ms=Math.max(ms,st); } else st=0; }
                    if (ms>=3) {
                        const E = BybitBotApp.DOMElements; const old = +E.minScore.value||5; E.minScore.value = old + 1; E.minScore.dispatchEvent(new Event('change'));
                        BybitBotApp.ui.logLive(`Auto-tune: tƒÉng Min Score ${old}‚Üí${old+1} do SL streak`, 'warn');
                    }
                }
            }catch(e){ BybitBotApp.ui.logLive('Coaching error: '+e.message,'warn'); }
        }
    },

    // --- DOM Elements Cache ---
    DOMElements: {},

    // --- Configuration ---
    config: {
        values: {},
        ids: [
            'apiKey', 'apiSecret', 'passphrase', 'useTestnet', 'simMode', 'autoRun',
            'orderQuote', 'tf', 'recvWindow', 'proxy', 'autoMode', 'btcFilter',
            'useTrailing', 'useBreakeven', 'useOCOEmu', 'symbolList', 'minScore',
            'timeStopMin', 'maxLossDay', 'scanSec', 'autoResetStart',
            'useBalanceSizing','riskPct','reserveUsd','minQuote','maxQuote','balanceAcct',
            'B_tf', 'B_lookback', 'B_topN', 'B_symbolList', 'B_btcFilter', 'B_pessimistic',
            'B_minScore', 'B_tpK', 'B_slK', 'B_timeStopMin', 'B_quote', 'B_feePct', 'B_slipBps',
            'B_useBreakeven', 'B_useTrailing',
            // Telegram
            'tg-token','tg-chatid','TG_onTrade','TG_onLifecycle',
            // Advanced filters
            'CO_mtfEnable','CO_mtfTf','CO_regimeMode','CO_winStart','CO_winEnd','CO_slStreak','CO_coolMin','CO_maxSpreadBps','CO_tp1Enable','CO_tp1Frac'
            , 'OV_vwap','OV_bb','OV_vol','panicSell','uiCompact'
        ],
        
        load() {
            // Load from UI inputs into values object
            this.ids.forEach(id => {
                const el = BybitBotApp.DOMElements[id];
                if (!el) return;
                this.values[id] = el.type === 'checkbox' ? el.checked : (el.type === 'number' ? +el.value : el.value);
            });
        },

        saveToStorage() {
            const cfgToSave = {
                q: this.values.orderQuote, tf: this.values.tf, rw: this.values.recvWindow, p: this.values.proxy,
                am: this.values.autoMode, bf: this.values.btcFilter, ut: this.values.useTrailing,
                ub: this.values.useBreakeven, uo: this.values.useOCOEmu, sl: this.values.symbolList,
                ms: this.values.minScore, ts: this.values.timeStopMin, ml: this.values.maxLossDay,
                ss: this.values.scanSec, ar: this.values.autoRun, sm: this.values.simMode, ars: this.values.autoResetStart,
                bs: this.values.useBalanceSizing, rp: this.values.riskPct, rz: this.values.reserveUsd,
                mn: this.values.minQuote, mx: this.values.maxQuote, ba: this.values.balanceAcct,
                cx: !!this.values.uiCompact,
                // Telegram
                tg: {
                    t: this.values['tg-token'] || '',
                    c: this.values['tg-chatid'] || '',
                    nt: !!this.values['TG_onTrade'],
                    nl: !!this.values['TG_onLifecycle']
                }
            };
            // v7 storage key (gi·ªØ backward-compat khi load)
            localStorage.setItem('bb_bot_config_v7', JSON.stringify(cfgToSave));
        },
        
        loadFromStorage() {
            const j = localStorage.getItem('bb_bot_config_v7') || localStorage.getItem('bb_bot_config_v6');
            if (!j) return;
            const c = JSON.parse(j);
            const { DOMElements } = BybitBotApp;
            DOMElements.orderQuote.value = c.q ?? 8;
            DOMElements.tf.value = c.tf ?? '5';
            DOMElements.recvWindow.value = c.rw ?? 5000;
            DOMElements.proxy.value = c.p ?? '';
            DOMElements.autoMode.checked = !!c.am;
            DOMElements.btcFilter.checked = c.bf !== false;
            DOMElements.useTrailing.checked = c.ut !== false;
            DOMElements.useBreakeven.checked = c.ub !== false;
            DOMElements.useOCOEmu.checked = c.uo !== false;
            DOMElements.symbolList.value = c.sl ?? '';
            DOMElements.minScore.value = c.ms ?? 5;
            DOMElements.timeStopMin.value = c.ts ?? 15;
            DOMElements.maxLossDay.value = c.ml ?? 2;
            DOMElements.scanSec.value = c.ss ?? 20;
            DOMElements.autoRun.checked = !!c.ar;
            DOMElements.simMode.checked = !!c.sm;
            DOMElements.autoResetStart.checked = c.ars !== false;
            if (DOMElements.uiCompact) DOMElements.uiCompact.checked = !!c.cx;

            DOMElements.useBalanceSizing.checked = c.bs !== false;
            DOMElements.riskPct.value   = c.rp ?? 15;
            DOMElements.reserveUsd.value= c.rz ?? 2;
            DOMElements.minQuote.value  = c.mn ?? 5;
            DOMElements.maxQuote.value  = c.mx ?? 25;
            DOMElements.balanceAcct.value = c.ba ?? 'AUTO';
            // Telegram
            if (c.tg) {
                if (DOMElements['tg-token']) DOMElements['tg-token'].value = c.tg.t || '';
                if (DOMElements['tg-chatid']) DOMElements['tg-chatid'].value = c.tg.c || '';
                if (DOMElements['TG_onTrade']) DOMElements['TG_onTrade'].checked = !!c.tg.nt;
                if (DOMElements['TG_onLifecycle']) DOMElements['TG_onLifecycle'].checked = !!c.tg.nl;
            }
            
            this.load(); // Reload values from UI after setting them
        },

        async saveApiKeys() {
            const k = BybitBotApp.DOMElements.apiKey.value.trim();
            const s = BybitBotApp.DOMElements.apiSecret.value.trim();
            const p = BybitBotApp.DOMElements.passphrase.value;
            if (!k || !s || !p) return BybitBotApp.ui.logLive('Thi·∫øu API Key, Secret, ho·∫∑c Passphrase', 'error');
            
            const sealed = await BybitBotApp.utils.crypto.seal(p, s);
            localStorage.setItem('bb_bot_key_v7', k);
            localStorage.setItem('bb_bot_sec_v7', JSON.stringify(sealed));
            localStorage.setItem('bb_bot_testnet_v7', BybitBotApp.DOMElements.useTestnet.checked ? '1' : '0');
            BybitBotApp.ui.logLive('ƒê√£ m√£ ho√° & l∆∞u tr·ªØ API.', 'ok');
        },

        async loadApiKeys() {
            try {
                const p = BybitBotApp.DOMElements.passphrase.value;
                if (!p) return BybitBotApp.ui.logLive('Vui l√≤ng nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£.', 'warn');

                const k = localStorage.getItem('bb_bot_key_v7') || localStorage.getItem('bb_bot_key_v6');
                const b = localStorage.getItem('bb_bot_sec_v7') || localStorage.getItem('bb_bot_sec_v6');
                if (!k || !b) return BybitBotApp.ui.logLive('Kh√¥ng t√¨m th·∫•y API ƒë√£ l∆∞u.', 'warn');

                const s = await BybitBotApp.utils.crypto.open(p, JSON.parse(b));
                BybitBotApp.DOMElements.apiKey.value = k;
                BybitBotApp.DOMElements.apiSecret.value = s;
                BybitBotApp.DOMElements.useTestnet.checked = (localStorage.getItem('bb_bot_testnet_v7') || localStorage.getItem('bb_bot_testnet_v6')) === '1';
                BybitBotApp.ui.logLive('ƒê√£ gi·∫£i m√£ v√† n·∫°p API Secret.', 'ok');
                return true;
            } catch (e) {
                BybitBotApp.ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i: ' + e.message, 'error');
                return false;
            }
        },

        clearApiKeys() {
            ['bb_bot_key_v7','bb_bot_sec_v7','bb_bot_testnet_v7','bb_bot_key_v6','bb_bot_sec_v6','bb_bot_testnet_v6'].forEach(k=>localStorage.removeItem(k));
            BybitBotApp.ui.logLive('ƒê√£ xo√° API kh·ªèi tr√¨nh duy·ªát.', 'ok');
        }
    },

    // --- UI Update Module ---
    ui: {
        logLive(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logLive;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
        },
        logBack(m, l = 'info') {
            const t = new Date().toLocaleTimeString();
            const c = l === 'error' ? 'bad' : l === 'warn' ? 'warn' : 'ok';
            const e = BybitBotApp.DOMElements.logBack;
            e.innerHTML += `<div class="${c} mono">[${t}] ${m}</div>`;
            e.scrollTop = e.scrollHeight;
        },
        updateStatus(text, level = 'ok') {
            const el = BybitBotApp.DOMElements.status;
            el.textContent = text;
            el.className = level;
        },
        updateStats() {
            const { DOMElements, api } = BybitBotApp;
            const { currentPosition } = BybitBotApp.state;
            DOMElements.lastUpdate.textContent = new Date().toLocaleTimeString();
            DOMElements.watching.textContent = currentPosition.watching || '‚Äî';
            DOMElements.signal.textContent = currentPosition.signal || '‚Äî';

            const bc = api.balanceCache;
            if (bc && bc.ts) DOMElements.usdtFree.textContent = (bc.free ?? 0).toFixed(2);
        },
        withinTimeWindow(){
            const s = BybitBotApp.DOMElements.CO_winStart?.value||'00:00';
            const e = BybitBotApp.DOMElements.CO_winEnd?.value||'23:59';
            const now = new Date();
            const cur = now.getHours()*60 + now.getMinutes();
            const toMin = t=>{ const [h,m]=t.split(':').map(x=>+x||0); return h*60+m; };
            const a = toMin(s), b = toMin(e);
            return a<=b ? (cur>=a && cur<=b) : (cur>=a || cur<=b);
        },
        renderJournal(logId, trades) {
            const table = BybitBotApp.DOMElements[logId];
            const body = table.querySelector('tbody');
            body.innerHTML = '';
            trades.slice(0, 200).forEach(r => {
                const pnlClass = r.pnl > 0 ? 'ok' : (r.pnl < 0 ? 'bad' : '');
                const note = BybitBotApp.utils.escapeHtml(r.note || '');
                const row = `
                    <td>${new Date(r.ts).toLocaleString()}</td>
                    <td>${r.sym}</td>
                    <td>${r.entry?.toFixed(6) || '-'}</td>
                    <td>${r.tp?.toFixed(6) || '-'}</td>
                    <td>${(logId === 'journalBack' ? r.initialSl : r.sl)?.toFixed(6) || '-'}</td>
                    <td>${r.exit?.toFixed(6) || '-'}</td>
                    <td class="${pnlClass}">${r.pnl?.toFixed(2) || '-'}</td>
                    <td>${note}</td>`;
                body.innerHTML += `<tr>${row}</tr>`;
            });
        },
        drawLiveStrategy(kl, emaF, emaS, overlay={}) {
            const E = BybitBotApp.DOMElements; if (!E.liveStrategyChart) return;
            const ctx = E.liveStrategyChart.getContext('2d');
            if (this.liveStratInstance) this.liveStratInstance.destroy();
            const labels = kl.map(k=>k.t);
            const price = kl.map(k=>k.c);

            // Gradient fill for price line
            const gradient = ctx.createLinearGradient(0, 0, 0, E.liveStrategyChart.clientHeight || 360);
            gradient.addColorStop(0, 'rgba(10,132,255,0.18)');
            gradient.addColorStop(1, 'rgba(10,132,255,0.00)');

            const ds = [
              { label:'Price', data: price.map((v,i)=>({x:labels[i], y:v})), borderColor:'#0a84ff', backgroundColor:gradient, fill:true, tension:0.25, borderWidth:2, pointRadius:0, order:3 },
              { label:'EMA20', data: emaF.map((v,i)=>({x:labels[i], y:v})), borderColor:'#34c759', tension:0.2, borderWidth:1.6, pointRadius:0, order:2 },
              { label:'EMA50', data: emaS.map((v,i)=>({x:labels[i], y:v})), borderColor:'#ff9f0a', tension:0.2, borderWidth:1.4, pointRadius:0, order:2 }
            ];
            try{
              if (BybitBotApp.DOMElements.OV_vwap?.checked){
                let sumPV=0, sumV=0; const vwap=[]; for(let i=0;i<kl.length;i++){ const p=(kl[i].h+kl[i].l+kl[i].c)/3; const v=kl[i].v||0; sumPV+=p*v; sumV+=v; vwap.push(sumV? sumPV/sumV : kl[i].c); }
                ds.push({ label:'VWAP', data:vwap.map((v,i)=>({x:labels[i], y:v})), borderColor:'#8e8e93', borderWidth:1, pointRadius:0, tension:0.2, order:1 });
              }
              if (BybitBotApp.DOMElements.OV_bb?.checked){
                const period=20; const std=(arr)=>{const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length);};
                const bbU=[], bbL=[]; for(let i=0;i<price.length;i++){ const w=price.slice(Math.max(0,i-period+1), i+1); const m=w.reduce((a,b)=>a+b,0)/w.length; const s=std(w); bbU.push(m+2*s); bbL.push(m-2*s);} 
                ds.push({ label:'BB Upper', data:bbU.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.35)', borderWidth:1, pointRadius:0, tension:0.15, order:1 });
                ds.push({ label:'BB Lower', data:bbL.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.35)', borderWidth:1, pointRadius:0, tension:0.15, order:1 });
              }
              if (BybitBotApp.DOMElements.OV_vol?.checked){
                const vols = kl.map(k=>k.v||0);
                ds.push({ type:'bar', yAxisID:'y2', label:'Volume', data: vols.map((v,i)=>({x:labels[i], y:v})), backgroundColor:'rgba(29,29,31,0.18)', borderWidth:0, order:0 });
              }
            }catch{}
            const tMin = labels[0], tMax = labels[labels.length-1];
            if (overlay.entry){ ds.push({ type:'scatter', label:'Entry', data:[{x: overlay.entry.t||tMax, y: overlay.entry.p}], borderColor:'#34c759', backgroundColor:'#34c759', pointRadius:4, showLine:false, order:4 }); }
            if (overlay.exits && overlay.exits.length){ ds.push({ type:'scatter', label:'Exit', data: overlay.exits.map(e=>({x:e.t||tMax, y:e.p})), borderColor:'#ff3b30', backgroundColor:'#ff3b30', pointRadius:4, showLine:false, order:4 }); }
            if (overlay.tp){ ds.push({ label:'TP', data:[{x:tMin,y:overlay.tp},{x:tMax,y:overlay.tp}], borderColor:'#34c759', borderDash:[6,4], pointRadius:0, order:1 }); }
            if (overlay.sl){ ds.push({ label:'SL', data:[{x:tMin,y:overlay.sl},{x:tMax,y:overlay.sl}], borderColor:'#ff3b30', borderDash:[6,4], pointRadius:0, order:1 }); }

            const crosshair = {
              id: 'xCrosshair',
              afterDatasetsDraw(chart) {
                const active = chart.tooltip?.getActiveElements?.() || [];
                if (!active.length) return;
                const x = active[0].element.x;
                const { ctx, chartArea: { top, bottom } } = chart;
                ctx.save();
                ctx.strokeStyle = 'rgba(10,132,255,0.25)';
                ctx.setLineDash([4,4]);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            };

            this.liveStratInstance = new Chart(ctx, {
              type:'line',
              data:{ datasets: ds },
              options:{
                parsing:false,
                responsive:true,
                maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                scales:{
                  x:{ type:'time', grid:{ color:'rgba(0,0,0,0.06)' }, ticks:{ color:'#6e6e73' } },
                  y:{ grid:{ color:'rgba(0,0,0,0.06)' }, ticks:{ color:'#6e6e73' } },
                  y2:{ display: ds.some(d=>d.yAxisID==='y2'), position:'right', grid:{ drawOnChartArea:false }, ticks:{ color:'#6e6e73' } }
                },
                plugins:{
                  legend:{ display:true, labels:{ usePointStyle:true, color:'#1d1d1f' } },
                  tooltip:{
                    mode:'index', intersect:false,
                    backgroundColor:'rgba(255,255,255,0.95)', titleColor:'#1d1d1f', bodyColor:'#1d1d1f', borderColor:'#d2d2d7', borderWidth:1,
                    callbacks:{
                      label(ctx){
                        const v = ctx.parsed.y;
                        const name = ctx.dataset.label || '';
                        if (ctx.dataset.yAxisID === 'y2') return `${name}: ${Math.round(v)}`;
                        return `${name}: ${(+v).toFixed(6)}`;
                      }
                    }
                  }
                }
              },
              plugins:[crosshair]
            });
        },
    },

    // --- Utility Functions ---
    utils: {
        canonQS(obj = {}) {
            const enc = v => encodeURIComponent(v == null ? '' : v);
            return Object.keys(obj).sort().map(k => `${k}=${enc(obj[k])}`).join('&');
        },
        escapeHtml(v){ const d=document.createElement('div'); d.textContent=String(v??''); return d.innerHTML; },
        crypto: {
            enc: new TextEncoder(),
            dec: new TextDecoder(),
            async kdf(p, s) {
                const baseKey = await crypto.subtle.importKey('raw', this.enc.encode(p), { name: 'PBKDF2' }, false, ['deriveKey']);
                return crypto.subtle.deriveKey({ name: 'PBKDF2', salt: s, iterations: 120000, hash: 'SHA-256' }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
            },
            async seal(p, t) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await this.kdf(p, salt);
                const sealedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, this.enc.encode(t));
                return {
                    iv: btoa(String.fromCharCode(...iv)),
                    s: btoa(String.fromCharCode(...salt)),
                    d: btoa(String.fromCharCode(...new Uint8Array(sealedData)))
                };
            },
            async open(p, b) {
                const iv = Uint8Array.from(atob(b.iv), c => c.charCodeAt(0));
                const salt = Uint8Array.from(atob(b.s), c => c.charCodeAt(0));
                const data = Uint8Array.from(atob(b.d), c => c.charCodeAt(0));
                const key = await this.kdf(p, salt);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, data);
                return this.dec.decode(decrypted);
            },
            async hmac(s, m) {
                const key = await crypto.subtle.importKey('raw', this.enc.encode(s), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const signature = await crypto.subtle.sign('HMAC', key, this.enc.encode(m));
                return Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        },
        indicators: {
            sma(a, n) { if (a.length < n) return null; let s = 0; for (let i = a.length - n; i < a.length; i++) s += a[i]; return s / n; },
            emaSeries(v, p){
                const out = []; if (!v || v.length===0) return out; const k = 2/(p+1);
                let prev = v[0]; out.push(prev);
                for (let i=1;i<v.length;i++){ prev = v[i]*k + prev*(1-k); out.push(prev); }
                return out;
            },
            rsi(v, p = 14) {
                if (v.length <= p) return null;
                let g = 0, l = 0;
                for (let i = 1; i <= p; i++) { const d = v[i] - v[i - 1]; d >= 0 ? g += d : l -= d; }
                let ag = g / p, al = l / p;
                for (let i = p + 1; i < v.length; i++) {
                    const d = v[i] - v[i - 1], G = d > 0 ? d : 0, L = d < 0 ? -d : 0;
                    ag = (ag * (p - 1) + G) / p;
                    al = (al * (p - 1) + L) / p;
                }
                return 100 - 100 / (1 + ag / (al || 1e-12));
            },
            trArr(H, L, C) { const o = []; let pc = C[0]; for (let i = 0; i < H.length; i++) { o.push(Math.max(H[i] - L[i], Math.abs(H[i] - pc), Math.abs(L[i] - pc))); pc = C[i]; } return o; },
            median(a) { const b = [...a].sort((x, y) => x - y), m = Math.floor(b.length / 2); return b.length % 2 ? b[m] : (b[m - 1] + b[m]) / 2; },
        },
        strategy: {
            pullbackScore(kl) {
                const C = kl.map(k => k.c), H = kl.map(k => k.h), L = kl.map(k => k.l);
                const { sma, rsi, trArr, median } = BybitBotApp.utils.indicators;
                const ema20 = sma(C, 20), ema50 = sma(C, 50);
                if (ema20 == null || ema50 == null) return { score: 0 };
                const last = C[C.length - 1], prev = C[C.length - 2], r = rsi(C, 14) || 0;
                let s = 0;
                if (ema20 > ema50) s += 2;
                if (last > ema20) s += 1;
                if (r > 52) s += 1;
                if (prev < ema20 && last > ema20) s += 2;
                const tr = trArr(H, L, C).slice(-30), atr = median(tr);
                return { score: s, atr, last };
            },
            calcTPSL(e, a, t, s) {
                const p = e + t * a, l = Math.max(e - s * a, 1e-9);
                return { tp: +p.toFixed(8), sl: +l.toFixed(8), rr: +(p - e) / (e - l || 1e-9) };
            }
        },
        precision: {
            __precToStep(x) {
                if (x == null) return null;
                const s = String(x).trim();
                if (s.includes('e-')) return Math.pow(10, -Number(s.split('e-')[1]));
                if (s.includes('.'))  return Number(s);
                const n = Number(s);
                if (!isNaN(n) && Number.isInteger(n) && n >= 0) return Math.pow(10, -n);
                return null;
            },
            __dec(step) {
                const s = String(step);
                return s.includes('e-') ? Number(s.split('e-')[1]) : (s.split('.')[1]?.length || 0);
            },
            stepOf(info) {
                const ls = info?.lotSizeFilter || {};
                return this.__precToStep(ls.qtyStep) ?? this.__precToStep(ls.basePrecision) ?? 1e-8;
            },
            tickOf(info) {
                const pf = info?.priceFilter || {};
                return this.__precToStep(pf.tickSize) ?? this.__precToStep(pf.pricePrecision) ?? 1e-8;
            },
            quoteStepOf(info) {
                const ls = info?.lotSizeFilter || {};
                // N·∫øu kh√¥ng c√≥ quotePrecision, fallback 0.01 ƒë·ªÉ kh√¥ng "decimal too long"
                return this.__precToStep(ls.quotePrecision) ?? 1e-2;
            },
            floorStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.floor(xi / si) * si;
                return ri / scale;
            },
            ceilStep(x, step) {
                const dec = this.__dec(step);
                const scale = Math.pow(10, dec);
                const xi = Math.floor((+x * scale) + 1e-9);
                const si = Math.round(step * scale);
                const ri = Math.ceil(xi / si) * si;
                return ri / scale;
            },
            // qty (base)
            fmtQty(q, step) {
                const dec = this.__dec(step);
                const floored = this.floorStep(q, step);
                if (floored < step) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            // amount (quote USDT) cho marketUnit='quoteCoin'
            fmtAmt(a, qstep) {
                const dec = this.__dec(qstep);
                const floored = this.floorStep(a, qstep);
                if (floored < qstep) return (0).toFixed(dec);
                return floored.toFixed(dec);
            },
            snapUp(p, tick)   { return this.floorStep(+p + +tick, tick); },
            snapDown(p, tick) { return this.floorStep(+p, tick); },
        }
    },

    // --- Telegram ---
    telegram: {
        getRaw(){ const E = BybitBotApp.DOMElements; return { t: (E['tg-token']?.value||'').trim(), c: (E['tg-chatid']?.value||'').trim() }; },
        async sendTest(){
            try{
                const { t, c } = this.getRaw(); if(!t||!c) throw new Error('Missing token/chatid');
                const msg = BybitBotApp.DOMElements['tg-msg']?.value || 'Test';
                const r = await fetch(`https://api.telegram.org/bot${t}/sendMessage`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id:c, text: msg }) });
                const j = await r.json(); if(!j.ok) throw new Error(j.description||'Send failed');
                BybitBotApp.ui.logLive('‚úì Telegram test sent','ok');
            }catch(e){ BybitBotApp.ui.logLive('Telegram error: '+e.message,'warn'); }
        },
        async notify(text){
            try{
                const { t, c } = this.getRaw(); if(!t||!c) return false;
                await fetch(`https://api.telegram.org/bot${t}/sendMessage`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id:c, text }) });
                return true;
            }catch{ return false; }
        },
        async validate(){
            try{
                const { t } = this.getRaw(); if(!t) throw new Error('Missing token');
                const r = await fetch(`https://api.telegram.org/bot${t}/getMe`);
                const j = await r.json(); if(!j.ok) throw new Error(j.description||'Invalid token');
                BybitBotApp.ui.logLive(`‚úì Bot: @${j.result.username}`,'ok');
            }catch(e){ BybitBotApp.ui.logLive('Token invalid: '+e.message,'error'); }
        },
        async detectChatId(){
            try{
                const { t } = this.getRaw(); if(!t) throw new Error('Missing token');
                const r = await fetch(`https://api.telegram.org/bot${t}/getUpdates`);
                const j = await r.json(); if(!j.ok) throw new Error(j.description||'getUpdates failed');
                const upd = (j.result||[]).slice().reverse().find(u=>u.message?.chat?.id);
                if(!upd) throw new Error('No chat found. Send a message to the bot first.');
                const chatId = upd.message.chat.id;
                if (BybitBotApp.DOMElements['tg-chatid']) BybitBotApp.DOMElements['tg-chatid'].value = chatId;
                BybitBotApp.ui.logLive(`‚úì Detected Chat ID: ${chatId}`,'ok');
            }catch(e){ BybitBotApp.ui.logLive('Detect Chat ID failed: '+e.message,'warn'); }
        }
    },

    // --- Bybit API Module ---
    api: {
        balanceCache: { ts: 0, free: 0, acct: 'AUTO' },
        async withApiQueue(fn) {
            const { state } = BybitBotApp;
            const prev = state.apiQueue;
            let release;
            state.apiQueue = new Promise(res => (release = res));
            try { await prev; return await fn(); } finally { release(); }
        },
        
        buildUrl(p, q) {
            const { DOMElements, config, utils } = BybitBotApp;
            const proxy = DOMElements.proxy.value.trim();
            const baseUrl = config.values.useTestnet ? 'https://api-testnet.bybit.com' : 'https://api.bybit.com';
            const qstr = (typeof q === 'string') ? q : (q && Object.keys(q).length ? utils.canonQS(q) : '');
            const u = baseUrl + p + (qstr ? ('?' + qstr) : '');
            return (proxy ? proxy.replace(/\/$/, '') + '/' : '') + u;
        },

        // Internal: fetch JSON with timeout
        async _fetchJsonWithTimeout(url, options = {}, timeoutMs = 18000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const resp = await fetch(url, { ...options, signal: controller.signal });
                const text = await resp.text();
                let data; try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: text }; }
                return { resp, data };
            } finally { clearTimeout(id); }
        },

        async sign(method, path, qs = {}, body = null) {
            return this.withApiQueue(async () => {
                const { config, ui, utils } = BybitBotApp;
                await this.syncTime();
                const apiKey = config.values.apiKey.trim();
                const apiSecret = config.values.apiSecret.trim();
                if (!apiKey || !apiSecret) throw new Error('Thi·∫øu API');

                const maxTries = 3;
                let rwVal = this.suggestedRecvWindow();
                for (let attemptIdx = 1; attemptIdx <= maxTries; attemptIdx++) {
                    try {
                        const rw = String(rwVal);
                        const ts = this.tsNow();
                        let url, payloadStr = '';
                        if (method === 'GET') {
                            payloadStr = BybitBotApp.utils.canonQS(qs);
                            url = this.buildUrl(path, payloadStr);
                        } else {
                            payloadStr = body ? JSON.stringify(body) : '';
                            url = this.buildUrl(path, '');
                        }
                        const sign = await utils.crypto.hmac(apiSecret, `${ts}${apiKey}${rw}${payloadStr}`);
                        const headers = { 'X-BAPI-API-KEY': apiKey, 'X-BAPI-TIMESTAMP': ts, 'X-BAPI-RECV-WINDOW': rw, 'X-BAPI-SIGN-TYPE': '2', 'X-BAPI-SIGN': sign };
                        if (method === 'POST') headers['Content-Type'] = 'application/json';

                        const { resp, data } = await this._fetchJsonWithTimeout(url, { method, headers, body: (method === 'POST' && payloadStr) ? payloadStr : undefined }, 18000);
                        if (resp.status === 403 && BybitBotApp.DOMElements.corsWarn) BybitBotApp.DOMElements.corsWarn.style.display = 'block';
                        if (!resp.ok || data.retCode !== 0) {
                            const ret = data.retCode ?? -1; const msg = data.retMsg || resp.statusText || 'ERR';
                            const err = new Error(`HTTP ${resp.status} ‚Äì ${msg} (${ret})`); err.retCode = ret; err.msg = msg; throw err;
                        }
                        return data.result;
                    } catch (e) {
                        const isTemporal = e.name === 'AbortError' || [429,500,502,503,504].some(c => String(e.message||'').includes(`HTTP ${c}`));
                        const isTimeSkew = [10001,10002,10004].includes(e.retCode) || /recvWindow|timestamp|Signature/i.test(e.msg || '');
                        if (attemptIdx < maxTries && (isTemporal || isTimeSkew)) {
                            if (isTimeSkew) { await this.syncTime(true); rwVal += 5000; }
                            const base = 600 * attemptIdx; const jitter = Math.floor(Math.random()*300);
                            ui.logLive(`Retry ${attemptIdx}/${maxTries-1} for ${path}...`, 'warn');
                            await new Promise(res => setTimeout(res, base + jitter));
                            continue;
                        }
                        throw e;
                    }
                }
            });
        },

        async syncTime(force = false) {
            const { time } = BybitBotApp.state;
            if (!force && Date.now() - time.lastSync < 30000) return;
            try {
                const t0 = Date.now();
                const r = await fetch(this.buildUrl('/v5/market/time'));
                const j = await r.json();
                const t1 = Date.now();
                const srvMs = (j?.result?.timeNano ? Math.floor(Number(j.result.timeNano) / 1e6) : j?.result?.timeSecond ? Number(j.result.timeSecond) * 1000 : Number(j?.result?.time) || Date.parse(r.headers.get('date')) || t1);
                time.netRTT = Math.min(5000, Math.max(50, t1 - t0));
                time.serverOffset = srvMs - ((t0 + t1) / 2);
                time.lastSync = t1;
                BybitBotApp.ui.logLive(`ƒê·ªìng b·ªô th·ªùi gian: Offset=${time.serverOffset.toFixed(0)}ms, RTT=${time.netRTT}ms`, 'ok');
            } catch (e) {
                BybitBotApp.ui.logLive('Kh√¥ng ƒë·ªìng b·ªô ƒë∆∞·ª£c th·ªùi gian', 'warn');
            }
        },
        now() { return Date.now() + BybitBotApp.state.time.serverOffset; },
        nowSec() { return Math.floor(this.now()/1000); },
        tsNow() { const t = this.now(); const { time } = BybitBotApp.state; time.lastTs = t <= time.lastTs ? (time.lastTs + 1) : t; return String(Math.floor(time.lastTs)); },
        suggestedRecvWindow() { const { config } = BybitBotApp; const { netRTT } = BybitBotApp.state.time; const pad = 2 * netRTT + 1500; return Math.max(10000, +config.values.recvWindow || 5000, pad); },
        
        async pub(p, q = {}) {
            const url = this.buildUrl(p, q);
            const tries = 2;
            for (let i=1;i<=tries;i++){
                try {
                const { resp, data } = await this._fetchJsonWithTimeout(url, { method:'GET', headers:{'Accept':'application/json'} }, 15000);
                    if (resp.status === 403 && !BybitBotApp.DOMElements.proxy.value.trim()) { BybitBotApp.DOMElements.corsWarn.style.display = 'block'; }
                // chu·∫©n ho√° l·ªói m·∫°ng
                if (resp.status === 0) throw new Error('Network error');
                return data;
                } catch (e) {
                    if (i < tries) { await new Promise(r=>setTimeout(r, 200 + Math.random()*300)); continue; }
                    throw e;
                }
            }
        },
        async klines(s, i = '5', l = 200) { const j = await this.pub('/v5/market/kline', { category: 'spot', symbol: s, interval: i, limit: l }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list.map(r => ({ t: +r[0], o: +r[1], h: +r[2], l: +r[3], c: +r[4], v: +r[5] })).reverse(); },
        async tickers() { const j = await this.pub('/v5/market/tickers', { category: 'spot' }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list; },
        async instruments(s) { const j = await this.pub('/v5/market/instruments-info', { category: 'spot', symbol: s }); if (j.retCode !== 0) throw new Error(j.retMsg); return j.result.list[0]; },
        async btcOk() { 
             try {
                // Lu√¥n 5m ƒë√∫ng nh∆∞ label
                const k = await this.klines('BTCUSDT', '5', 100);
                const C = k.map(k => k.c);
                const { sma, rsi } = BybitBotApp.utils.indicators;
                return sma(C, 20) > sma(C, 50) && rsi(C, 14) > 48;
             } catch { return true; }
        },
        
        // --- Order Placement (with precision & min rules) ---
        async __norms(symbol) {
            const i = await BybitBotApp.api.instruments(symbol);
            const pr = BybitBotApp.utils.precision;
            const tick = pr.tickOf(i), step = pr.stepOf(i);
            const minQty = +(i?.lotSizeFilter?.minOrderQty ?? 0) || 0;
            const minAmt = +(i?.lotSizeFilter?.minOrderAmt ?? 0) || 0; // quote min for marketUnit=quoteCoin
            const qstep = pr.quoteStepOf(i);
            return { i, pr, tick, step, minQty, minAmt, qstep };
        },
        async buy(symbol, quoteUSDT) {
            const n = await this.__norms(symbol);
            let q = Math.max(+quoteUSDT, n.minAmt || 0);
            // Chu·∫©n ho√° amount theo quotePrecision (qstep) ƒë·ªÉ tr√°nh 170148
            // N·∫øu sau khi floor < minAmt ‚Üí ceil l√™n ƒë√∫ng b·ªôi b∆∞·ªõc
            q = n.pr.floorStep(q, n.qstep);
            if (q < n.minAmt) q = n.pr.ceilStep(n.minAmt, n.qstep);
            const qtyStr = n.pr.fmtAmt(q, n.qstep);
            if (+qtyStr <= 0) throw new Error('Quote amount <= 0 sau khi l√†m tr√≤n');
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Buy', orderType: 'Market',
                marketUnit: 'quoteCoin', qty: qtyStr,
                orderLinkId: `buy_${symbol}_${Date.now()}`
            });
        },
        async sell(symbol, baseQty) {
            const n = await this.__norms(symbol);
            const qty = n.pr.fmtQty(baseQty, n.step);
            return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                category: 'spot', symbol, side: 'Sell', orderType: 'Market',
                marketUnit: 'baseCoin', qty, timeInForce: 'IOC',
                orderLinkId: `sell_${symbol}_${Date.now()}`
            });
        },
        async tp(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapUp(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            // Pre-check: if quote value is below min amount, fallback to EMU OCO to avoid 170140
            if ((+qty) * (+trig) < (n.minAmt || 0)) {
                return { emu: true, type: 'tp', price: trig, qty };
            }
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 1,              // ‚Üë kh·ªõp khi gi√° tƒÉng v∆∞·ª£t
                    triggerBy: 'LastPrice',
                    triggerPrice: String(trig.toFixed(8)),
                    qty,
                    orderLinkId: `tp_${symbol}_${Date.now()}`
                });
            } catch (e) {
                // Fallback sang OCO gi·∫£ l·∫≠p n·∫øu s√†n t·ª´ ch·ªëi StopOrder
                BybitBotApp.ui.logLive(`TP spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'tp', price: trig, qty };
            }
        },
        async sl(symbol, baseQty, price) {
            const n = await this.__norms(symbol);
            const trig = n.pr.snapDown(+price, n.tick);
            const qty = n.pr.fmtQty(baseQty, n.step);
            // Pre-check: if quote value is below min amount, fallback to EMU OCO to avoid 170140
            if ((+qty) * (+trig) < (n.minAmt || 0)) {
                return { emu: true, type: 'sl', price: trig, qty };
            }
            try {
                return await BybitBotApp.api.sign('POST', '/v5/order/create', {}, {
                    category: 'spot', symbol, side: 'Sell',
                    orderType: 'Market',
                    orderFilter: 'StopOrder',
                    triggerDirection: 2,              // ‚Üì kh·ªõp khi gi√° gi·∫£m xuy√™n th·ªßng
                    triggerBy: 'LastPrice',
                    triggerPrice: String(trig.toFixed(8)),
                    qty,
                    orderLinkId: `sl_${symbol}_${Date.now()}`
                });
            } catch (e) {
                BybitBotApp.ui.logLive(`SL spot kh√¥ng h·ªó tr·ª£ tr√™n symbol n√†y (fallback EMU OCO): ${e.message}`, 'warn');
                return { emu: true, type: 'sl', price: trig, qty };
            }
        },
        realtimeOrders: async (s) => await BybitBotApp.api.sign('GET', '/v5/order/realtime', { category: 'spot', symbol: s }),
        async cancelAll(symbol) {
            const { state, ui } = BybitBotApp;
            if (state.cancelLock || state.isStopping) return;
            state.cancelLock = true;
            clearTimeout(state.cancelTimer);
            try { await this.syncTime(true); await this.sign('POST', '/v5/order/cancel-all', {}, { category: 'spot', symbol }); } 
            catch (e) { ui.logLive('Hu·ª∑ l·ªánh th·∫•t b·∫°i: ' + e.message, 'warn'); } 
            finally { state.cancelTimer = setTimeout(() => { state.cancelLock = false; }, 800); }
        },
        async usdtFreeBalance(force=false) {
            const { config } = BybitBotApp;
            const now = Date.now();
            // cache 10s
            if (!force && now - this.balanceCache.ts < 10_000 && this.balanceCache.free >= 0) {
              return this.balanceCache;
            }
            const pref = (config.values.balanceAcct || 'AUTO').toUpperCase();
            const tryOrder = pref === 'AUTO' ? ['SPOT','UNIFIED'] : [pref];

            for (const acct of tryOrder) {
              try {
                const r = await BybitBotApp.api.sign('GET', '/v5/account/wallet-balance', { accountType: acct, coin: 'USDT' });
                const list = r?.list?.[0]?.coin || [];
                const usdt = list.find(c => c.coin === 'USDT');
                if (!usdt) continue;

                let free = 0;
                if (acct === 'SPOT' && usdt.free != null) {
                  free = +usdt.free;
                } else {
                  const wb = +usdt.walletBalance || 0;
                  const locked = +usdt.locked || 0;
                  free = Math.max(wb - locked, 0);
                }
                this.balanceCache = { ts: now, free: +free.toFixed(4), acct };
                return this.balanceCache;
              } catch (e) { /* continue to next account type */ }
            }
            throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c s·ªë d∆∞ USDT.');
          }
    },

    // --- OCO Emulation Module ---
    oco: {
      timer: null,
      async watch(symbol, baseQty, tpPrice, slPrice) {
        clearInterval(this.timer);
        this.timer = setInterval(async () => {
          try {
            const t = await BybitBotApp.api.pub('/v5/market/tickers', { category: 'spot', symbol });
            if (t.retCode !== 0) return;
            const last = +t.result.list[0].lastPrice;
            if (tpPrice && last >= tpPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] TakeProfit @ ${last} ‚Üí SELL`, 'ok');
              await BybitBotApp.api.sell(symbol, baseQty);
            } else if (slPrice && last <= slPrice) {
              clearInterval(this.timer);
              BybitBotApp.ui.logLive(`[OCO-EMU] StopLoss @ ${last} ‚Üí SELL`, 'warn');
              await BybitBotApp.api.sell(symbol, baseQty);
            }
          } catch {}
        }, 1500);
      },
      stop(){ clearInterval(this.timer); }
    },

    // --- WebSocket Module ---
    ws: {
        async connect() {
            try {
                if (BybitBotApp.state.ws.instance) { try { BybitBotApp.state.ws.instance.close() } catch {} }
                const { config, ui, api } = BybitBotApp;
                config.load(); // Ensure latest API keys are used
                const { apiKey, apiSecret } = config.values;
                if (!apiKey || !apiSecret) return ui.logLive('WS private: thi·∫øu API', 'warn');

                const url = config.values.useTestnet ? 'wss://stream-testnet.bybit.com/v5/private' : 'wss://stream.bybit.com/v5/private';
                
                const makeArgs = async () => {
                    const expires = api.now() + 10000; // 10 seconds expiry, in MS
                    const expiresStr = String(Math.floor(expires));
                    const sig = await BybitBotApp.utils.crypto.hmac(apiSecret, `GET/realtime${expiresStr}`);
                    return [apiKey, expiresStr, sig];
                };

                const ws = new WebSocket(url);
                BybitBotApp.state.ws.instance = ws;
                let lastPong = Date.now();

                ws.onopen = async () => {
                    ws.send(JSON.stringify({ op: 'auth', args: await makeArgs() }));
                    clearInterval(BybitBotApp.state.ws.ping);
                    BybitBotApp.state.ws.ping = setInterval(() => { try { ws.send(JSON.stringify({ op: 'ping' })); } catch {} }, 15000);
                    clearInterval(BybitBotApp.state.ws.watchdog);
                    BybitBotApp.state.ws.watchdog = setInterval(() => { if (Date.now() - lastPong > 45000) { ui.logLive('WS private: heartbeat timeout ‚Üí reconnect', 'warn'); try { ws.close(); } catch {} } }, 10000);
                };

                ws.onmessage = async ev => {
                    let msg; try { msg = JSON.parse(ev.data); } catch { return; }
                    if (msg.op === 'pong' || msg.ret_msg === 'pong') { lastPong = Date.now(); return; }
                    if (msg.op === 'auth') {
                        if (msg.success) {
                            BybitBotApp.state.ws.backoff = 3000;
                            ui.logLive('WS private: auth OK', 'ok');
                            ws.send(JSON.stringify({ op: 'subscribe', args: ['order'] }));
                            return;
                        }
                        ui.logLive(`WS private: auth failed (${msg.ret_msg})`, 'error');
                        try { ws.close(); } catch {}
                        // G·ª£i √Ω s·ª≠a l·ªói API
                        ui.logLive('Ki·ªÉm tra l·∫°i API Key/Secret v√† Testnet/Real, sau ƒë√≥ Load API v√† Start l·∫°i.', 'warn');
                        return;
                    }
                    if (msg.topic === 'order') {
                        const { state, liveBot } = BybitBotApp;
                        const ds = msg.data || [];
                        const filledSell = ds.find(o => o.symbol === state.currentPosition.sym && o.side === 'Sell' && (o.orderStatus === 'Filled' || o.orderStatus === 'PartiallyFilled'));
                        if (filledSell) {
                            liveBot.handlePositionExit(filledSell.avgPrice, 'WS Fill');
                        }
                    }
                };
                
                const cleanup = () => {
                    clearInterval(BybitBotApp.state.ws.ping); BybitBotApp.state.ws.ping = null;
                    clearInterval(BybitBotApp.state.ws.watchdog); BybitBotApp.state.ws.watchdog = null;
                };

                ws.onclose = () => {
                    cleanup();
                    ui.logLive('WS private: closed', 'warn');
                    const { state, config } = BybitBotApp;
                    if (state.isRunning && !config.values.simMode) {
                        const d = Math.min(state.ws.backoff, 30000);
                        setTimeout(() => { state.ws.backoff = Math.min(state.ws.backoff * 1.7, 30000); this.connect(); }, d);
                    }
                };
                ws.onerror = () => { cleanup(); ui.logLive('WS private error', 'warn'); };

            } catch (e) {
                BybitBotApp.ui.logLive('M·ªü WS private l·ªói: ' + e.message, 'warn');
            }
        },
        disconnect() {
            const { state } = BybitBotApp;
            clearInterval(state.ws.ping); state.ws.ping = null;
            clearInterval(state.ws.watchdog); state.ws.watchdog = null;
            if (state.ws.instance) { try { state.ws.instance.close() } catch {}; state.ws.instance = null; }
        }
    },

    // --- Journal Module ---
    journal: {
        state: { date: '', loss: 0, pnl: 0, trades: [] },
        today: () => new Date().toISOString().slice(0, 10),
        load() {
            const j = localStorage.getItem('bb_journal_v6');
            this.state = j ? JSON.parse(j) : { date: this.today(), loss: 0, pnl: 0, trades: [] };
            if (this.state.date !== this.today()) this.reset();
            this.updateUI();
        },
        save() {
            localStorage.setItem('bb_journal_v6', JSON.stringify(this.state));
        },
        push(trade) {
            this.state.trades.unshift(trade);
            if (trade.pnl !== undefined) this.state.pnl += trade.pnl;
            if (trade.pnl < 0) this.state.loss += 1;
            else if (trade.pnl > 0) this.state.loss = 0;
            this.save();
            this.updateUI();
        },
        reset() {
            this.state = { date: this.today(), loss: 0, pnl: 0, trades: [] };
            this.save();
            this.updateUI();
            BybitBotApp.ui.logLive('ƒê√£ reset phi√™n giao d·ªãch.', 'ok');
        },
        updateUI() {
            const { DOMElements, ui } = BybitBotApp;
            DOMElements.lossStreak.textContent = this.state.loss;
            DOMElements.pnlDay.textContent = this.state.pnl.toFixed(2);
            ui.renderJournal('journalLive', this.state.trades);
        }
    },

    // --- Live Trading Bot ---
    liveBot: {
        async computeOrderQtyLive(symbol, fixedQuote) {
          const { api, utils, config } = BybitBotApp;
          const info = await api.instruments(symbol);
          const ls = info.lotSizeFilter || {};
          const minOrderAmt = +ls.minOrderAmt || 5;
          const step   = utils.precision.stepOf(info);
          const qstep  = utils.precision.quoteStepOf(info);

          // L·∫•y gi√° hi·ªán t·∫°i
          const kl = await api.klines(symbol, config.values.tf, 2);
          const price = kl[kl.length - 1].c;

          // --- NEW: quote theo balance ---
          let quote = fixedQuote;
          if (config.values.useBalanceSizing) {
            try {
                const { free, acct } = await api.usdtFreeBalance(false);
                const pct   = Math.max(0, Math.min(+config.values.riskPct || 0, 100)) / 100;
                const minQ  = Math.max(+config.values.minQuote || 5, minOrderAmt);
                const maxQ  = Math.max(+config.values.maxQuote || minQ, minQ);
                const rz    = Math.max(+config.values.reserveUsd || 0, 0);

                const capByPct = free * pct;
                const capByFree= Math.max(0, free - rz);
                quote = Math.min(Math.max(capByPct, minQ), maxQ, capByFree);
                if (!isFinite(quote) || quote <= 0) quote = minQ;

                BybitBotApp.ui.logLive(`[Sizing] acct=${acct} free=${free.toFixed(2)} ‚Üí quote=${quote.toFixed(2)} USDT`);
            } catch(e) {
                BybitBotApp.ui.logLive(`L·ªói sizing: ${e.message}. D√πng quote c·ªë ƒë·ªãnh.`, 'warn');
                quote = fixedQuote;
            }
          }

          // ƒê·ªïi ra s·ªë l∆∞·ª£ng base, √©p minQty & step
          let qty = utils.precision.floorStep(quote / price, step);
          const minQty = +(ls.minOrderQty || 0);
          if (minQty && qty < minQty) {
            const times = Math.ceil(minQty / step);
            qty = +(times * step).toFixed(8);
          }
          
          let finalQuote = qty * price;
          // R√†ng amount theo quote step ƒë·ªÉ kh√¥ng b·ªã "decimal too long"
          finalQuote = utils.precision.floorStep(finalQuote, qstep);
          if (finalQuote < minOrderAmt) {
              let qtyForMinAmt = Math.ceil(minOrderAmt / price / step) * step;
              qty = Math.max(qty, qtyForMinAmt);
              finalQuote = utils.precision.floorStep(qty * price, qstep);
              if (finalQuote < minOrderAmt) {
                  // Ceil l√™n m·ª©c min theo b·ªôi b∆∞·ªõc quote (nh·ªè, nh∆∞ng b·∫Øt bu·ªôc)
                  finalQuote = utils.precision.ceilStep(minOrderAmt, qstep);
              }
          }
          return { qty, step, finalQuote };
        },

        async start() {
            const { state, config, api, ui, liveBot, ws } = BybitBotApp;
            if (state.isRunning) return;
            config.load(); // Load latest UI settings
            if (config.values.autoResetStart) BybitBotApp.journal.reset();

            if (!config.values.simMode) {
                const apiKey = BybitBotApp.DOMElements.apiKey.value.trim();
                const apiSecret = BybitBotApp.DOMElements.apiSecret.value.trim();
                if (!apiKey || !apiSecret) return ui.logLive('Thi·∫øu API Key/Secret. Vui l√≤ng n·∫°p API tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.', 'error');
            }

            state.isRunning = true;
            state.isStopping = false;
            await api.syncTime(true);

            if (!config.values.simMode) {
                ws.connect();
            }
            
            ui.updateStatus('ƒêang ch·∫°y...');
            liveBot.scheduler();
            ui.logLive('Bot ƒë√£ b·∫Øt ƒë·∫ßu.', 'ok');
            if (BybitBotApp.config.values['TG_onLifecycle']) { BybitBotApp.telegram.notify('‚ñ∂Ô∏è Bot started'); }
        },

        async stop() {
            const { state, ui, liveBot, ws, oco } = BybitBotApp;
            if (!state.isRunning) return;
            state.isStopping = true;
            state.isRunning = false;
            clearTimeout(state.timers.scheduler);
            if (state.isInPosition) await liveBot.gracefulExit();
            
            ws.disconnect();
            oco.stop(); // Ensure OCO watcher is stopped as well
            
            ui.updateStatus('ƒê√£ d·ª´ng', 'warn');
            ui.logLive('Bot ƒë√£ d·ª´ng.', 'warn');
            if (BybitBotApp.config.values['TG_onLifecycle']) { BybitBotApp.telegram.notify('‚ñ† Bot stopped'); }
            state.isStopping = false;
        },
        
        async gracefulExit() {
            const { state, api, ui, liveBot, ws, oco } = BybitBotApp;
            clearTimeout(state.timers.monitor);
            clearTimeout(state.timers.simMonitor);
            oco.stop();
            
            state.isInPosition = false;
            ui.updateStatus('Nh√†n r·ªói');
            if (state.currentPosition.sym && !BybitBotApp.config.values.simMode) {
                await api.cancelAll(state.currentPosition.sym);
            }
            state.currentPosition = {};
            ws.disconnect();
        },
        
        handlePositionExit(exitPrice, note = '') {
            const { state, journal, ui } = BybitBotApp;
            const baseQty = state.currentPosition.sellQty ?? state.currentPosition.qty;
            const pnl = (exitPrice - state.currentPosition.entry) * baseQty;
            ui.logLive(`‚úÖ ${note}: L·ªánh kh·ªõp @ ${exitPrice} ‚Üí PnL: ${pnl.toFixed(2)}$`, pnl > 0 ? 'ok' : 'bad');
            journal.push({
                ts: Date.now(),
                ...state.currentPosition,
                exit: +exitPrice,
                pnl,
                note
            });
            if (BybitBotApp.config.values['TG_onTrade']) {
                BybitBotApp.telegram.notify(`EXIT ${state.currentPosition.sym} @ ${exitPrice} | PnL ${pnl.toFixed(2)}$`);
            }
            this.gracefulExit();
        },

        async step() {
            const { state, config, api, ui, journal, utils } = BybitBotApp;
            ui.updateStats(); // Update time
            if (journal.state.loss >= config.values.maxLossDay) return ui.updateStatus('T·∫°m d·ª´ng (Max Loss)', 'warn');
            if (state.isInPosition) return;
            if (!BybitBotApp.ui.withinTimeWindow()) return ui.updateStatus('Ngo√†i khung gi·ªù giao d·ªãch', 'warn');
            
            try {
                // Find best symbol
                const symbols = config.values.symbolList.trim() ? config.values.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean) : await this.getUniverseLiveAlt();
                state.currentPosition.watching = symbols.slice(0, 6).join(',') + (symbols.length > 6 ? ' ...' : '');
                
                const btcOk = config.values.btcFilter ? await api.btcOk() : true;
                let dynMin = config.values.minScore;
                if (!btcOk) dynMin += 1;

                let best = null;
                const viewSamples = [];
                for (const sym of symbols) {
                    try {
                        const kl = await api.klines(sym, config.values.tf, 200);
                        const s = utils.strategy.pullbackScore(kl);
                        // collect for visualization first symbol
                        if (!viewSamples.length) {
                          const C = kl.map(k=>k.c); const ema20 = utils.indicators.sma(C,20)||[]; const ema50 = utils.indicators.sma(C,50)||[];
                          viewSamples.push({ kl, ema20, ema50 });
                        }
                        // Add relative strength logic if BTC is not OK
                        if (!btcOk && kl.length >= 10) {
                             const C = kl.map(k=>k.c);
                             const btcKl = await api.klines('BTCUSDT', config.values.tf, 10);
                             const btcROC = (btcKl.at(-1).c - btcKl.at(-10).c) / btcKl.at(-10).c;
                             const roc = (C.at(-1) - C.at(-10)) / C.at(-10);
                             if (roc - btcROC > 0.01) s.score += 1; else s.score -= 1;
                        }
                        if (!best || s.score > best.meta?.score) best = { sym, meta: s };
                    } catch (e) {}
                }
                state.currentPosition.signal = best ? `${best.sym} ‚Ä¢ ƒêi·ªÉm ${best.meta.score}` : '‚Äî';
                // Draw strategy view for top-watching symbol (fallback n·∫øu ch∆∞a c√≥ symbol: BTCUSDT)
                if (viewSamples.length){ const v = viewSamples[0];
                  const C = v.kl.map(k=>k.c);
                  const emaF = utils.indicators.emaSeries(C, 20);
                  const emaS = utils.indicators.emaSeries(C, 50);
                  ui.drawLiveStrategy(v.kl, emaF, emaS, {});
                }
                else {
                  try{
                    const sym = 'BTCUSDT'; const kl = await api.klines(sym, config.values.tf, 200);
                    const C = kl.map(k=>k.c); const ema20 = utils.indicators.emaSeries(C,20); const ema50 = utils.indicators.emaSeries(C,50);
                    ui.drawLiveStrategy(kl, ema20, ema50, {});
                  }catch{}
                }
                ui.updateStats();
                
                if (!best || !config.values.autoMode || best.meta.score < dynMin) return;

                // MTF confirmation
                if (BybitBotApp.DOMElements.CO_mtfEnable?.checked) {
                    try{
                        const tfHi = String(BybitBotApp.DOMElements.CO_mtfTf.value||'15');
                        const klHi = await api.klines(best.sym, tfHi, 60);
                        const C2 = klHi.map(k=>k.c); const ema20 = utils.indicators.sma(C2,20), ema50 = utils.indicators.sma(C2,50);
                        const rhi = utils.indicators.rsi(C2,14)||0;
                        const trendOk = (ema20!=null && ema50!=null) ? (ema20>ema50) : (rhi>50);
                        if (!trendOk) return ui.logLive(`MTF t·ª´ ch·ªëi ${best.sym} (${tfHi})`, 'warn');
                    }catch{}
                }

                // Regime-based presets (AUTO)
                if ((BybitBotApp.DOMElements.CO_regimeMode?.value||'AUTO')==='AUTO'){
                    try{
                        const klRef = await api.klines('BTCUSDT', String(config.values.tf||'5'), 120);
                        const Cb = klRef.map(k=>k.c); const ema20b = utils.indicators.sma(Cb,20), ema50b=utils.indicators.sma(Cb,50);
                        const trb = utils.indicators.trArr(klRef.map(k=>k.h), klRef.map(k=>k.l), Cb); const atrb = utils.indicators.median(trb.slice(-14));
                        const atrp = Cb.length ? atrb/Cb.at(-1) : 0;
                        let mode = 'SIDEWAYS'; if (ema20b>ema50b) mode='TREND'; if (atrp>0.02 && ema20b<ema50b) mode='MEANREV';
                        // apply light preset
                        const E = BybitBotApp.DOMElements; if (mode==='TREND'){ E.B_tpK.value=1.5; E.B_slK.value=0.9; } else if (mode==='MEANREV'){ E.B_tpK.value=1.2; E.B_slK.value=0.8; } else { E.B_tpK.value=1.3; E.B_slK.value=0.9; }
                        E.B_tpK.dispatchEvent(new Event('change')); E.B_slK.dispatchEvent(new Event('change'));
                    }catch{}
                }
                
                // Calculate TP/SL
                const tpsl = utils.strategy.calcTPSL(best.meta.last, best.meta.atr || best.meta.last * 0.005, config.values.B_tpK, config.values.B_slK);
                if (tpsl.rr < 1.2) return ui.logLive(`B·ªè qua ${best.sym}: R:R ${tpsl.rr.toFixed(2)}<1.2`, 'warn');
                
                // Spread/slippage guard (approx using last price & tick size)
                try{
                    const t = await api.pub('/v5/market/tickers', { category:'spot', symbol: best.sym });
                    if (t?.result?.list?.length){ const s = t.result.list[0]; const bid = +s.bid1Price||best.meta.last; const ask = +s.ask1Price||best.meta.last; const spreadBps = (ask-bid)/((ask+bid)/2)*10000; const maxBps = +BybitBotApp.DOMElements.CO_maxSpreadBps?.value||15; if (spreadBps>maxBps) return ui.logLive(`Spread guard: ${best.sym} ${spreadBps.toFixed(1)}bps > ${maxBps}`, 'warn'); }
                }catch{}

                // Calculate quantity
                const { qty, step, finalQuote } = await this.computeOrderQtyLive(best.sym, config.values.orderQuote);
                if (qty <= 0 || finalQuote <= 0) return ui.logLive('Kh√¥ng t√≠nh ƒë∆∞·ª£c s·ªë l∆∞·ª£ng h·ª£p l·ªá', 'warn');
                
                state.isInPosition = true;
                state.currentPosition = { sym: best.sym, entry: best.meta.last, tp: tpsl.tp, sl: tpsl.sl, ts: Date.now(), qty, quote: finalQuote, atr: best.meta.atr || best.meta.last * 0.005 };
                
                if (config.values.simMode) {
                    ui.updateStatus('[SIM] Trong v·ªã th·∫ø');
                    ui.logLive(`[SIM] BUY ${best.sym} @${best.meta.last.toFixed(6)} | TP=${tpsl.tp.toFixed(6)} SL=${tpsl.sl.toFixed(6)}`, 'ok');
                    this.simMonitor();
                    return;
                }
                
                ui.updateStatus('ƒêang mua...');
                const buyOrder = await api.buy(best.sym, finalQuote);
                ui.logLive(`ƒê√£ ƒë·∫∑t l·ªánh BUY ${best.sym} (id=${buyOrder.orderId})`, 'ok');
                ui.updateStatus('Trong v·ªã th·∫ø');
                await api.cancelAll(best.sym);
                if (BybitBotApp.config.values['TG_onTrade']) {
                    BybitBotApp.telegram.notify(`BUY ${best.sym} ~ ${finalQuote.toFixed(2)} USDT`);
                }
                // update overlay
                try{
                    const kl = await api.klines(best.sym, config.values.tf, 200);
                    const C = kl.map(k=>k.c); const ema20 = utils.indicators.emaSeries(C,20); const ema50 = utils.indicators.emaSeries(C,50);
                    ui.drawLiveStrategy(kl, ema20, ema50, { entry: { t: Date.now(), p: best.meta.last }, tp: tpsl.tp, sl: tpsl.sl });
                }catch{}
                
                // Get filled quantity and place OCO
                let filledQty = 0;
                try {
                    // Wait briefly and poll a few times for execution info
                    for (let k=0;k<3;k++){
                        await new Promise(r=>setTimeout(r, 400 + Math.random()*250));
                        const orders = await api.realtimeOrders(best.sym);
                        const exec = orders?.list?.find(o => o.orderId === buyOrder.orderId);
                        filledQty = +(exec?.cumExecQty || 0);
                        if (filledQty > 0) break;
                    }
                } catch (e) {}
                
                let sellQty = filledQty > 0 ? filledQty : qty;
                sellQty = utils.precision.floorStep(sellQty * 0.98, step);
                const info = await api.instruments(best.sym);
                state.currentPosition.sellQty = +utils.precision.fmtQty(sellQty, utils.precision.stepOf(info));
                
                if (config.values.useOCOEmu) {
                    const tpOrder = await api.tp(best.sym, state.currentPosition.sellQty, tpsl.tp);
                    const slOrder = await api.sl(best.sym, state.currentPosition.sellQty, tpsl.sl);
                    if (tpOrder.emu || slOrder.emu) {
                        ui.logLive(`K√≠ch ho·∫°t OCO gi·∫£ l·∫≠p cho ${best.sym}`, 'warn');
                        // Only watch for the side that failed. If TP failed, tpPrice is its trigger. If SL failed, slPrice is its trigger.
                        // If both succeed, tpPrice and slPrice will be null.
                        BybitBotApp.oco.watch(
                            best.sym,
                            state.currentPosition.sellQty,
                            tpOrder.emu ? tpOrder.price : null,
                            slOrder.emu ? slOrder.price : null
                        );
                    } else {
                        ui.logLive(`ƒê√£ ƒë·∫∑t OCO tr√™n s√†n v·ªõi qty=${state.currentPosition.sellQty}`, 'ok');
                    }
                }
                this.monitor();
            } catch (e) {
                ui.logLive('L·ªói trong chu tr√¨nh: ' + (e.message || e), 'error');
                state.isInPosition = false;
            }
        },

        monitor() {
            const { state, config, api, ui, ws, utils } = BybitBotApp;
            // If using reliable WS, no need for REST polling
            if (ws.instance && ws.instance.readyState === WebSocket.OPEN && config.values.useOCOEmu) return;

            clearInterval(state.timers.monitor);
            const startTime = Date.now();
            state.timers.monitor = setInterval(async () => {
                try {
                    const { currentPosition } = state;
                    const kl = await api.klines(currentPosition.sym, '1', 2);
                    const px = kl[kl.length - 1].c;

                    if (Date.now() - startTime > config.values.timeStopMin * 60 * 1000) {
                        ui.logLive('Time-stop, ƒëang tho√°t l·ªánh...', 'warn');
                        const qtyExit = currentPosition.sellQty || currentPosition.qty;
                        try { await api.sell(currentPosition.sym, qtyExit); } catch (e) { ui.logLive('L·ªói Market SELL: ' + e.message, 'warn'); }
                        this.handlePositionExit(px, 'Time-stop');
                        return;
                    }

                    let newSl = currentPosition.sl, needsUpdate = false, isTrailing = false;
                    if (config.values.useBreakeven && !currentPosition.beLocked && px >= currentPosition.entry + 0.6 * currentPosition.atr) {
                        newSl = Math.max(currentPosition.sl, currentPosition.entry - 0.1 * currentPosition.atr);
                        if (newSl > currentPosition.sl) { currentPosition.beLocked = true; ui.logLive(`BE-lock: d·ªùi SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); needsUpdate = true; }
                    }
                    if (config.values.useTrailing && px >= currentPosition.tp) {
                        newSl = Math.max(newSl, px - 0.6 * currentPosition.atr);
                        if (newSl > currentPosition.sl) { ui.logLive(`Trailing SL ‚Üí ${newSl.toFixed(6)}`, 'ok'); needsUpdate = true; isTrailing = true; }
                    }

                    // Partial TP1
                    if (BybitBotApp.DOMElements.CO_tp1Enable?.checked && !currentPosition.tp1Done && px >= currentPosition.tp) {
                        const frac = Math.min(0.9, Math.max(0.1, +BybitBotApp.DOMElements.CO_tp1Frac?.value || 0.4));
                        const sellQty = (currentPosition.sellQty || currentPosition.qty) * frac;
                        try { await api.sell(currentPosition.sym, sellQty); } catch {}
                        currentPosition.sellQty = (currentPosition.sellQty || currentPosition.qty) * (1-frac);
                        currentPosition.tp1Done = true; ui.logLive(`[TP1] Ch·ªët ${Math.round(frac*100)}% t·∫°i ${px}`, 'ok');
                        // Move SL to BE
                        newSl = Math.max(newSl, currentPosition.entry);
                        needsUpdate = true;
                    }

                    if (needsUpdate && config.values.useOCOEmu) {
                        state.currentPosition.sl = newSl;
                        if (isTrailing) state.currentPosition.tp *= 1.05;
                        await api.cancelAll(currentPosition.sym);
                        const qtyToUse = currentPosition.sellQty || currentPosition.qty;
                        await api.tp(currentPosition.sym, qtyToUse, state.currentPosition.tp);
                        await api.sl(currentPosition.sym, qtyToUse, state.currentPosition.sl);
                        // refresh overlay lines
                        try{
                          const kl = await api.klines(currentPosition.sym, BybitBotApp.config.values.tf, 120);
                          const C = kl.map(k=>k.c); const ema20 = BybitBotApp.utils.indicators.emaSeries(C,20); const ema50 = BybitBotApp.utils.indicators.emaSeries(C,50);
                          BybitBotApp.ui.drawLiveStrategy(kl, ema20, ema50, { tp: state.currentPosition.tp, sl: state.currentPosition.sl });
                        }catch{}
                    }
                } catch (e) { ui.logLive('L·ªói theo d√µi l·ªánh: ' + e.message, 'warn'); }
            }, 8000); // Poll less frequently
        },

        simMonitor() {
            const { state, config, ui } = BybitBotApp;
            clearInterval(state.timers.simMonitor);
            const tS = config.values.timeStopMin * 60 * 1000;
            const st = Date.now();
            let p = state.currentPosition.entry;
            state.timers.simMonitor = setInterval(() => {
                const { currentPosition } = state;
                const d = (Math.random() - .48) * currentPosition.atr * .2;
                p += d;
                const checkExit = (e, n) => {
                    this.handlePositionExit(e, 'SIM ' + n);
                };
                if (p >= currentPosition.tp) return checkExit(currentPosition.tp, 'TP hit');
                if (p <= currentPosition.sl) return checkExit(currentPosition.sl, 'SL hit');
                if (Date.now() - st > tS) return checkExit(p, 'Time-stop');
                if (config.values.useBreakeven && !currentPosition.beLocked && p >= currentPosition.entry + .6 * currentPosition.atr) {
                    currentPosition.sl = Math.max(currentPosition.sl, currentPosition.entry - .1 * currentPosition.atr);
                    currentPosition.beLocked = true;
                    ui.logLive('[SIM] BE Lock: SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
                if (config.values.useTrailing && p > currentPosition.tp) {
                    currentPosition.sl = Math.max(currentPosition.sl, p - .6 * currentPosition.atr);
                    ui.logLive('[SIM] Trailing SL -> ' + currentPosition.sl.toFixed(6), 'ok');
                }
            }, 1500);
        },
        
        async getUniverseLiveAlt() {
            const { api, config } = BybitBotApp;
            const list = await api.tickers();
            const EX = new Set(['BTCUSDT', 'ETHUSDT', 'USDCUSDT', 'FDUSDUSDT', 'TUSDUSDT']);
            let cands = list
                .filter(x => x.symbol.endsWith('USDT') && !EX.has(x.symbol))
                .filter(x => +x.turnover24h > 50_000_000)
                .filter(x => +x.lastPrice < 10);
            const quote = config.values.orderQuote;
            const out = [];
            for (const it of cands.slice(0, 80)) {
                try {
                    const info = await api.instruments(it.symbol);
                    const minAmt = +(info.lotSizeFilter?.minOrderAmt || 5);
                    if (minAmt <= quote) out.push(it.symbol);
                    if (out.length >= 30) break;
                } catch {}
            }
            return out.length ? out : cands.slice(0, 30).map(x => x.symbol);
        },
        
        async scheduler() {
            const { state } = BybitBotApp;
            if (!state.isRunning) return;
            await this.step();
            const delay = this.nextCandleDelayMs();
            state.timers.scheduler = setTimeout(() => this.scheduler(), delay);
        },
        
        nextCandleDelayMs() {
            const n = BybitBotApp.api.now();
            const tfSec = { '1': 60, '3': 180, '5': 300, '15': 900 }[BybitBotApp.config.values.tf] || 300;
            const tfMs = tfSec * 1000;
            const delta = (Math.ceil(n / tfMs) * tfMs) - n;
            let wait = BybitBotApp.config.values.scanSec * 1000;
            if (delta < 12000) wait = Math.min(wait, 4000);
            if (delta < 5000) wait = Math.min(wait, 2000);
            return Math.max(1500, wait);
        }
    },

    // --- Backtester Module ---
    backtester: {
        pnlChartInstance: null,

        async run(isGridSearch = false, gridParams = null) {
            const { config, ui, api, DOMElements } = BybitBotApp;
            config.load();

            ui.logBack('B·∫Øt ƒë·∫ßu Backtest...', 'ok');
            DOMElements.B_run.disabled = true;
            DOMElements.B_grid.disabled = true;
            DOMElements.autopilot.disabled = true;
            DOMElements.logBack.innerHTML = '';
            DOMElements.journalBack.querySelector('tbody').innerHTML = '';
            DOMElements.bySymBack.querySelector('tbody').innerHTML = '';
            DOMElements.B_summary.textContent = 'ƒêang ch·∫°y...';

            try {
                const params = gridParams || {
                    tf: String(config.values.B_tf), lookback: config.values.B_lookback, topN: config.values.B_topN,
                    symbolList: config.values.B_symbolList, btcFilter: config.values.B_btcFilter,
                    pessimistic: config.values.B_pessimistic, minScore: config.values.B_minScore,
                    tpK: config.values.B_tpK, slK: config.values.B_slK,
                    timeStopMin: config.values.B_timeStopMin, quote: config.values.B_quote,
                    feePct: config.values.B_feePct, slipBps: config.values.B_slipBps,
                    useBreakeven: config.values.B_useBreakeven, useTrailing: config.values.B_useTrailing
                };

                let symbols;
                if (params.symbolList.trim()) {
                    symbols = params.symbolList.toUpperCase().split(',').map(s => s.trim()).filter(Boolean);
                } else {
                    ui.logBack(`ƒêang t√¨m ${params.topN} coin c√≥ volume cao nh·∫•t...`);
                    const tickers = await api.tickers();
                    symbols = tickers
                        .filter(t => t.symbol.endsWith('USDT') && !/BTC|ETH|USDC|FDUSD|TUSD/.test(t.symbol))
                        .sort((a, b) => +b.turnover24h - +a.turnover24h)
                        .slice(0, params.topN)
                        .map(t => t.symbol);
                }
                ui.logBack(`Backtest tr√™n c√°c symbols: ${symbols.join(', ')}`);

                let btcData = null;
                if (params.btcFilter) {
                    ui.logBack('ƒêang t·∫£i d·ªØ li·ªáu BTC filter...');
                    btcData = await api.klines('BTCUSDT', '5', Math.max(200, params.lookback));
                }

                const allTrades = [];
                for (const sym of symbols) {
                    ui.logBack(`ƒêang x·ª≠ l√Ω ${sym}...`);
                    try {
                        const klines = await api.klines(sym, params.tf, params.lookback);
                        const trades = this.runSymbol(sym, klines, params, btcData);
                        allTrades.push(...trades);
                    } catch (e) {
                        ui.logBack(`L·ªói khi x·ª≠ l√Ω ${sym}: ${e.message}`, 'error');
                    }
                }

                allTrades.sort((a, b) => a.ts - b.ts);
                
                if (isGridSearch) {
                    const totalPnl = allTrades.reduce((sum, t) => sum + t.pnl, 0);
                    return { pnl: totalPnl, trades: allTrades.length };
                }

                this.generateReport(allTrades, params);

            } catch (e) {
                ui.logBack(`Backtest th·∫•t b·∫°i: ${e.message}`, 'error');
                DOMElements.B_summary.textContent = `L·ªói: ${e.message}`;
            } finally {
                DOMElements.B_run.disabled = false;
                DOMElements.B_grid.disabled = false;
                DOMElements.autopilot.disabled = false;
            }
        },

        runSymbol(symbol, klines, params, btcData) {
            const trades = [];
            let inPosition = false;
            let currentTrade = {};
            const { strategy, indicators } = BybitBotApp.utils;
            const tfMs = (params.tf || 5) * 60 * 1000;

            const isBtcOk = (timestamp) => {
                if (!params.btcFilter || !btcData) return true;
                const btcCandleIndex = btcData.findIndex(k => k.t >= timestamp);
                if (btcCandleIndex < 50) return false;
                const btcSlice = btcData.slice(0, btcCandleIndex + 1);
                const C = btcSlice.map(k => k.c);
                return indicators.sma(C, 20) > indicators.sma(C, 50) && indicators.rsi(C, 14) > 48;
            };

            for (let i = 50; i < klines.length; i++) {
                const currentCandle = klines[i];
                const historicalSlice = klines.slice(0, i + 1);

                if (inPosition) {
                    let exitPrice = null, exitNote = '';
                    const slHit = currentCandle.l <= currentTrade.sl, tpHit = currentCandle.h >= currentTrade.tp;
                    if (slHit && tpHit && params.pessimistic) { exitPrice = currentTrade.sl; exitNote = 'SL Hit (Pessimistic)'; }
                    else if (slHit) { exitPrice = currentTrade.sl; exitNote = 'SL Hit'; }
                    else if (tpHit) { exitPrice = currentTrade.tp; exitNote = 'TP Hit'; }

                    if (!exitPrice && (currentCandle.t - currentTrade.ts) / tfMs > params.timeStopMin / params.tf) {
                        exitPrice = currentCandle.c; exitNote = 'Time-stop';
                    }

                    if (!exitPrice) {
                        if (params.useBreakeven && !currentTrade.beLocked && currentCandle.h >= currentTrade.entry + 0.6 * currentTrade.atr) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentTrade.entry); currentTrade.beLocked = true;
                        }
                        if (params.useTrailing && currentCandle.h >= currentTrade.tp) {
                            currentTrade.sl = Math.max(currentTrade.sl, currentCandle.c - 0.6 * currentTrade.atr);
                            currentTrade.tp = currentCandle.c + (currentTrade.initialTp - currentTrade.entry);
                        }
                    }

                    if (exitPrice) {
                        inPosition = false;
                        currentTrade.exit = exitPrice; currentTrade.note = exitNote;
                        const slip = params.slipBps / 10000, fee = params.feePct / 100;
                        const entryCost = currentTrade.qty * currentTrade.entry * (1 + fee + slip);
                        const exitValue = currentTrade.qty * currentTrade.exit * (1 - fee - slip);
                        currentTrade.pnl = exitValue - entryCost;
                        trades.push(currentTrade);
                    }
                }

                if (!inPosition) {
                    const signal = strategy.pullbackScore(historicalSlice);
                    if (signal.score >= params.minScore && isBtcOk(currentCandle.t)) {
                        const entryPrice = currentCandle.c;
                        const tpsl = strategy.calcTPSL(entryPrice, signal.atr, params.tpK, params.slK);
                        if (tpsl.rr >= 1.2) {
                            inPosition = true;
                            currentTrade = {
                                ts: currentCandle.t, sym: symbol, entry: entryPrice, tp: tpsl.tp, sl: tpsl.sl,
                                initialSl: tpsl.sl, initialTp: tpsl.tp, atr: signal.atr, qty: params.quote / entryPrice, beLocked: false,
                            };
                        }
                    }
                }
            }
            return trades;
        },

        generateReport(trades, params) {
            const { ui, DOMElements } = BybitBotApp;
            ui.renderJournal('journalBack', [...trades].reverse());

            if (trades.length === 0) {
                DOMElements.B_summary.textContent = 'Kh√¥ng c√≥ trade n√†o ƒë∆∞·ª£c th·ª±c hi·ªán.';
                this.drawPnlChart([]);
                return;
            }
            
            const bySymbol = {};
            trades.forEach(t => {
                if (!bySymbol[t.sym]) bySymbol[t.sym] = { trades: 0, wins: 0, pnl: 0, sumR: 0 };
                bySymbol[t.sym].trades++; bySymbol[t.sym].pnl += t.pnl;
                const initialRisk = (t.entry - t.initialSl) * t.qty;
                bySymbol[t.sym].sumR += initialRisk > 0 ? t.pnl / initialRisk : 0;
                if (t.pnl > 0) bySymbol[t.sym].wins++;
            });

            const bySymBody = DOMElements.bySymBack.querySelector('tbody'); bySymBody.innerHTML = '';
            Object.entries(bySymbol).forEach(([sym, data]) => {
                bySymBody.innerHTML += `<tr><td>${sym}</td><td>${data.trades}</td><td>${(data.wins/data.trades*100).toFixed(1)}%</td><td class="${data.pnl>0?'ok':'bad'}">${data.pnl.toFixed(2)}</td><td>${(data.sumR/data.trades).toFixed(2)}</td></tr>`;
            });

            const totalPnl = trades.reduce((s, t) => s + t.pnl, 0), wins = trades.filter(t=>t.pnl>0).length, losses = trades.length - wins;
            const grossP = trades.filter(t=>t.pnl>0).reduce((s,t)=>s+t.pnl,0), grossL = Math.abs(trades.filter(t=>t.pnl<0).reduce((s,t)=>s+t.pnl,0));
            
            let equity=[1000], maxEquity=1000, maxDD=0;
            [...trades].sort((a,b)=>a.ts-b.ts).forEach(t => {
                const newEquity = equity[equity.length - 1] + t.pnl;
                equity.push(newEquity); maxEquity = Math.max(maxEquity, newEquity);
                maxDD = Math.max(maxDD, (maxEquity - newEquity) / maxEquity);
            });

            DOMElements.B_summary.textContent = `
K·∫øt qu·∫£ Backtest
----------------------------------
T·ªïng PnL      : ${totalPnl.toFixed(2)} USDT
T·ªïng s·ªë Trades : ${trades.length}
T·ª∑ l·ªá th·∫Øng   : ${trades.length>0?(wins/trades.length*100).toFixed(1):0}% (${wins} W / ${losses} L)
Profit Factor : ${grossL>0?(grossP/grossL).toFixed(2):'‚àû'}
Max Drawdown  : ${(maxDD * 100).toFixed(2)}%`;

            this.drawPnlChart(trades);
        },

        drawPnlChart(trades) {
            if (this.pnlChartInstance) this.pnlChartInstance.destroy();
            const { DOMElements } = BybitBotApp;
            const ctx = DOMElements.pnlChart.getContext('2d');
            let cumulativePnl = 0;
            const equityData = [...trades].sort((a, b) => a.ts - b.ts).map(trade => ({ x: trade.ts, y: cumulativePnl += trade.pnl }));
            this.pnlChartInstance = new Chart(ctx, {
                type: 'line', data: { datasets: [{ label: 'Equity Curve (USDT)', data: equityData, borderColor: '#58a6ff', backgroundColor: 'rgba(88,166,255,0.1)', borderWidth: 2, pointRadius: 0, fill: true }] },
                options: { scales: { x: { type: 'time', time: { unit: 'day' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { grid: { color: 'rgba(255,255,255,0.1)' } } }, plugins: { legend: { display: false } } }
            });
        },

        drawLiveStrategy(kl, emaF, emaS, overlay={}) {
            const E = BybitBotApp.DOMElements; if (!E.liveStrategyChart) return;
            const ctx = E.liveStrategyChart.getContext('2d');
            if (this.liveStratInstance) this.liveStratInstance.destroy();
            const labels = kl.map(k=>k.t);
            const price = kl.map(k=>k.c);
            const ds = [
              { label:'Price', data: price.map((v,i)=>({x:labels[i], y:v})), borderColor:'#0a84ff', pointRadius:0 },
              { label:'EMA20', data: emaF.map((v,i)=>({x:labels[i], y:v})), borderColor:'#34c759', pointRadius:0 },
              { label:'EMA50', data: emaS.map((v,i)=>({x:labels[i], y:v})), borderColor:'#ff9f0a', pointRadius:0 }
            ];
            // overlays
            try{
              if (BybitBotApp.DOMElements.OV_vwap?.checked){
                let sumPV=0, sumV=0; const vwap=[]; for(let i=0;i<kl.length;i++){ const p=(kl[i].h+kl[i].l+kl[i].c)/3; const v=kl[i].v||0; sumPV+=p*v; sumV+=v; vwap.push(sumV? sumPV/sumV : kl[i].c); }
                ds.push({ label:'VWAP', data:vwap.map((v,i)=>({x:labels[i], y:v})), borderColor:'#8e8e93', pointRadius:0 });
              }
              if (BybitBotApp.DOMElements.OV_bb?.checked){
                const period=20; const std=(arr)=>{const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length);};
                const bbU=[], bbL=[]; for(let i=0;i<price.length;i++){ const w=price.slice(Math.max(0,i-period+1), i+1); const m=w.reduce((a,b)=>a+b,0)/w.length; const s=std(w); bbU.push(m+2*s); bbL.push(m-2*s);} 
                ds.push({ label:'BB Upper', data:bbU.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.4)', pointRadius:0 });
                ds.push({ label:'BB Lower', data:bbL.map((v,i)=>({x:labels[i], y:v})), borderColor:'rgba(10,132,255,0.4)', pointRadius:0 });
              }
            }catch{}
            const tMin = labels[0], tMax = labels[labels.length-1];
            if (overlay.entry){
              ds.push({ type:'scatter', label:'Entry', data:[{x: overlay.entry.t||tMax, y: overlay.entry.p}], borderColor:'#34c759', backgroundColor:'#34c759', pointRadius:4, showLine:false });
            }
            if (overlay.exits && overlay.exits.length){
              ds.push({ type:'scatter', label:'Exit', data: overlay.exits.map(e=>({x:e.t||tMax, y:e.p})), borderColor:'#ff3b30', backgroundColor:'#ff3b30', pointRadius:4, showLine:false });
            }
            if (overlay.tp){
              ds.push({ label:'TP', data:[{x:tMin,y:overlay.tp},{x:tMax,y:overlay.tp}], borderColor:'#34c759', borderDash:[6,4], pointRadius:0 });
            }
            if (overlay.sl){
              ds.push({ label:'SL', data:[{x:tMin,y:overlay.sl},{x:tMax,y:overlay.sl}], borderColor:'#ff3b30', borderDash:[6,4], pointRadius:0 });
            }
            this.liveStratInstance = new Chart(ctx, { type:'line', data:{ datasets: ds }, options:{ parsing:false, scales:{ x:{ type:'time'}, y:{} }, plugins:{ legend:{ display:true } } } });
        },

        async gridSearch() {
            const { ui, config, DOMElements } = BybitBotApp;
            ui.logBack('B·∫Øt ƒë·∫ßu Grid Search...', 'ok');
            DOMElements.B_run.disabled = true; DOMElements.B_grid.disabled = true; DOMElements.autopilot.disabled = true;

            const tpRange = [1.0, 1.2, 1.5, 2.0], slRange = [0.6, 0.8, 1.0, 1.2];
            let bestParams = null, bestPnl = -Infinity;
            const totalCombos = tpRange.length * slRange.length;

            for (const [i, tpK] of tpRange.entries()) {
                for (const [j, slK] of slRange.entries()) {
                    const count = i * slRange.length + j + 1;
                    ui.logBack(`[${count}/${totalCombos}] Testing TP=${tpK}, SL=${slK}...`);
                    config.load();
                    const backtestParams = {
                        ...Object.keys(config.values).filter(k=>k.startsWith('B_')).reduce((o,k)=>(o[k.slice(2)]=config.values[k],o),{}),
                        tf: String(config.values.B_tf), tpK: tpK, slK: slK, lookback: 300 // Use shorter lookback for speed
                    };
                    const result = await this.run(true, backtestParams);
                    ui.logBack(`‚Üí PnL: ${result.pnl.toFixed(2)} USDT, Trades: ${result.trades}`);
                    if (result.pnl > bestPnl) { bestPnl = result.pnl; bestParams = { tpK, slK }; }
                }
            }

            if (bestParams) {
                ui.logBack(`Grid Search ho√†n t·∫•t! T·ªët nh·∫•t: TP=${bestParams.tpK}, SL=${bestParams.slK} v·ªõi PnL ${bestPnl.toFixed(2)} USDT`, 'ok');
                DOMElements.B_tpK.value = bestParams.tpK; DOMElements.B_slK.value = bestParams.slK;
                DOMElements.B_tpK.dispatchEvent(new Event('change')); DOMElements.B_slK.dispatchEvent(new Event('change'));
            } else { ui.logBack('Grid Search kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£.', 'warn'); }
            
            DOMElements.B_run.disabled = false; DOMElements.B_grid.disabled = false; DOMElements.autopilot.disabled = false;
            return bestParams;
        },

        async runAutopilot() {
            const { DOMElements, ui, config, liveBot } = BybitBotApp;
            ui.logBack('üöÄ B·∫Øt ƒë·∫ßu Autopilot...', 'ok');
            document.querySelector('.tab[data-tab="back"]').click();

            const bestParams = await this.gridSearch();
            if (!bestParams) { ui.logLive('Autopilot d·ª´ng: kh√¥ng t√¨m ƒë∆∞·ª£c th√¥ng s·ªë t·ªëi ∆∞u.', 'error'); return; }

            ui.logLive('ƒê√£ t·ªëi ∆∞u th√¥ng s·ªë, ƒëang kh·ªüi ƒë·ªông live bot...', 'ok');
            config.load();

            const passphrase = prompt("Nh·∫≠p passphrase ƒë·ªÉ gi·∫£i m√£ API keys cho Autopilot. B·ªè tr·ªëng ƒë·ªÉ ch·∫°y ·ªü ch·∫ø ƒë·ªô SIM mode.");
            DOMElements.simMode.checked = true;
            if (passphrase) {
                DOMElements.passphrase.value = passphrase;
                if (await config.loadApiKeys()) {
                    DOMElements.simMode.checked = false;
                    ui.logLive('API keys ƒë√£ n·∫°p. Ch·∫°y ch·∫ø ƒë·ªô REAL.', 'ok');
                } else ui.logLive('Gi·∫£i m√£ th·∫•t b·∫°i. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'warn');
            } else ui.logLive('Kh√¥ng c√≥ passphrase. Ch·∫°y ch·∫ø ƒë·ªô SIM.', 'ok');

            DOMElements.autoMode.checked = true;
            [DOMElements.autoMode, DOMElements.simMode].forEach(el => el.dispatchEvent(new Event('change')));
            
            document.querySelector('.tab[data-tab="live"]').click();
            liveBot.start();
            ui.logLive('üöÄ Autopilot ƒë√£ kh·ªüi ƒë·ªông!', 'ok');
        }
    },

    // --- App Initialization ---
    init() {
        // Cache all DOM elements
        this.DOMElements = {};
        const allIds = [
            ...this.config.ids, 'status', 'watching', 'signal', 'lastUpdate', 'lossStreak', 'pnlDay',
            'logLive', 'journalLive', 'logBack', 'B_summary', 'pnlChart', 'journalBack', 'bySymBack', 'liveStrategyChart',
            'start', 'stop', 'resetDay', 'saveKeys', 'loadKeys', 'clearKeys', 'btn-tg-send', 'tg-msg',
            'B_run', 'B_grid', 'autopilot', 'corsWarn', 'tab-live', 'tab-back', 'tab-help', 'usdtFree',
            // Radar
            'tab-radar','radar-list','R_scan','R_topN','R_minTurnover','R_maxPrice','R_interval','R_auto',
            'RA_enable','RA_retMin','RA_retPct','RA_volSpike','RA_coolMin',
            // Daily report
            'DR_enable','DR_time','DR_send',
            // News
            'tab-news','news-list','NW_refresh','NW_src_coindesk','NW_src_cointele','NW_src_binance','NW_keywords','NW_interval','NW_auto','NW_forward'
        ];
        allIds.forEach(id => this.DOMElements[id] = document.getElementById(id));

        // Setup UI
        const tabs = [...document.querySelectorAll('.tab')];
        const views = { live: this.DOMElements['tab-live'], back: this.DOMElements['tab-back'], help: this.DOMElements['tab-help'] };
        tabs.forEach(t => t.onclick = () => {
            tabs.forEach(x => x.classList.remove('active'));
            t.classList.add('active');
            Object.values(views).forEach(v => v.classList.remove('active'));
            (views[t.dataset.tab] || this.DOMElements[`tab-${t.dataset.tab}`])?.classList.add('active');
        });

        // Load config and journal
        this.config.loadFromStorage();
        this.journal.load();
        // Apply compact mode on load
        try{ if (this.DOMElements.uiCompact?.checked) document.body.classList.add('compact'); }catch{}
        
        // Attach event listeners
        this.config.ids.forEach(id => {
            const el = this.DOMElements[id];
            if (el) el.addEventListener('change', () => {
                this.config.load();
                this.config.saveToStorage();
                if (id === 'uiCompact') {
                    if (el.checked) document.body.classList.add('compact');
                    else document.body.classList.remove('compact');
                }
            });
        });
        
        this.DOMElements.saveKeys.onclick = () => this.config.saveApiKeys();
        this.DOMElements.loadKeys.onclick = () => this.config.loadApiKeys();
        this.DOMElements.clearKeys.onclick = () => this.config.clearApiKeys();
        this.DOMElements.resetDay.onclick = () => this.journal.reset();
        
        this.DOMElements.start.onclick = () => this.liveBot.start();
        this.DOMElements.stop.onclick = () => this.liveBot.stop();
        
        // Attach backtester listeners
        this.DOMElements.B_run.onclick = () => this.backtester.run();
        this.DOMElements.B_grid.onclick = () => this.backtester.gridSearch();
        this.DOMElements.autopilot.onclick = () => this.backtester.runAutopilot();

        // Radar auto toggle
        const rAuto = this.DOMElements.R_auto; if (rAuto) {
            rAuto.addEventListener('change', ()=>{
                if (rAuto.checked) BybitBotApp.radar.startAuto(); else BybitBotApp.radar.stopAuto();
            });
        }

        // Daily report controls
        if (this.DOMElements.DR_send) this.DOMElements.DR_send.onclick = () => this.dailyReport.sendNow();
        const drEnable = this.DOMElements.DR_enable; if (drEnable) {
            drEnable.addEventListener('change', ()=>{
                if (drEnable.checked) this.dailyReport.start(); else this.dailyReport.stop();
            });
        }

        // Coaching actions
        const coBtn = this.DOMElements.CO_analyze; if (coBtn) coBtn.onclick = () => this.coaching.run();

        // News
        if (this.DOMElements.NW_refresh) this.DOMElements.NW_refresh.onclick = () => this.news.render();
        const nwAuto = this.DOMElements.NW_auto; if (nwAuto){ nwAuto.addEventListener('change', ()=>{ if (nwAuto.checked) this.news.startAuto(); else this.news.stopAuto(); }); }

        // Panic Sell button & hotkey (Shift+P)
        if (this.DOMElements.panicSell) this.DOMElements.panicSell.onclick = async () => {
            try{
                const { state, api, ui } = BybitBotApp; const pos = state.currentPosition; if (!state.isInPosition || !pos?.sym) return;
                ui.logLive('Panic Sell initiated...', 'warn');
                const qtyExit = pos.sellQty || pos.qty; await api.sell(pos.sym, qtyExit);
                BybitBotApp.liveBot.handlePositionExit(pos.entry, 'Panic Sell');
            }catch(e){ BybitBotApp.ui.logLive('Panic Sell error: '+e.message, 'error'); }
        };
        window.addEventListener('keydown', (ev)=>{ if (ev.shiftKey && (ev.key==='P' || ev.key==='p')) this.DOMElements.panicSell?.click(); });
        
        if (this.config.values.autoRun) {
            this.liveBot.start();
        }
        if (this.DOMElements['btn-tg-send']) this.DOMElements['btn-tg-send'].onclick = () => this.telegram.sendTest();
        const vBtn = document.getElementById('btn-tg-validate'); if (vBtn) vBtn.onclick = () => this.telegram.validate();
        const dBtn = document.getElementById('btn-tg-detect'); if (dBtn) dBtn.onclick = () => this.telegram.detectChatId();
    }
};

// --- Start the application ---
window.addEventListener('DOMContentLoaded', () => BybitBotApp.init());

</script>
</body>
</html>
